{"meta":{"title":"æ£®æ£®çš„åšå®¢","subtitle":"ä¼šæŒ½é›•å¼“å¦‚æ»¡æœˆï¼Œè¥¿åŒ—æœ›ï¼Œå°„å¤©ç‹¼ã€‚","description":"20æ¯•ä¸šï¼Œåå°æ–¹å‘ï¼Œè¿˜æœªä¸Šå²¸ã€‚","author":"ForeverSen","url":"http://github.com/ForeverSen/ForeverSen.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:27:12.433Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:56:23.417Z","comments":true,"path":"about/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-01T13:25:30.000Z","updated":"2019-09-10T04:28:42.208Z","comments":true,"path":"friends/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-01T10:23:38.000Z","updated":"2019-09-10T04:28:54.241Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCodeä¸­BFS&DFS","slug":"BFS","date":"2019-05-02T10:25:08.000Z","updated":"2019-09-10T09:52:30.929Z","comments":true,"path":"2019/05/02/bfs/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/02/bfs/","excerpt":"","text":"æ·±åº¦ä¼˜å…ˆéå†DFSï¼š å‡è®¾åˆå§‹çŠ¶æ€æ˜¯å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹å‡æœªè¢«è®¿é—®ï¼Œåˆ™ä»æŸä¸ªé¡¶ç‚¹vå‡ºå‘ï¼Œé¦–å…ˆè®¿é—®è¯¥é¡¶ç‚¹ï¼Œç„¶åä¾æ¬¡ä»å®ƒçš„å„ä¸ªæœªè¢«è®¿é—®çš„é‚»æ¥ç‚¹å‡ºå‘æ·±åº¦ä¼˜å…ˆæœç´¢éå†å›¾ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰å’Œvæœ‰è·¯å¾„ç›¸é€šçš„é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ã€‚ è‹¥æ­¤æ—¶å°šæœ‰å…¶ä»–é¡¶ç‚¹æœªè¢«è®¿é—®åˆ°ï¼Œåˆ™å¦é€‰ä¸€ä¸ªæœªè¢«è®¿é—®çš„é¡¶ç‚¹ä½œèµ·å§‹ç‚¹ï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ä¸ºæ­¢ã€‚ DFSåº”ç”¨ï¼šä½¿ç”¨ DFS å¯¹ä¸€ä¸ªå›¾è¿›è¡Œéå†æ—¶ï¼Œèƒ½å¤Ÿéå†åˆ°çš„èŠ‚ç‚¹éƒ½æ˜¯ä»åˆå§‹èŠ‚ç‚¹å¯è¾¾çš„ï¼ŒDFS å¸¸ç”¨æ¥æ±‚è§£ å•ç‚¹è¿é€šæ€§ã€å•ç‚¹å¯è¾¾æ€§ã€å•ç‚¹è·¯å¾„ç­‰ã€‚ å®ç°ï¼šä½¿ç”¨æ ˆæ¥ä¿å­˜å½“å‰èŠ‚ç‚¹ä¿¡æ¯ï¼Œå½“éå†æ–°èŠ‚ç‚¹è¿”å›æ—¶èƒ½å¤Ÿç»§ç»­éå†å½“å‰èŠ‚ç‚¹ã€‚ä¹Ÿå¯ä»¥ç”¨é€’å½’ã€‚ LeetCodeç›¸å…³é¢˜è§£ï¼š695. Max Area of Islandç»™å®šä¸€ä¸ªåŒ…å«äº†ä¸€äº› 0 å’Œ 1çš„éç©ºäºŒç»´æ•°ç»„ grid , ä¸€ä¸ª å²›å±¿ æ˜¯ç”±å››ä¸ªæ–¹å‘ (æ°´å¹³æˆ–å‚ç›´) çš„ 1 (ä»£è¡¨åœŸåœ°) æ„æˆçš„ç»„åˆã€‚ä½ å¯ä»¥å‡è®¾äºŒç»´çŸ©é˜µçš„å››ä¸ªè¾¹ç¼˜éƒ½è¢«æ°´åŒ…å›´ç€ã€‚æ‰¾åˆ°ç»™å®šçš„äºŒç»´æ•°ç»„ä¸­æœ€å¤§çš„å²›å±¿é¢ç§¯ã€‚(å¦‚æœæ²¡æœ‰å²›å±¿ï¼Œåˆ™è¿”å›é¢ç§¯ä¸º0ã€‚) ç¤ºä¾‹ 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] å¯¹äºä¸Šé¢è¿™ä¸ªç»™å®šçŸ©é˜µåº”è¿”å› 6ã€‚æ³¨æ„ç­”æ¡ˆä¸åº”è¯¥æ˜¯11ï¼Œå› ä¸ºå²›å±¿åªèƒ½åŒ…å«æ°´å¹³æˆ–å‚ç›´çš„å››ä¸ªæ–¹å‘çš„â€˜1â€™ã€‚ ç¤ºä¾‹ 2: [[0,0,0,0,0,0,0,0]]å¯¹äºä¸Šé¢è¿™ä¸ªç»™å®šçš„çŸ©é˜µ, è¿”å› 0ã€‚ æ³¨æ„: ç»™å®šçš„çŸ©é˜µgrid çš„é•¿åº¦å’Œå®½åº¦éƒ½ä¸è¶…è¿‡ 50ã€‚ è§£é¢˜æ€è·¯:ä½¿ç”¨dfsè®¡ç®—æ¯ä¸ªå²›å±¿çš„é¢ç§¯ï¼Œåœ¨dfsæœŸé—´ï¼Œå°†å²›ä¸­æ¯ä¸ªç‚¹çš„å€¼è®¾ç½®ä¸º0ï¼Œè¡¨ç¤ºä¸ºå·²æ ‡è®°ã€‚ /* *ä½¿ç”¨DFSï¼Œå…ˆç”¨äºŒç»´æ•°ç»„å­˜å‚¨å››ä¸ªæ–¹å‘ï¼Œç„¶ååˆ†åˆ«é€’å½’éå†æ¯ä¸ªç‚¹ *éå†è¿‡çš„ç‚¹å°†å…¶ç½®ä¸º0ï¼Œä¸å†éå† */ class Solution { private int m, n; private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};//å››ä¸ªæ–¹å‘ public int maxAreaOfIsland(int[][] grid) { m = grid.length;//è¡Œ n = grid[0].length;//åˆ— int maxArea = 0; if (m == 0 || grid == null) { return 0; } for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { maxArea = Math.max(maxArea,dfs(grid,i,j)); } } return maxArea; } private int dfs(int [][] grid,int i,int j){ if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || grid[i][j] == 0) { return 0; } grid[i][j] = 0;//è®¾ä¸ºå·²æ ‡è®° int area = 1; for (int [] d : direction) { area += dfs(grid,i + d[0],j + d[1]); } return area; } } 200. Number of Islands ç»™å®šä¸€ä¸ªç”± â€˜1â€™ï¼ˆé™†åœ°ï¼‰å’Œ â€˜0â€™ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè®¡ç®—å²›å±¿çš„æ•°é‡ã€‚ä¸€ä¸ªå²›è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”å®ƒæ˜¯é€šè¿‡æ°´å¹³æ–¹å‘æˆ–å‚ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥è€Œæˆçš„ã€‚ä½ å¯ä»¥å‡è®¾ç½‘æ ¼çš„å››ä¸ªè¾¹å‡è¢«æ°´åŒ…å›´ã€‚ Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3è§£é¢˜æ€è·¯ï¼šæœ¬é¢˜è·Ÿä¸Šé¢leetcode695æœ‰ç‚¹ç±»ä¼¼ï¼Œéƒ½æ˜¯å²›å±¿é—®é¢˜ï¼Œå¯ä»¥å°†çŸ©é˜µè¡¨ç¤ºçœ‹æˆä¸€å¼ æœ‰å‘å›¾ï¼ŒæŠŠé—®é¢˜è½¬æ¢ä¸ºå¯¹æ¯ä¸ªç‚¹è¿›è¡ŒDFSéå†ï¼Œå¦‚æœæœ‰éå†å®Œä¸€ä¸ªï¼Œé‚£ä¹ˆå²›å±¿æ•°é‡+1 class Solution { private int directions[][] = {{0,1},{0,-1},{1,0},{-1,0}}; private int m , n; public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } m = grid.length; n = grid[0].length; int num = 0;//å²›å±¿æ•°é‡ for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { if (grid[i][j] != '0') { dfs(grid,i,j); num++; } } } return num; } private void dfs(char [][] grid,int i,int j){ if(i >= m || i &lt; 0 || j >= n || j &lt; 0 || grid[i][j] =='0'){ return; } grid[i][j] = '0';//éå†è¿‡çš„ä¸å†éå† for(int d[] : directions){ dfs(grid,i + d[0],j + d[1]); } } } 547. Friend Circlesç­ä¸Šæœ‰ N åå­¦ç”Ÿã€‚å…¶ä¸­æœ‰äº›äººæ˜¯æœ‹å‹ï¼Œæœ‰äº›åˆ™ä¸æ˜¯ã€‚ä»–ä»¬çš„å‹è°Šå…·æœ‰æ˜¯ä¼ é€’æ€§ã€‚å¦‚æœå·²çŸ¥ A æ˜¯ B çš„æœ‹å‹ï¼ŒB æ˜¯ C çš„æœ‹å‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è®¤ä¸º A ä¹Ÿæ˜¯ C çš„æœ‹å‹ã€‚æ‰€è°“çš„æœ‹å‹åœˆï¼Œæ˜¯æŒ‡æ‰€æœ‰æœ‹å‹çš„é›†åˆã€‚ ç»™å®šä¸€ä¸ª N * N çš„çŸ©é˜µ Mï¼Œè¡¨ç¤ºç­çº§ä¸­å­¦ç”Ÿä¹‹é—´çš„æœ‹å‹å…³ç³»ã€‚å¦‚æœM[i][j] = 1ï¼Œè¡¨ç¤ºå·²çŸ¥ç¬¬ i ä¸ªå’Œ j ä¸ªå­¦ç”Ÿäº’ä¸ºæœ‹å‹å…³ç³»ï¼Œå¦åˆ™ä¸ºä¸çŸ¥é“ã€‚ä½ å¿…é¡»è¾“å‡ºæ‰€æœ‰å­¦ç”Ÿä¸­çš„å·²çŸ¥çš„æœ‹å‹åœˆæ€»æ•°ã€‚ Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1è§£é¢˜æ€è·¯ï¼š DFSä¸­çš„æœ‹å‹åœˆé—®é¢˜ï¼Œæ³¨æ„è¿™æ˜¯ä¸ªN*NçŸ©é˜µï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªhasVisitedæ•°ç»„, ä¾æ¬¡åˆ¤æ–­æ¯ä¸ªèŠ‚ç‚¹, å¦‚æœå…¶æœªè®¿é—®, æœ‹å‹åœˆæ•°åŠ 1å¹¶å¯¹è¯¥èŠ‚ç‚¹è¿›è¡Œdfsæœç´¢æ ‡è®°æ‰€æœ‰è®¿é—®åˆ°çš„èŠ‚ç‚¹ã€‚ class Solution { private int m; //N*NçŸ©é˜µ public int findCircleNum(int[][] M) { if (M.length == 0 || M == null) { return -1; } m = M.length; boolean [] hasVisited = new boolean[m]; //æ˜¯å¦è®¿é—® int circleNum = 0; for (int i = 0; i &lt; m; i++) { if (!hasVisited[i]) { dfs(M,i,hasVisited); circleNum++; } } return circleNum; } private void dfs(int [][] M,int i,boolean [] hasVisited) { hasVisited[i] = true; for (int k = 0; k &lt; m; k++) { if (M[i][k] == 1 &amp;&amp; !hasVisited[k]) dfs(M,k,hasVisited); } } } 207. Course Scheduleç°åœ¨ä½ æ€»å…±æœ‰ n é—¨è¯¾éœ€è¦é€‰ï¼Œè®°ä¸º 0 åˆ° n-1ã€‚ åœ¨é€‰ä¿®æŸäº›è¯¾ç¨‹ä¹‹å‰éœ€è¦ä¸€äº›å…ˆä¿®è¯¾ç¨‹ã€‚ ä¾‹å¦‚ï¼Œæƒ³è¦å­¦ä¹ è¯¾ç¨‹ 0 ï¼Œä½ éœ€è¦å…ˆå®Œæˆè¯¾ç¨‹ 1 ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªåŒ¹é…æ¥è¡¨ç¤ºä»–ä»¬: [0,1] ç»™å®šè¯¾ç¨‹æ€»é‡ä»¥åŠå®ƒä»¬çš„å…ˆå†³æ¡ä»¶ï¼Œåˆ¤æ–­æ˜¯å¦å¯èƒ½å®Œæˆæ‰€æœ‰è¯¾ç¨‹çš„å­¦ä¹ ï¼Ÿ è¾“å…¥: 2, [[1,0]] è¾“å‡º: true è§£é‡Š: æ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å®Œæˆè¯¾ç¨‹ 0ã€‚æ‰€ä»¥è¿™æ˜¯å¯èƒ½çš„ã€‚ è¾“å…¥: 2, [[1,0],[0,1]] è¾“å‡º: false è§£é‡Š: æ€»å…±æœ‰ 2 é—¨è¯¾ç¨‹ã€‚å­¦ä¹ è¯¾ç¨‹ 1 ä¹‹å‰ï¼Œä½ éœ€è¦å…ˆå®Œæˆâ€‹è¯¾ç¨‹ 0ï¼›å¹¶ä¸”å­¦ä¹ è¯¾ç¨‹ 0 ä¹‹å‰ï¼Œä½ è¿˜åº”å…ˆå®Œæˆè¯¾ç¨‹ 1ã€‚è¿™æ˜¯ä¸å¯èƒ½çš„ã€‚è§£é¢˜æ€è·¯ï¼šæ„å»ºé€†é‚»æ¥è¡¨ï¼Œå®ç°æ·±åº¦ä¼˜å…ˆéå†ï¼Œå…¶å®å°±æ˜¯æ£€æµ‹è¿™ä¸ªæœ‰å‘å›¾ä¸­æœ‰æ²¡æœ‰ç¯ï¼Œåªè¦å­˜åœ¨ç¯ï¼Œè¯¾ç¨‹å°±ä¸èƒ½å®Œæˆã€‚å¦å¤–ï¼Œå½“è®¿é—®ä¸€ä¸ªç»“ç‚¹çš„æ—¶å€™ï¼Œåº”è¯¥é€’å½’è®¿é—®å®ƒçš„å‰é©±ç»“ç‚¹ï¼Œç›´è‡³å‰é©±ç»“ç‚¹æ²¡æœ‰å‰é©±ç»“ç‚¹ä¸ºæ­¢ã€‚ /** *é‡‡ç”¨æ·±åº¦ä¼˜å…ˆéå†è§£å†³æœ‰æ— ç¯ *å¦‚æœé‡‡ç”¨BFSä¼šæ›´å¿« **/ class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List&lt;Integer> [] graphic = new List[numCourses]; boolean [] marked = new boolean[numCourses];//åˆ¤æ–­é‚£ä¸ªæ•°æ˜¯å¦è¢«æ ‡è®° for (int i = 0;i &lt; numCourses;i++){ graphic[i] = new ArrayList();//å¯¹æ¯ä¸ªæ•°å­—ç”Ÿæˆä¸€ä¸ªé“¾è¡¨ } for (int [] pre : prerequisites){ graphic[pre[0]].add(pre[1]); } for (int i = 0;i &lt; numCourses;i++){ if(hasCycle(graphic,marked,i)){ return false; } } return true; } //åˆ¤æ–­æ˜¯å¦å«ç¯ private boolean hasCycle(List&lt;Integer> [] graphic,boolean [] marked,int cur){ if (marked[cur]){ return true;//å¦‚æœè¢«æ ‡è®°ï¼Œåˆ™ç›´æ¥è¿”å›true } marked[cur] = true; for (int next : graphic[cur]){ if (hasCycle(graphic,marked,next)){ return true; } } marked[cur] = false; return false; } } 130. Surrounded Regionsç»™å®šä¸€ä¸ªäºŒç»´çš„çŸ©é˜µï¼ŒåŒ…å« â€˜Xâ€™ å’Œ â€˜Oâ€™ï¼ˆå­—æ¯ Oï¼‰ã€‚ æ‰¾åˆ°æ‰€æœ‰è¢« â€˜Xâ€™ å›´ç»•çš„åŒºåŸŸï¼Œå¹¶å°†è¿™äº›åŒºåŸŸé‡Œæ‰€æœ‰çš„ â€˜Oâ€™ ç”¨ â€˜Xâ€™ å¡«å……ã€‚ç¤ºä¾‹: X X X XX O O XX X O XX O X Xè¿è¡Œä½ çš„å‡½æ•°åï¼ŒçŸ©é˜µå˜ä¸ºï¼š X X X XX X X XX X X XX O X Xè§£é‡Š: è¢«å›´ç»•çš„åŒºé—´ä¸ä¼šå­˜åœ¨äºè¾¹ç•Œä¸Šï¼Œæ¢å¥è¯è¯´ï¼Œä»»ä½•è¾¹ç•Œä¸Šçš„ â€˜Oâ€™ éƒ½ä¸ä¼šè¢«å¡«å……ä¸º â€˜Xâ€™ã€‚ ä»»ä½•ä¸åœ¨è¾¹ç•Œä¸Šï¼Œæˆ–ä¸ä¸è¾¹ç•Œä¸Šçš„ â€˜Oâ€™ ç›¸è¿çš„ â€˜Oâ€™ æœ€ç»ˆéƒ½ä¼šè¢«å¡«å……ä¸º â€˜Xâ€™ã€‚å¦‚æœä¸¤ä¸ªå…ƒç´ åœ¨æ°´å¹³æˆ–å‚ç›´æ–¹å‘ç›¸é‚»ï¼Œåˆ™ç§°å®ƒä»¬æ˜¯â€œç›¸è¿â€çš„ã€‚ è§£é¢˜æ€è·¯ï¼šé¦–å…ˆå¯¹çŸ©é˜µè¾¹ç•Œä¸Šæ‰€æœ‰çš„Oåšæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œå°†ç›¸è¿çš„Oæ›´æ”¹ä¸º * ï¼Œç„¶åç¼–è¾‘æ•°ç»„ï¼Œå°†æ•°ç»„ä¸­Oæ›´æ”¹ä¸ºXï¼Œå°†æ•°ç»„ä¸­ * æ›´æ”¹ä¸ºOã€‚ class Solution { private int m,n; private int [] [] directions = {{0,1},{0,-1},{1,0},{-1,0}}; public void solve(char[][] board) { if (board == null || board.length == 0){ return; } m = board.length; n = board[0].length; //è¾¹ç•Œå€¼éå† for (int i = 0; i &lt; m; i++) { dfs(board, i, 0); dfs(board, i, n-1); } for (int j = 0; j &lt; n; j++) { dfs(board, 0, j); dfs(board, m - 1, j); } for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++){ if(board[i][j] == 'O') { board [i][j] = 'X'; //å°†è¢«åŒ…å›´åœ¨ä¸­é—´çš„ç½®ä¸ºX }else if (board[i][j] == '*'){ board [i][j] = 'O'; //å°†è¾¹ç•Œçš„ç½®ä¸ºO } } } } private void dfs(char [][] board, int i, int j) { if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || board[i][j] != 'O'){ return; } board[i][j] = '*'; //å°†è¢«åŒ…å›´çš„Oï¼Œå¹¶ä¸”Oä¸åœ¨è¾¹ç•Œ ç½®ä¸ºå…¶ä»–ç¬¦å· for (int [] d: directions) { dfs(board, i + d[0],j + d[1]); } } } æ€»ç»“ï¼šé€šè¿‡åˆ·é¢˜çŸ¥é“DFSç±»å‹çš„è§£é¢˜æ€è·¯ï¼Œå¤§æ¦‚æœ‰å²›å±¿é—®é¢˜ï¼Œæœ‹å‹åœˆé—®é¢˜ï¼Œæ­¤æ—¶è§£é¢˜æ¨¡æ¿ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œç”¨é€’å½’éå†ï¼Œéå†è¿‡äº†ç‚¹è®¾ä¸ºå·²æ ‡è®°ã€‚ å¹¿åº¦ä¼˜å…ˆéå†BFSï¼š å¹¿åº¦ä¼˜å…ˆæœç´¢ç®—æ³•(Breadth First Search)ï¼Œåˆç§°ä¸ºâ€å®½åº¦ä¼˜å…ˆæœç´¢â€æˆ–â€æ¨ªå‘ä¼˜å…ˆæœç´¢â€ï¼Œç®€ç§°BFSã€‚ å®ƒçš„æ€æƒ³æ˜¯ï¼šä»å›¾ä¸­æŸé¡¶ç‚¹vå‡ºå‘ï¼Œåœ¨è®¿é—®äº†vä¹‹åä¾æ¬¡è®¿é—®vçš„å„ä¸ªæœªæ›¾è®¿é—®è¿‡çš„é‚»æ¥ç‚¹ï¼Œç„¶ååˆ†åˆ«ä»è¿™äº›é‚»æ¥ç‚¹å‡ºå‘ä¾æ¬¡è®¿é—®å®ƒä»¬çš„é‚»æ¥ç‚¹ï¼Œå¹¶ä½¿å¾—â€œå…ˆè¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹å…ˆäºåè¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹è¢«è®¿é—®ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰å·²è¢«è®¿é—®çš„é¡¶ç‚¹çš„é‚»æ¥ç‚¹éƒ½è¢«è®¿é—®åˆ°ã€‚å¦‚æœæ­¤æ—¶å›¾ä¸­å°šæœ‰é¡¶ç‚¹æœªè¢«è®¿é—®ï¼Œåˆ™éœ€è¦å¦é€‰ä¸€ä¸ªæœªæ›¾è¢«è®¿é—®è¿‡çš„é¡¶ç‚¹ä½œä¸ºæ–°çš„èµ·å§‹ç‚¹ï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«è®¿é—®åˆ°ä¸ºæ­¢ã€‚éœ€è¦æ³¨æ„ï¼Œéå†è¿‡çš„èŠ‚ç‚¹ä¸èƒ½å†æ¬¡è¢«éå†ã€‚ BFSåº”ç”¨ï¼šBFSå¯ç”¨äºè§£å†³2ç±»é—®é¢˜ï¼š ä»Aå‡ºå‘æ˜¯å¦å­˜åœ¨åˆ°è¾¾Bçš„è·¯å¾„ï¼›ä»Aå‡ºå‘åˆ°è¾¾Bçš„æœ€çŸ­è·¯å¾„(è¿™ä¸ªåº”è¯¥å«æœ€å°‘æ­¥éª¤åˆç†ï¼Œç¬¬ä¸€æ¬¡éå†åˆ°ç›®çš„èŠ‚ç‚¹ï¼Œå…¶æ‰€ç»è¿‡çš„è·¯å¾„ä¸ºæœ€çŸ­è·¯å¾„)ï¼›æ³¨æ„ï¼Œä½¿ç”¨ BFS åªèƒ½æ±‚è§£æ— æƒå›¾çš„æœ€çŸ­è·¯å¾„ã€‚ å®ç°ï¼šä½¿ç”¨é˜Ÿåˆ—æ¥å­˜å‚¨æ¯ä¸€è½®éå†å¾—åˆ°çš„èŠ‚ç‚¹,å¯¹äºéå†è¿‡çš„èŠ‚ç‚¹ï¼Œåº”è¯¥å°†å®ƒæ ‡è®°ï¼Œé˜²æ­¢é‡å¤éå†ã€‚ å…¸ä¾‹ï¼šè®¡ç®—åœ¨ç½‘æ ¼ä¸­ä»åŸç‚¹åˆ°ç‰¹å®šç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ [[1,1,0,1],[1,0,1,0],[1,1,1,1],[1,0,1,1]] 1 è¡¨ç¤ºå¯ä»¥ç»è¿‡æŸä¸ªä½ç½®ï¼Œæ±‚è§£ä» (0, 0) ä½ç½®åˆ° (tr, tc) ä½ç½®çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚ ç”±äºæ¯ä¸ªç‚¹éœ€è¦ä¿å­˜xåæ ‡ï¼Œyåæ ‡ä»¥åŠé•¿åº¦ï¼Œæ‰€ä»¥å¿…é¡»è¦ç”¨ä¸€ä¸ªç±»å°†ä¸‰ä¸ªå±æ€§å°è£…èµ·æ¥ã€‚ ç”±äºbfsæ¯æ¬¡åªå°†è·ç¦»åŠ ä¸€ï¼Œæ‰€ä»¥å½“ä½ç½®æŠµè¾¾ç»ˆç‚¹æ—¶ï¼Œæ­¤æ—¶çš„è·ç¦»å°±æ˜¯æœ€çŸ­è·¯å¾„äº†ã€‚ private static class Position { int r, c, length; public Position(int r, int c, int length) { this.r = r; this.c = c; this.length = length; } } public static int minPathLength(int[][] grids, int tr, int tc) { int[][] next = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int m = grids.length, n = grids[0].length; Queue&lt;Position> queue = new LinkedList&lt;>(); queue.add(new Position(0, 0, 1)); while (!queue.isEmpty()) { Position pos = queue.poll(); for (int i = 0; i &lt; 4; i++) {//4æ˜¯æ•°ç»„nextçš„é•¿åº¦ Position nextPos = new Position(pos.r + next[i][0], pos.c + next[i][1], pos.length + 1); if (nextPos.r &lt; 0 || nextPos.r >= m || nextPos.c &lt; 0 || nextPos.c >= n) continue; if (grids[nextPos.r][nextPos.c] != 1) continue; grids[nextPos.r][nextPos.c] = 0; if (nextPos.r == tr &amp;&amp; nextPos.c == tc) return nextPos.length; queue.add(nextPos); } } return -1; } LeetCodeç›¸å…³é¢˜è§£ï¼š279. Perfect Square(Medium) é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªæ­£æ•´æ•°nï¼Œæ±‚å’Œä¸ºnçš„æœ€å°å…¨å¹³æ–¹æ•°ï¼ˆä¾‹å¦‚ï¼Œ1ï¼Œ4ï¼Œ9ï¼Œ16ï¼Œâ€¦ï¼‰ã€‚Input: n = 12Output: 3Explanation: 12 = 4 + 4 + 4. Input: n = 13Output: 2Explanation: 13 = 4 + 9. è§£é¢˜æ€è·¯: æ€è·¯æ¥æºå‚è€ƒ@CyC2018Leetcodeåˆ·é¢˜é¢˜è§£ å¯ä»¥å°†æ¯ä¸ªæ•´æ•°çœ‹æˆå›¾ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœä¸¤ä¸ªæ•´æ•°ä¹‹å·®ä¸ºä¸€ä¸ªå¹³æ–¹æ•°ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ•´æ•°æ‰€åœ¨çš„èŠ‚ç‚¹å°±æœ‰ä¸€æ¡è¾¹ã€‚ è¦æ±‚è§£æœ€å°çš„å¹³æ–¹æ•°æ•°é‡ï¼Œå°±æ˜¯æ±‚è§£ä»èŠ‚ç‚¹ n åˆ°èŠ‚ç‚¹ 0 çš„æœ€çŸ­è·¯å¾„ã€‚ é¦–å…ˆç”Ÿæˆå¹³æ–¹æ•°åºåˆ—æ”¾å…¥æ•°ç»„ï¼Œç„¶åé€šè¿‡é˜Ÿåˆ—ï¼Œæ¯æ¬¡å‡å»ä¸€ä¸ªå¹³æ–¹æ•°ï¼ŒæŠŠå‰©ä¸‹çš„æ•°åŠ å…¥é˜Ÿåˆ—ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡bfsçš„æ–¹å¼ï¼Œå½“æ­¤æ—¶çš„æ•°åˆšå¥½ç­‰äºå¹³æ–¹æ•°ï¼Œåˆ™æ»¡è¶³é¢˜æ„ï¼Œç”±äºæ¯æ¬¡å¾ªç¯levelåŠ ä¸€ï¼Œæ‰€ä»¥æœ€åè¾“å‡ºçš„levelå°±æ˜¯éœ€è¦çš„å¹³æ–¹æ•°ä¸ªæ•° class Solution { public int numSquares(int n) { List&lt;Integer> squares = getSquares(n);//è·å–æ‰€æœ‰å¹³æ–¹æ•°ï¼Œå­˜åœ¨é“¾è¡¨ä¸­ Queue&lt;Integer> queue = new LinkedList&lt;>(); boolean[] marked = new boolean[n + 1];//è¿™é‡Œæ˜¯n+1ï¼Œæ¯”è¾ƒå¥½è®¡ç®— queue.add(n); marked[n] = true; int level = 0;//levelä¸ºç¬¬å‡ å±‚ while(!queue.isEmpty()){ int size = queue.size(); level++; while(size-- > 0){ int top = queue.poll(); for(int s : squares){ if (top - s==0){ return level; } if (top - s &lt; 0){ break; } if (marked[top - s]){ continue; } marked[top - s] =true;//æ ‡è®°ä¸ºtrueçš„ä¸å†éå† queue.add(top - s); } } } return n; } //å…ˆå®šä¹‰ä¸€ä¸ªæ±‚å°äºnçš„æ‰€æœ‰å¹³æ–¹æ•°çš„æ–¹æ³• private List getSquares(int n){ List&lt;Integer> list = new ArrayList&lt;>(); int square = 1; int i = 3; while (square &lt;= n){ list.add(square); square += i; i += 2; } return list; } } ```","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BFS-DFS/"}]},{"title":"LeetCodeä¸­å¸¸è§çš„é“¾è¡¨é¢˜ç›®","slug":"é“¾è¡¨","date":"2019-04-28T07:45:28.000Z","updated":"2019-09-10T09:47:00.811Z","comments":true,"path":"2019/04/28/lian-biao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/28/lian-biao/","excerpt":"","text":"å¼€å§‹å¯¹LeetCodeä¸­é“¾è¡¨ç›¸å…³é—®é¢˜è¿›è¡Œåˆ·é¢˜ğŸ¤” 206. Reverse Linked Listé¢˜ç›®æè¿°ï¼šåè½¬ä¸€ä¸ªå•é“¾è¡¨ã€‚ ç¤ºä¾‹: è¾“å…¥: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLè¾“å‡º: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL è§£é¢˜æ€è·¯ï¼š1 â†’ 2 â†’ 3 â†’ 4â†’ 5â†’ Ã˜ï¼Œæ”¹æˆ Ã˜ â† 1 â† 2 â† 3â†4â†5å®šä¹‰ä¸€ä¸ªå‰ç»“ç‚¹preå’Œå½“å‰ç»“ç‚¹curï¼Œåœ¨éå†åˆ—è¡¨æ—¶ï¼Œå°†å½“å‰èŠ‚ç‚¹çš„ next æŒ‡é’ˆæ”¹ä¸ºæŒ‡å‘å‰é¢ä¸€ä¸ªå…ƒç´ ã€‚ /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; //å‰ä¸€ä¸ªèŠ‚ç‚¹ ListNode cur = head; while (cur != null) { ListNode nextNode = cur.next; cur.next = pre; //æŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹ pre = cur; cur = nextNode; } return pre; } } 21. Merge Two Sorted Listsé¢˜ç›®æè¿°ï¼šåˆå¹¶ä¸¤ä¸ªå·²æ’åºçš„é“¾è¡¨ï¼Œå¹¶å°†å…¶ä½œä¸ºä¸€ä¸ªæ–°åˆ—è¡¨è¿”å›ã€‚æ–°åˆ—è¡¨åº”è¯¥é€šè¿‡å°†å‰ä¸¤ä¸ªåˆ—è¡¨çš„èŠ‚ç‚¹æ‹¼æ¥åœ¨ä¸€èµ·æ¥åˆ›å»ºã€‚ Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 è§£é¢˜æ€è·¯ï¼šåˆ©ç”¨é€’å½’ï¼Œæ¯”è¾ƒä¸¤ä¸ªé“¾è¡¨ç¬¬ä¸€ä¸ªç»“ç‚¹çš„å¤§å°ï¼Œç¡®å®šå¤´ç»“ç‚¹çš„ä½ç½® ï¼Œå¤´ç»“ç‚¹ç¡®å®šåï¼Œç»§ç»­åœ¨å‰©ä¸‹çš„ç»“ç‚¹ä¸­é€‰å‡ºä¸‹ä¸€ä¸ªç»“ç‚¹å»é“¾æ¥åˆ°ç¬¬äºŒæ­¥é€‰å‡ºçš„ç»“ç‚¹åé¢ï¼Œç„¶ååœ¨ç»§ç»­é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´åˆ°æœ‰é“¾è¡¨ä¸ºç©ºã€‚ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; //å…ˆåˆ¤æ–­ä¸¤ä¸ªé“¾è¡¨çš„ç¬¬ä¸€ä¸ªæ•°è°æ¯”è¾ƒå¤§ if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; } else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 83. Remove Duplicates from Sorted Listé¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªæ’åºé“¾è¡¨ï¼Œåˆ é™¤æ‰€æœ‰é‡å¤çš„å…ƒç´ ï¼Œä½¿å¾—æ¯ä¸ªå…ƒç´ åªå‡ºç°ä¸€æ¬¡ã€‚ Example 1: Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3è§£é¢˜æ€è·¯ï¼šå¯ä»¥ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶æŒ‡é’ˆnodeï¼Œéœ€è¦æ³¨æ„å¤´æŒ‡é’ˆâ€œheadâ€ä¸åº”è¯¥ç›´æ¥ç§»åŠ¨æˆ–æ›´æ–°ï¼Œå› ä¸ºå®ƒæŒ‡å‘åˆ—è¡¨çš„å¤´éƒ¨ï¼Œä½ éœ€è¦åœ¨æœ€åè¿”å›è¿™ä¸ªå¤´éƒ¨ã€‚æ‰€æœ‰æ“ä½œéƒ½åº”è¯¥ä½¿ç”¨â€œnodeâ€æ¥é˜²æ­¢ä¸¢å¤±å¤´éƒ¨ã€‚ class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null){ return null; } ListNode node = head; //ä½¿ç”¨ä¸´æ—¶æŒ‡é’ˆ while (node.next != null) { if (node.val == node.next.val) { node.next = node.next.next; }else{ node = node.next; } } return head; } } ä¹Ÿå¯ä»¥ä½¿ç”¨é€’å½’ï¼š class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; } } 24. Swap Nodes in Pairsé¢˜ç›®æè¿°ï¼šå®šä¸€ä¸ªé“¾è¡¨ï¼Œäº¤æ¢æ¯ä¸¤ä¸ªç›¸é‚»èŠ‚ç‚¹å¹¶è¿”å›å…¶å¤´éƒ¨ã€‚ ä¸èƒ½ä¿®æ”¹åˆ—è¡¨èŠ‚ç‚¹ä¸­çš„å€¼ï¼Œåªèƒ½æ›´æ”¹èŠ‚ç‚¹æœ¬èº«ã€‚ Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.è§£é¢˜æ€è·¯ï¼šæœ¬é¢˜åŒæ ·å¯ä»¥ä½¿ç”¨é€’å½’æˆ–è€…æŒ‰ç…§è¿­ä»£ï¼Œä¸¤ç§æ–¹å¼è¿è¡Œé€Ÿåº¦å’Œå†…å­˜éƒ½å·®ä¸å¤šã€‚ è¿­ä»£ï¼š // 1->2->3->4 class Solution { public ListNode swapPairs(ListNode head) { ListNode node = new ListNode(0); node.next = head; ListNode temp = node; while (temp.next != null &amp;&amp; temp.next.next != null) { ListNode l1 = temp.next; ListNode l2 = temp.next.next; ListNode next = l2.next; temp.next = l2; l2.next = l1; l1.next = next; temp = l1; } return node.next; //headæ­¤æ—¶å·²è¢«æ”¹å˜ } } é€’å½’ï¼š class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; } } 19.Remove Nth Node From End of Listé¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œåˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ n ä¸ªèŠ‚ç‚¹ï¼Œå¹¶ä¸”è¿”å›é“¾è¡¨çš„å¤´ç»“ç‚¹ã€‚ Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.è§£é¢˜æ€è·¯ï¼šé¢˜ç›®é‚£é‡Œæè¿°å¯å¦ç”¨ä¸€æ¬¡éå†å°±å®Œæˆï¼Œåˆšå¼€å§‹æˆ‘åªæƒ³åˆ°ç”¨ä¸¤æ¬¡éå†ï¼Œåæ¥å‘ç°è¿˜å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆå®ç°ä¸€æ¬¡éå†å°±è§£é¢˜ï¼š ä¸¤æ¬¡éå†ï¼šåˆ é™¤ä»åˆ—è¡¨å¼€å¤´æ•°èµ·çš„ç¬¬ (L - n + 1) ä¸ªç»“ç‚¹ï¼Œå…¶ä¸­ L æ˜¯åˆ—è¡¨çš„é•¿åº¦ã€‚ç¬¬ä¸€æ¬¡éå†ä¸­å…ˆç®—å‡ºé“¾è¡¨é•¿åº¦ï¼Œç¬¬äºŒæ¬¡éå†åˆ é™¤è¯¥æ•°ï¼Œæ³¨æ„æ·»åŠ ä¸€ä¸ªä¸´æ—¶ç»“ç‚¹ä½œä¸ºè¾…åŠ©ï¼Œè¯¥ç»“ç‚¹ä½äºåˆ—è¡¨å¤´éƒ¨ã€‚è¯¥ç»“ç‚¹ç”¨æ¥ç®€åŒ–æŸäº›æç«¯æƒ…å†µï¼Œä¾‹å¦‚åˆ—è¡¨ä¸­åªå«æœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œæˆ–éœ€è¦åˆ é™¤åˆ—è¡¨çš„å¤´éƒ¨ã€‚ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode temp= new ListNode(0); //ä¸´æ—¶ç»“ç‚¹ temp.next = head; ListNode node = head; int length = 0; //é“¾è¡¨é•¿åº¦ while (node != null) { node = node.next; length++; } length -= n; node = temp; while (length > 0) { length--; node = node.next; } node.next = node.next.next; return temp.next; } } ä¸€æ¬¡éå†ï¼šä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªæŒ‡é’ˆfastå…ˆå¼€å§‹ç§»åŠ¨næ­¥ï¼Œç„¶åç¬¬äºŒä¸ªæŒ‡é’ˆslowä»å¤´å¼€å§‹ç§»åŠ¨ï¼Œæ­¤æ—¶ç¬¬ä¸€ä¸ªæŒ‡é’ˆä¹Ÿä¸€èµ·ç§»åŠ¨ï¼Œè¿™æ ·å°±å¯ä»¥ä½¿å¾—åœ¨ç§»åŠ¨è¿‡ç¨‹ä¸­ä¸¤ä¸ªæŒ‡é’ˆä¿æŒnæ­¥çš„è·ç¦»ï¼Œç›´åˆ°faståˆ°è¾¾æœ€åä¸€ä¸ªç»“ç‚¹ã€‚æ­¤æ—¶slowå°†æŒ‡å‘ä»æœ€åä¸€ä¸ªç»“ç‚¹æ•°èµ·çš„ç¬¬ n ä¸ªç»“ç‚¹ï¼Œæˆ‘ä»¬é‡æ–°é“¾æ¥slowæ‰€å¼•ç”¨çš„ç»“ç‚¹çš„ next æŒ‡é’ˆæŒ‡å‘è¯¥ç»“ç‚¹çš„ä¸‹ä¸‹ä¸ªç»“ç‚¹ã€‚ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head; while (n-- > 0) { fast = fast.next; } if (fast == null) return head.next; //é˜²æ­¢æç«¯æƒ…å†µ ListNode slow = head; while (fast.next != null) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return head; } } 725. Split Linked List in Partsé¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªå¤´ç»“ç‚¹ä¸º root çš„é“¾è¡¨, ç¼–å†™ä¸€ä¸ªå‡½æ•°ä»¥å°†é“¾è¡¨åˆ†éš”ä¸º k ä¸ªè¿ç»­çš„éƒ¨åˆ†ã€‚æ¯éƒ¨åˆ†çš„é•¿åº¦åº”è¯¥å°½å¯èƒ½çš„ç›¸ç­‰: ä»»æ„ä¸¤éƒ¨åˆ†çš„é•¿åº¦å·®è·ä¸èƒ½è¶…è¿‡ 1ï¼Œä¹Ÿå°±æ˜¯è¯´å¯èƒ½æœ‰äº›éƒ¨åˆ†ä¸º nullã€‚è¿™kä¸ªéƒ¨åˆ†åº”è¯¥æŒ‰ç…§åœ¨é“¾è¡¨ä¸­å‡ºç°çš„é¡ºåºè¿›è¡Œè¾“å‡ºï¼Œå¹¶ä¸”æ’åœ¨å‰é¢çš„éƒ¨åˆ†çš„é•¿åº¦åº”è¯¥å¤§äºæˆ–ç­‰äºåé¢çš„é•¿åº¦ã€‚è¿”å›ä¸€ä¸ªç¬¦åˆä¸Šè¿°è§„åˆ™çš„é“¾è¡¨çš„åˆ—è¡¨ã€‚ä¸¾ä¾‹ï¼š 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 ç»“æœ [ [1], [2], [3], [4], null ] ç¤ºä¾‹ 1ï¼š è¾“å…¥: root = [1, 2, 3], k = 5 è¾“å‡º: [[1],[2],[3],[],[]] è§£é‡Š: è¾“å…¥è¾“å‡ºå„éƒ¨åˆ†éƒ½åº”è¯¥æ˜¯é“¾è¡¨ï¼Œè€Œä¸æ˜¯æ•°ç»„ã€‚ ä¾‹å¦‚, è¾“å…¥çš„ç»“ç‚¹ root çš„ val= 1, root.next.val = 2, \\root.next.next.val = 3, ä¸” root.next.next.next = nullã€‚ ç¬¬ä¸€ä¸ªè¾“å‡º output[0] æ˜¯ output[0].val = 1, output[0].next = nullã€‚ æœ€åä¸€ä¸ªå…ƒç´  output[4] ä¸º null, å®ƒä»£è¡¨äº†æœ€åä¸€ä¸ªéƒ¨åˆ†ä¸ºç©ºé“¾è¡¨ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 è¾“å‡º: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] è§£é‡Š: è¾“å…¥è¢«åˆ†æˆäº†å‡ ä¸ªè¿ç»­çš„éƒ¨åˆ†ï¼Œå¹¶ä¸”æ¯éƒ¨åˆ†çš„é•¿åº¦ç›¸å·®ä¸è¶…è¿‡1.å‰é¢éƒ¨åˆ†çš„é•¿åº¦å¤§äºç­‰äºåé¢éƒ¨åˆ†çš„é•¿åº¦ã€‚è§£é¢˜æ€è·¯ï¼šé¦–å…ˆæ±‚å‡ºé“¾è¡¨é•¿åº¦ï¼Œç„¶åçœ‹é“¾è¡¨é•¿åº¦æ˜¯å¦å¹³å‡åˆ†é…ï¼Œå¯¹å…¶æ±‚ä½™æ•°å³å¯ï¼Œç„¶åç”¨æ•°ç»„æ¥ä¿å­˜æ¯ä¸€ä¸ªåˆ‡å‰²é‚£éƒ¨åˆ†ï¼Œæœ€ç»ˆå°†åˆ‡æ–­ä¸Šä¸€éƒ¨åˆ†çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹å’Œä¸‹ä¸€éƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„é“¾æ¥ã€‚ class Solution { public ListNode[] splitListToParts(ListNode root, int k) { ListNode node = root; int length = 0; //é“¾è¡¨é•¿åº¦ while (node != null) { length++; node = node.next; } node = root; int mod = length % k; //å“ªä¸€ä¸ªå¤šä½™ int size = length / k; //åˆ†æˆå‡ éƒ¨åˆ† ListNode result [] = new ListNode[k]; //ç”¨æ•°ç»„ä¿å­˜ for (int i = 0; node != null &amp;&amp; i &lt; k; i++) { result[i] = node; int cursize = size + (mod-- > 0 ? 1:0); for (int j = 0; j &lt; cursize - 1; j++) { node = node.next; } ListNode next = node.next; node.next = null; node = next; } return result; } } æ€»ç»“ï¼šåœ¨é“¾è¡¨ä¸­è¦ç†è§£æ¯ä¸ªèŠ‚ç‚¹å’Œæ¯ä¸ªèŠ‚ç‚¹æ˜¯ç›¸è¿çš„ï¼Œå¦‚ä½•æ¥æ±‚é“¾è¡¨é•¿åº¦ï¼Œæ—¶åˆ»è¦æ³¨æ„ä½¿ç”¨ä¸´æ—¶æŒ‡é’ˆæ¥ä»£æ›¿å¤´éƒ¨åˆ†æˆ–è€…å…¶ä»–éƒ¨åˆ†ï¼›ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼ˆä¸€ä¸ªå¿«æŒ‡é’ˆï¼Œä¸€ä¸ªæ…¢æŒ‡é’ˆï¼‰æ±‚é“¾è¡¨ä¸­çš„ä¸­é—´ç»“ç‚¹ï¼›åŒæ—¶ä¸­ä¹Ÿè¦çµæ´»è¿ç”¨é€’å½’å’Œè¿­ä»£ã€‚ å¯¹é“¾è¡¨åˆ·é¢˜å‘Šä¸€æ®µè½ï¼Œå¼€å§‹æ–°çš„tagåˆ·é¢˜ğŸ˜€","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"é“¾è¡¨","slug":"é“¾è¡¨","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/é“¾è¡¨/"}]},{"title":"LeetCodeä¸­æ ˆå’Œé˜Ÿåˆ—ç›¸å…³é¢˜ç›®","slug":"æ ˆå’Œé˜Ÿåˆ—","date":"2019-04-15T08:28:52.000Z","updated":"2019-09-10T09:48:53.469Z","comments":true,"path":"2019/04/15/zhan-he-dui-lie/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/15/zhan-he-dui-lie/","excerpt":"","text":"æ ˆå’Œé˜Ÿåˆ—å¼€å§‹å¯¹æ•°æ®ç»“æ„ä¸­æ ˆå’Œé˜Ÿåˆ—ç›¸å…³é¢˜ç›®è¿›è¡Œåˆ·é¢˜~ 155. æœ€å°æ ˆé¢˜ç›®æè¿°ï¼šè®¾è®¡ä¸€ä¸ªæ”¯æŒ pushï¼Œpopï¼Œtop æ“ä½œï¼Œå¹¶èƒ½åœ¨å¸¸æ•°æ—¶é—´å†…æ£€ç´¢åˆ°æœ€å°å…ƒç´ çš„æ ˆã€‚ push(x) â€“ å°†å…ƒç´  x æ¨å…¥æ ˆä¸­ã€‚pop() â€“ åˆ é™¤æ ˆé¡¶çš„å…ƒç´ ã€‚top() â€“ è·å–æ ˆé¡¶å…ƒç´ ã€‚getMin() â€“ æ£€ç´¢æ ˆä¸­çš„æœ€å°å…ƒç´ ã€‚ è§£é¢˜æ€è·¯ï¼šæœ€å°å€¼æ ˆé—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæ ˆï¼Œä¸€ä¸ªå­˜æ”¾æ•°æ®ï¼Œä¸€ä¸ªå­˜æ”¾æœ€å°å€¼ï¼Œæ¯æ¬¡æ’å…¥æ•°æ®æ—¶ä¸¤ä¸ªæ ˆéƒ½è¦æ’å…¥ï¼Œåˆ é™¤æ—¶æ¯ä¸ªæ ˆä¹Ÿè¦åˆ é™¤ã€‚ è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªæ ˆçš„è§£å†³æ–¹æ¡ˆå€¼å¾—å‚è€ƒ class MinStack { private Stack&lt;Integer> dataStack; //å­˜æ”¾æ•°æ® private Stack&lt;Integer> minStack; //å­˜æœ€å°å€¼ int min; /** initialize your data structure here. */ public MinStack() { dataStack = new Stack&lt;>(); minStack = new Stack&lt;>(); min = Integer.MAX_VALUE; } public void push(int x) { dataStack.push(x); min = Math.min(min,x); minStack.push(min); } public void pop() { dataStack.pop(); minStack.pop(); min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek(); } public int top() { return dataStack.peek(); } public int getMin() { return minStack.peek(); } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 232. ç”¨æ ˆå®ç°é˜Ÿåˆ—é¢˜ç›®æè¿°ï¼šä½¿ç”¨æ ˆå®ç°é˜Ÿåˆ—çš„ä¸‹åˆ—æ“ä½œï¼š push(x) â€“ å°†ä¸€ä¸ªå…ƒç´ æ”¾å…¥é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚pop() â€“ ä»é˜Ÿåˆ—é¦–éƒ¨ç§»é™¤å…ƒç´ ã€‚peek() â€“ è¿”å›é˜Ÿåˆ—é¦–éƒ¨çš„å…ƒç´ ã€‚empty() â€“ è¿”å›é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚ ç¤ºä¾‹ï¼šMyQueue queue = new MyQueue(); queue.push(1);queue.push(2);queue.peek(); // è¿”å› 1queue.pop(); // è¿”å› 1queue.empty(); // è¿”å› false è§£é¢˜æ€è·¯ï¼šæ ˆçš„ç‰¹ç‚¹æ˜¯åè¿›å…ˆå‡ºï¼Œè€Œé˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºï¼Œå› æ­¤ï¼Œå¯ä»¥è€ƒè™‘ç”¨ä¸¤ä¸ªæ ˆæ¥å®ç°ï¼Œè¿™æ ·å°±èƒ½è¾¾åˆ°å…ˆè¿›å…ˆå‡ºçš„æ•ˆæœã€‚stack1è¡¨ç¤ºå…¥æ ˆï¼Œstack2è¡¨ç¤ºå‡ºæ ˆã€‚ class MyQueue { private Stack&lt;Integer> stack1; //å…¥æ ˆ private Stack&lt;Integer> stack2; //å‡ºæ ˆ /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;>(); stack2 = new Stack&lt;>(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { peek(); //æ‰§è¡Œä»£ç ç±»åŒpeek() æ•…ç”¨peekä»£æ›¿ return stack2.pop(); } /** Get the front element. */ public int peek() { if (stack2.isEmpty()){ while (!stack1.isEmpty()) { int temp = stack1.pop(); stack2.push(temp); } } return stack2.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack2.isEmpty() &amp;&amp; stack1.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. ç”¨é˜Ÿåˆ—å®ç°æ ˆé¢˜ç›®æè¿°ï¼šä½¿ç”¨é˜Ÿåˆ—å®ç°æ ˆçš„ä¸‹åˆ—æ“ä½œï¼š push(x) â€“ å…ƒç´  x å…¥æ ˆpop() â€“ ç§»é™¤æ ˆé¡¶å…ƒç´ top() â€“ è·å–æ ˆé¡¶å…ƒç´ empty() â€“ è¿”å›æ ˆæ˜¯å¦ä¸ºç©º è§£é¢˜æ€è·¯ï¼šç”¨é˜Ÿåˆ—å®ç°æ ˆçš„è¯ä½¿ç”¨ä¸€ä¸ªé˜Ÿåˆ—å°±å¯ä»¥ï¼Œå› ä¸ºåœ¨ä¸€å¼€å§‹é˜Ÿåˆ—ä¸ºç©ºï¼Œéœ€è¦è¿›è¡Œpushæ“ä½œï¼Œæ‰€ä»¥å°† x æ’å…¥é˜Ÿåˆ—å°¾éƒ¨ä¹‹åï¼Œéœ€è¦è®©é™¤äº† x ä¹‹å¤–çš„æ‰€æœ‰å…ƒç´ å…ˆå‡ºé˜Ÿåˆ—ï¼Œå†å…¥é˜Ÿåˆ—ã€‚ class MyStack { private Queue&lt;Integer> queue; /** Initialize your data structure here. */ public MyStack() { queue = new LinkedList&lt;>(); } /** Push element x onto stack. */ public void push(int x) { queue.offer(x); int size = queue.size(); while(--size > 0) { queue.offer(queue.poll()); } } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue.poll(); } /** Get the top element. */ public int top() { return queue.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 20. æœ‰æ•ˆçš„æ‹¬å·é¢˜ç›®æè¿°ï¼š ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ â€˜(â€˜ï¼Œâ€™)â€™ï¼Œâ€™{â€˜ï¼Œâ€™}â€™ï¼Œâ€™[â€˜ï¼Œâ€™]â€™ çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚ æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚æ³¨æ„ç©ºå­—ç¬¦ä¸²å¯è¢«è®¤ä¸ºæ˜¯æœ‰æ•ˆå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: &quot;()&quot; è¾“å‡º: true ç¤ºä¾‹ 2: è¾“å…¥: &quot;()[]{}&quot; è¾“å‡º: true ç¤ºä¾‹ 3: è¾“å…¥: &quot;(]&quot; è¾“å‡º: false ç¤ºä¾‹ 4: è¾“å…¥: &quot;([)]&quot; è¾“å‡º: false ç¤ºä¾‹ 5: è¾“å…¥: &quot;{[]}&quot; è¾“å‡º: trueè§£é¢˜æ€è·¯ï¼š å…ˆåˆ¤æ–­å¼€å¤´ï¼Œç„¶åç”¨ä¸€ä¸ªæ ˆæ¥ä¿å­˜ç»“å°¾ï¼Œæ ¹æ®å…¶åè¿›å…ˆå‡ºå¾—ç‰¹ç‚¹ï¼Œç„¶åæ¯æ¬¡å†å¼¹å‡ºã€‚ class Solution { public boolean isValid(String s) { Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()){ if (c == '('){ stack.push(')'); } else if (c == '{') { stack.push('}'); } else if (c == '[') { stack.push(']'); } else if (stack.isEmpty() || stack.pop() != c) { return false; } } return stack.isEmpty(); } } å¯¹æ ˆå’Œé˜Ÿåˆ—çš„åˆ·é¢˜å‘Šä¸€æ®µè½ï¼Œå¼€å§‹ç»§ç»­æ–°çš„é˜¶æ®µåˆ·é¢˜ã€‚","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"æ ˆå’Œé˜Ÿåˆ—","slug":"æ ˆå’Œé˜Ÿåˆ—","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/æ ˆå’Œé˜Ÿåˆ—/"}]},{"title":"LeetCodeä¸­å¸¸è§çš„å †æ’åº","slug":"æ’åº","date":"2019-04-07T01:25:08.000Z","updated":"2019-09-10T09:42:21.787Z","comments":true,"path":"2019/04/07/pai-xu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/07/pai-xu/","excerpt":"","text":"å †æ’åºä»Šå¤©åœ¨åˆ·leetcode215é¢˜ï¼Œç¢°åˆ°æ±‚è§£ TopK Elementsé—®é¢˜ï¼Œä¸€å…±æœ‰ä¸‰ç§æ–¹æ³•ï¼Œæ€»ç»“ä¸€ä¸‹ï¼š é¢˜ç›®æè¿°ï¼šæ‰¾åˆ°æœªæ’åºæ•°ç»„ä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´ ã€‚è¯·æ³¨æ„ï¼Œå®ƒæ˜¯æ’åºé¡ºåºä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´ ï¼Œè€Œä¸æ˜¯ç¬¬kä¸ªä¸åŒå…ƒç´ ã€‚ Input: [3,2,1,5,6,4] and k = 2 Output: 5 Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 è§£é¢˜æ–¹æ³•ï¼š1ã€å¯¹æ•´ä¸ªè¾“å…¥æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åé€šè¿‡å®ƒçš„ç´¢å¼•ï¼ˆå³Oï¼ˆ1ï¼‰ï¼‰æ“ä½œè®¿é—®è¯¥å…ƒç´ ï¼š â€‹ æ—¶é—´å¤æ‚åº¦ O(NlogN)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚ public int findKthLargest(int[] nums, int k) { final int N = nums.length; Arrays.sort(nums); return nums[N - k]; } 2ã€å †æ’åºä¹Ÿå¯ä»¥ç”¨äºæ±‚è§£ Kth Element é—®é¢˜ï¼Œå †é¡¶å…ƒç´ å°±æ˜¯ Kth Elementã€‚ä½¿ç”¨é¢å‘æœ€å°å€¼çš„ä¼˜å…ˆçº§é˜Ÿåˆ—æ¥å­˜å‚¨ç¬¬Kä¸ªæœ€å¤§å€¼ã€‚è¯¥ç®—æ³•è¿­ä»£æ•´ä¸ªè¾“å…¥å¹¶ç»´æŒä¼˜å…ˆçº§é˜Ÿåˆ—çš„å¤§å°ã€‚ä¼˜å…ˆé˜Ÿåˆ—å¯ä»¥ç”¨å †æ¥å®ç°ï¼š æ—¶é—´å¤æ‚åº¦ O(NlogK)ï¼Œç©ºé—´å¤æ‚åº¦ O(K)ã€‚ public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>(); // å°é¡¶å † for (int val : nums) { pq.add(val); if (pq.size() > k) // ç»´æŠ¤å †çš„å¤§å°ä¸º K pq.poll(); } return pq.peek(); } 3ã€åŸºäºåˆ‡åˆ†partionçš„å¿«é€Ÿé€‰æ‹©ç®—æ³•ï¼›å¿«é€Ÿæ’åºçš„ partition() æ–¹æ³•ï¼Œä¼šè¿”å›ä¸€ä¸ªæ•´æ•° j ä½¿å¾— a[l..j-1] å°äºç­‰äº a[j]ï¼Œä¸” a[j+1..h] å¤§äºç­‰äº a[j]ï¼Œæ­¤æ—¶ a[j] å°±æ˜¯æ•°ç»„çš„ç¬¬ j å¤§å…ƒç´ ã€‚å¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ‰¾å‡ºæ•°ç»„çš„ç¬¬ k ä¸ªå…ƒç´ ã€‚ æ—¶é—´å¤æ‚åº¦ æœ€ä½³æƒ…å†µï¼šO(N) æœ€åæƒ…å†µï¼šOï¼ˆN ^ 2ï¼‰ï¼Œç©ºé—´å¤æ‚åº¦ O(1) æˆ‘ä»¬å¦‚ä½•æ‰èƒ½æ”¹è¿›ä¸Šè¿°è§£å†³æ–¹æ¡ˆå¹¶ä½¿å…¶ä¿è¯Oï¼ˆNï¼‰ï¼Ÿç­”æ¡ˆéå¸¸ç®€å•ï¼Œåˆšå¼€å§‹æ—¶è¦å¯¹æ•°ç»„è¿›è¡Œæ´—ç‰Œshuffleï¼Œä½¿å…¶éšæœºåŒ–è¾“å…¥ï¼Œè¿™æ ·å³ä½¿æä¾›æœ€åæƒ…å†µè¾“å…¥ï¼Œç®—æ³•ä¹Ÿä¸ä¼šå—åˆ°å½±å“ã€‚å› æ­¤ï¼Œæ‰€éœ€è¦åšçš„å°±æ˜¯æ”¹å˜è¾“å…¥ã€‚ public int findKthLargest(int[] nums, int k) { shuffle(nums);//æ‰“ä¹±æ•°ç»„ k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) { final int j = partition(nums, lo, hi); if(j &lt; k) { lo = j + 1; } else if (j > k) { hi = j - 1; } else { break; } } return nums[k]; } //åˆ‡åˆ† private int partition(int[] a, int lo, int hi) { int i = lo; int j = hi + 1; while(true) { while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j > lo &amp;&amp; less(a[lo], a[--j])); if(i >= j) { break; } exch(a, i, j); } exch(a, lo, j); return j; } //äº¤æ¢ private void exch(int[] a, int i, int j) { final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } //æ¯”è¾ƒæ˜¯å¦å°äº private boolean less(int v, int w) { return v &lt; w; } private void shuffle(int a[]) { final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) { final int r = random.nextInt(ind + 1); exch(a, ind, r); } } æ¡¶æ’åºLeetcode : 347. Top K Frequent Elements (Medium) æ‰¾å‡ºå‡ºç°é¢‘ç‡æœ€å¤šçš„ k ä¸ªæ•° é¢˜ç›®æè¿°ï¼šç»™å®šéç©ºçš„æ•´æ•°æ•°ç»„ï¼Œè¿”å›kä¸ªæœ€å¸¸è§çš„å…ƒç´ ã€‚ Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]è§£å†³æ–¹æ³•ï¼šè®¾ç½®è‹¥å¹²ä¸ªæ¡¶ï¼Œæ¯ä¸ªæ¡¶å­˜å‚¨å‡ºç°é¢‘ç‡ç›¸åŒçš„æ•°ï¼Œå¹¶ä¸”æ¡¶çš„ä¸‹æ ‡ä»£è¡¨æ¡¶ä¸­æ•°å‡ºç°çš„é¢‘ç‡ã€‚ class Solution { public List&lt;Integer> topKFrequent(int[] nums, int k) { Map&lt;Integer,Integer> map = new HashMap&lt;>(); for(int a : nums){ map.put(a,map.getOrDefault(a,0)+1);//åˆ¤æ–­aæ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœæ²¡å‡ºç° } List&lt;Integer> [] buckets = new ArrayList[nums.length + 1]; for(int i : map.keySet()){ int frequency = map.get(i); if(buckets[frequency]==null){ buckets[frequency] = new ArrayList&lt;>(); } buckets[frequency].add(i); } List&lt;Integer> topK = new ArrayList&lt;>(); //ä»åå‘å‰éå†æ¡¶ï¼Œæœ€å…ˆå¾—åˆ°çš„ k ä¸ªæ•°å°±æ˜¯å‡ºç°é¢‘ç‡æœ€å¤šçš„çš„ k ä¸ªæ•° for(int i = buckets.length - 1; i >= 0 &amp;&amp; topK.size() &lt; k;i--){ if(buckets[i]!=null){ topK.addAll(buckets[i]); } } return topK; } } è·å…°å›½æ——é—®é¢˜ï¼š75. Sort Colors (Medium) é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªå…·æœ‰çº¢è‰²ï¼Œç™½è‰²æˆ–è“è‰²çš„nä¸ªå¯¹è±¡çš„æ•°ç»„ï¼Œå¯¹å®ƒä»¬è¿›è¡Œå°±åœ° æ’åºï¼Œä½¿ç›¸åŒé¢œè‰²çš„å¯¹è±¡ç›¸é‚»ï¼Œé¢œè‰²é¡ºåºä¸ºçº¢è‰²ï¼Œç™½è‰²å’Œè“è‰²ã€‚ è¿™é‡Œï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ•´æ•°0,1å’Œ2åˆ†åˆ«è¡¨ç¤ºçº¢è‰²ï¼Œç™½è‰²å’Œè“è‰²ã€‚ æ³¨æ„ï¼š æ‚¨ä¸åº”è¯¥ä½¿ç”¨åº“çš„æ’åºåŠŸèƒ½æ¥è§£å†³æ­¤é—®é¢˜ã€‚ Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]è§£å†³æ–¹æ³•ï¼šä½¿ç”¨ä¸‰å‘åˆ‡åˆ†å¿«é€Ÿæ’åºï¼Œå°†æ•°ç»„åˆ†æˆä¸‰ä¸ªåŒºé—´ï¼šç­‰äºçº¢è‰²ã€ç­‰äºç™½è‰²ã€ç­‰äºè“è‰²ã€‚ class Solution { public void sortColors(int[] nums) { int zero = 0; int two = nums.length - 1; int one = 0; while(one &lt;= two){ if (nums[one] == 0){ swap(nums,zero++,one++);//ä»å‰é¢å¼€å§‹äº¤æ¢çš„å·²ç»æ¯”è¾ƒè¿‡äº† }else if (nums[one] == 2){ swap(nums,two--,one);//è¿™é‡Œæ³¨æ„oneä¸è¦++ï¼Œä»åé¢äº¤æ¢åˆ°å‰é¢çš„è¿˜æ— æ³•æ¯”è¾ƒ }else { one++; } } } private static void swap(int [] nums,int a,int b){ int i = nums[a]; nums[a] = nums[b]; nums[b] = i; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Sort/"}]},{"title":"LeetCodeä¸­å¸¸è§çš„è´ªå¿ƒé¢˜ç›®","slug":"è´ªå¿ƒç®—æ³•","date":"2019-04-01T10:45:28.000Z","updated":"2019-09-10T09:45:03.856Z","comments":true,"path":"2019/04/01/tan-xin-suan-fa/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/01/tan-xin-suan-fa/","excerpt":"","text":"è´ªå¿ƒç®—æ³•ï¼šå®šä¹‰ï¼šè´ªå¿ƒç®—æ³•ï¼ˆåˆç§°è´ªå©ªç®—æ³•ï¼‰æ˜¯æŒ‡ï¼Œåœ¨å¯¹é—®é¢˜æ±‚è§£æ—¶ï¼Œæ€»æ˜¯åšå‡ºåœ¨å½“å‰çœ‹æ¥æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸ä»æ•´ä½“æœ€ä¼˜ä¸ŠåŠ ä»¥è€ƒè™‘ï¼Œä»–æ‰€åšå‡ºçš„æ˜¯åœ¨æŸç§æ„ä¹‰ä¸Šçš„å±€éƒ¨æœ€ä¼˜è§£ã€‚ è´ªå¿ƒç®—æ³•ä¸æ˜¯å¯¹æ‰€æœ‰é—®é¢˜éƒ½èƒ½å¾—åˆ°æ•´ä½“æœ€ä¼˜è§£ï¼Œå…³é”®æ˜¯è´ªå¿ƒç­–ç•¥çš„é€‰æ‹©ï¼Œé€‰æ‹©çš„è´ªå¿ƒç­–ç•¥å¿…é¡»å…·å¤‡æ— åæ•ˆæ€§ï¼Œå³æŸä¸ªçŠ¶æ€ä»¥å‰çš„è¿‡ç¨‹ä¸ä¼šå½±å“ä»¥åçš„çŠ¶æ€ï¼Œåªä¸å½“å‰çŠ¶æ€æœ‰å…³ã€‚ è´ªå¿ƒç­–ç•¥é€‚ç”¨çš„å‰ææ˜¯ï¼šå±€éƒ¨æœ€ä¼˜ç­–ç•¥èƒ½å¯¼è‡´äº§ç”Ÿå…¨å±€æœ€ä¼˜è§£ã€‚ 455. Assign Cookiesé¢˜ç›®æè¿°ï¼šå‡è®¾ä½ æ˜¯ä¸€ä½å¾ˆæ£’çš„å®¶é•¿ï¼Œæƒ³è¦ç»™ä½ çš„å­©å­ä»¬ä¸€äº›å°é¥¼å¹²ã€‚ä½†æ˜¯ï¼Œæ¯ä¸ªå­©å­æœ€å¤šåªèƒ½ç»™ä¸€å—é¥¼å¹²ã€‚å¯¹æ¯ä¸ªå­©å­ i ï¼Œéƒ½æœ‰ä¸€ä¸ªèƒƒå£å€¼ gi ï¼Œè¿™æ˜¯èƒ½è®©å­©å­ä»¬æ»¡è¶³èƒƒå£çš„é¥¼å¹²çš„æœ€å°å°ºå¯¸ï¼›å¹¶ä¸”æ¯å—é¥¼å¹² j ï¼Œéƒ½æœ‰ä¸€ä¸ªå°ºå¯¸ sj ã€‚å¦‚æœ sj &gt;= gi ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªé¥¼å¹² j åˆ†é…ç»™å­©å­ i ï¼Œè¿™ä¸ªå­©å­ä¼šå¾—åˆ°æ»¡è¶³ã€‚ä½ çš„ç›®æ ‡æ˜¯å°½å¯èƒ½æ»¡è¶³è¶Šå¤šæ•°é‡çš„å­©å­ï¼Œå¹¶è¾“å‡ºè¿™ä¸ªæœ€å¤§æ•°å€¼ã€‚ æ³¨æ„ï¼šä½ å¯ä»¥å‡è®¾èƒƒå£å€¼ä¸ºæ­£ã€‚ä¸€ä¸ªå°æœ‹å‹æœ€å¤šåªèƒ½æ‹¥æœ‰ä¸€å—é¥¼å¹²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [1,2,3], [1,1] è¾“å‡º: 1 è§£é‡Š: ä½ æœ‰ä¸‰ä¸ªå­©å­å’Œä¸¤å—å°é¥¼å¹²ï¼Œ3ä¸ªå­©å­çš„èƒƒå£å€¼åˆ†åˆ«æ˜¯ï¼š1,2,3ã€‚ è™½ç„¶ä½ æœ‰ä¸¤å—å°é¥¼å¹²ï¼Œç”±äºä»–ä»¬çš„å°ºå¯¸éƒ½æ˜¯1ï¼Œä½ åªèƒ½è®©èƒƒå£å€¼æ˜¯1çš„å­©å­æ»¡è¶³ã€‚ æ‰€ä»¥ä½ åº”è¯¥è¾“å‡º1ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [1,2], [1,2,3] è¾“å‡º: 2 è§£é‡Š: ä½ æœ‰ä¸¤ä¸ªå­©å­å’Œä¸‰å—å°é¥¼å¹²ï¼Œ2ä¸ªå­©å­çš„èƒƒå£å€¼åˆ†åˆ«æ˜¯1,2ã€‚ ä½ æ‹¥æœ‰çš„é¥¼å¹²æ•°é‡å’Œå°ºå¯¸éƒ½è¶³ä»¥è®©æ‰€æœ‰å­©å­æ»¡è¶³ã€‚ æ‰€ä»¥ä½ åº”è¯¥è¾“å‡º2.è§£é¢˜æ€è·¯ï¼šè´ªå¿ƒå°±æ˜¯ç»™ä¸€ä¸ªå­©å­çš„é¥¼å¹²åº”å½“å°½é‡å°åˆèƒ½æ»¡è¶³è¯¥å­©å­ï¼Œè¿™æ ·å¤§é¥¼å¹²å°±èƒ½æ‹¿æ¥ç»™æ»¡è¶³åº¦æ¯”è¾ƒå¤§çš„å­©å­ã€‚å› ä¸ºæœ€å°çš„å­©å­æœ€å®¹æ˜“å¾—åˆ°æ»¡è¶³ï¼Œæ‰€ä»¥å…ˆæ»¡è¶³æœ€å°çš„å­©å­ã€‚é€šè¿‡ä½¿ç”¨è¿™ç§è´ªå©ªçš„æ–¹æ³•ï¼Œæµªè´¹çš„cookieçš„æ€»å’Œå°†æ˜¯æœ€å°çš„ã€‚å› æ­¤è¦å¯¹ä¸¤ä¸ªæ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒå³å¯ã€‚ //[1,2], [1,2,3] class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int gi = 0, si = 0; while (si &lt; s.length &amp;&amp; gi &lt; g.length) { if (g[gi] &lt;= s[si]) { gi++; } si++; } return gi; } } 435. Non-overlapping Intervalsé¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªåŒºé—´çš„é›†åˆï¼Œæ‰¾åˆ°éœ€è¦ç§»é™¤åŒºé—´çš„æœ€å°æ•°é‡ï¼Œä½¿å‰©ä½™åŒºé—´äº’ä¸é‡å ã€‚ æ³¨æ„: å¯ä»¥è®¤ä¸ºåŒºé—´çš„ç»ˆç‚¹æ€»æ˜¯å¤§äºå®ƒçš„èµ·ç‚¹ã€‚åŒºé—´ [1,2] å’Œ [2,3] çš„è¾¹ç•Œç›¸äº’â€œæ¥è§¦â€ï¼Œä½†æ²¡æœ‰ç›¸äº’é‡å ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [ [1,2], [2,3], [3,4], [1,3] ] è¾“å‡º: 1 è§£é‡Š: ç§»é™¤ [1,3] åï¼Œå‰©ä¸‹çš„åŒºé—´æ²¡æœ‰é‡å ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [ [1,2], [1,2], [1,2] ] è¾“å‡º: 2 è§£é‡Š: ä½ éœ€è¦ç§»é™¤ä¸¤ä¸ª [1,2] æ¥ä½¿å‰©ä¸‹çš„åŒºé—´æ²¡æœ‰é‡å ã€‚ ç¤ºä¾‹ 3: è¾“å…¥: [ [1,2], [2,3] ] è¾“å‡º: 0 è§£é‡Š: ä½ ä¸éœ€è¦ç§»é™¤ä»»ä½•åŒºé—´ï¼Œå› ä¸ºå®ƒä»¬å·²ç»æ˜¯æ— é‡å çš„äº†ã€‚è§£é¢˜æ€è·¯ï¼šç»å…¸çš„è´ªå©ªé—®é¢˜ï¼šé—´éš”è°ƒåº¦ï¼Œä¸‹é¢é‚£ä¸€é¢˜LeetCode452ä¹Ÿæ˜¯åŒæ ·æ€è·¯ å…ˆè®¡ç®—æœ€å¤šèƒ½ç»„æˆçš„ä¸é‡å åŒºé—´ä¸ªæ•°ï¼Œç„¶åç”¨åŒºé—´æ€»ä¸ªæ•°å‡å»ä¸é‡å åŒºé—´çš„ä¸ªæ•°ã€‚ åœ¨æ¯æ¬¡é€‰æ‹©ä¸­ï¼Œé€‰æ‹©çš„åŒºé—´ç»“å°¾è¶Šå°ï¼Œç•™ç»™åé¢çš„åŒºé—´çš„ç©ºé—´è¶Šå¤§ï¼Œé‚£ä¹ˆåé¢èƒ½å¤Ÿé€‰æ‹©çš„åŒºé—´ä¸ªæ•°ä¹Ÿå°±è¶Šå¤§ã€‚ æŒ‰åŒºé—´çš„ç»“å°¾è¿›è¡Œå‡åºæ’åºï¼Œæ¯æ¬¡é€‰æ‹©ç»“å°¾æœ€å°ï¼Œå¹¶ä¸”å’Œå‰ä¸€ä¸ªåŒºé—´ä¸é‡å çš„åŒºé—´ã€‚ åœ¨å¯¹æ•°ç»„è¿›è¡Œæ’åºçš„æ—¶å€™ä¹Ÿå¯ä»¥ä½¿ç”¨ lambda è¡¨ç¤ºå¼æ¥åˆ›å»º Comparator ï¼Œä¸è¿‡ç®—æ³•è¿è¡Œæ—¶é—´ä¼šæ¯”è¾ƒé•¿ç‚¹ã€‚ class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length == 0) { return 0; } Arrays.sort(intervals,new Comparator&lt;int [] >(){ public int compare(int [] a1,int [] a2) { return a1[1] - a2[1]; //å‡åºæ’åˆ— } }); int count = 1; //æœ€å¤šèƒ½ç»„æˆçš„ä¸é‡å åŒºé—´ä¸ªæ•° int end = intervals[0][1]; for (int i = 0; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; end) { continue; } end = intervals[i][1]; count++; } return intervals.length - count; } } 452. Minimum Number of Arrows to Burst Ballooné¢˜ç›®æè¿°ï¼šåœ¨äºŒç»´ç©ºé—´ä¸­æœ‰è®¸å¤šçƒå½¢çš„æ°”çƒã€‚å¯¹äºæ¯ä¸ªæ°”çƒï¼Œæä¾›çš„è¾“å…¥æ˜¯æ°´å¹³æ–¹å‘ä¸Šï¼Œæ°”çƒç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ã€‚ç”±äºå®ƒæ˜¯æ°´å¹³çš„ï¼Œæ‰€ä»¥yåæ ‡å¹¶ä¸é‡è¦ï¼Œå› æ­¤åªè¦çŸ¥é“å¼€å§‹å’Œç»“æŸçš„xåæ ‡å°±è¶³å¤Ÿäº†ã€‚å¼€å§‹åæ ‡æ€»æ˜¯å°äºç»“æŸåæ ‡ã€‚å¹³é¢å†…æœ€å¤šå­˜åœ¨104ä¸ªæ°”çƒã€‚ ä¸€æ”¯å¼“ç®­å¯ä»¥æ²¿ç€xè½´ä»ä¸åŒç‚¹å®Œå…¨å‚ç›´åœ°å°„å‡ºã€‚åœ¨åæ ‡xå¤„å°„å‡ºä¸€æ”¯ç®­ï¼Œè‹¥æœ‰ä¸€ä¸ªæ°”çƒçš„ç›´å¾„çš„å¼€å§‹å’Œç»“æŸåæ ‡ä¸º xstartï¼Œxendï¼Œ ä¸”æ»¡è¶³ xstart â‰¤ x â‰¤ xendï¼Œåˆ™è¯¥æ°”çƒä¼šè¢«å¼•çˆ†ã€‚å¯ä»¥å°„å‡ºçš„å¼“ç®­çš„æ•°é‡æ²¡æœ‰é™åˆ¶ã€‚ å¼“ç®­ä¸€æ—¦è¢«å°„å‡ºä¹‹åï¼Œå¯ä»¥æ— é™åœ°å‰è¿›ã€‚æˆ‘ä»¬æƒ³æ‰¾åˆ°ä½¿å¾—æ‰€æœ‰æ°”çƒå…¨éƒ¨è¢«å¼•çˆ†ï¼Œæ‰€éœ€çš„å¼“ç®­çš„æœ€å°æ•°é‡ã€‚ è¾“å…¥: [[10,16], [2,8], [1,6], [7,12]] è¾“å‡º: 2 è§£é‡Š: å¯¹äºè¯¥æ ·ä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨x = 6ï¼ˆå°„çˆ†[2,8],[1,6]ä¸¤ä¸ªæ°”çƒï¼‰å’Œ x = 11ï¼ˆå°„çˆ†å¦å¤–ä¸¤ä¸ªæ°”çƒï¼‰ã€‚è§£é¢˜æ€è·¯ï¼šæœ¬é¢˜è·Ÿä¸Šä¸€é¢˜å‡ ä¹ä¸€æ ·çš„å®ç°æ–¹æ³•ï¼Œè¯´ç™½äº†å°±æ˜¯è®¡ç®—ä¸é‡å çš„åŒºé—´ä¸ªæ•°ï¼Œå¹¶ä¸”æŒ‰ç»“æŸåæ ‡å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åéå†åˆ¤æ–­ä¸è¿‡è¿™é‡Œæ³¨æ„[1, 2] å’Œ [2, 3] åœ¨æœ¬é¢˜ä¸­ç®—æ˜¯é‡å åŒºé—´ã€‚åœ¨è¿™é‡Œæˆ‘å¯¹æ•°ç»„è¿›è¡Œæ’åºæ—¶ç”¨lambdaè¡¨è¾¾å¼ï¼Œç›¸å¯¹å®ç°Comparatoræ¥å£è¾ƒæ…¢ã€‚ä»£ç å¦‚ä¸‹ï¼š class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points,(i1,i2) -> (i1[1] - i2[1])); //ä½¿ç”¨Lambdaè¡¨è¾¾å¼æ’åºï¼ŒæŒ‰ int count = 1; int end = points[0][1]; for (int i = 0; i &lt; points.length; i++) { if (points[i][0] &lt;= end) { //æ³¨æ„è¿™é‡Œæ˜¯&lt;= continue; //å±äºé‡å¤åŒºé—´ï¼Œè·³è¿‡ï¼Œä¸ç”¨å¢åŠ countæ¬¡æ•° } end = points[i][1]; count++; } return count; } } 605. Can Place Flowersé¢˜ç›®æè¿°ï¼šå‡è®¾ä½ æœ‰ä¸€ä¸ªå¾ˆé•¿çš„èŠ±å›ï¼Œä¸€éƒ¨åˆ†åœ°å—ç§æ¤äº†èŠ±ï¼Œå¦ä¸€éƒ¨åˆ†å´æ²¡æœ‰ã€‚å¯æ˜¯ï¼ŒèŠ±å‰ä¸èƒ½ç§æ¤åœ¨ç›¸é‚»çš„åœ°å—ä¸Šï¼Œå®ƒä»¬ä¼šäº‰å¤ºæ°´æºï¼Œä¸¤è€…éƒ½ä¼šæ­»å»ã€‚ ç»™å®šä¸€ä¸ªèŠ±å›ï¼ˆè¡¨ç¤ºä¸ºä¸€ä¸ªæ•°ç»„åŒ…å«0å’Œ1ï¼Œå…¶ä¸­0è¡¨ç¤ºæ²¡ç§æ¤èŠ±ï¼Œ1è¡¨ç¤ºç§æ¤äº†èŠ±ï¼‰ï¼Œå’Œä¸€ä¸ªæ•° n ã€‚èƒ½å¦åœ¨ä¸æ‰“ç ´ç§æ¤è§„åˆ™çš„æƒ…å†µä¸‹ç§å…¥ n æœµèŠ±ï¼Ÿèƒ½åˆ™è¿”å›Trueï¼Œä¸èƒ½åˆ™è¿”å›Falseã€‚ è§£é¢˜æ€è·¯ï¼šè´ªå©ªåœ°åœ¨ä»å·¦åˆ°å³éå†ï¼Œåœ¨é‡åˆ°çš„æ¯ä¸ªç©ºåœ°ä¸Šæ”¾ä¸€æœµèŠ±ã€‚è·å–ä¸Šä¸€ä¸ªå’Œä¸‹ä¸€ä¸ªèŠ±å›ï¼Œå¦‚æœiä½äºé¦–ä½æˆ–è€…æœ«ç«¯ï¼Œåˆ™å‰ä¸€ä¸ªæˆ–è€…ä¸‹ä¸€ä¸ªè¢«è®¤ä¸ºæ˜¯0ã€‚ class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int length = flowerbed.length; int count = 0; for(int i = 0; i &lt; length &amp;&amp; count &lt; n; i++) { if (flowerbed[i] == 0) { int pre = (i == 0)? 0 : flowerbed[i-1]; //ä¸Šä¸€ä¸ªèŠ±å› int next = (i == length - 1)? 0 : flowerbed[i+1]; //ä¸‹ä¸€ä¸ªèŠ±å› if(pre == 0 &amp;&amp; next == 0) { count++; flowerbed[i] = 1; } } } return count == n; } } 121. Best Time to Buy and Sell Stocké¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªæ•°ç»„ï¼Œå®ƒçš„ç¬¬ i ä¸ªå…ƒç´ æ˜¯ä¸€æ”¯ç»™å®šè‚¡ç¥¨ç¬¬ i å¤©çš„ä»·æ ¼ã€‚ å¦‚æœä½ æœ€å¤šåªå…è®¸å®Œæˆä¸€ç¬”äº¤æ˜“ï¼ˆå³ä¹°å…¥å’Œå–å‡ºä¸€æ”¯è‚¡ç¥¨ï¼‰ï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•æ¥è®¡ç®—ä½ æ‰€èƒ½è·å–çš„æœ€å¤§åˆ©æ¶¦ã€‚ æ³¨æ„ä½ ä¸èƒ½åœ¨ä¹°å…¥è‚¡ç¥¨å‰å–å‡ºè‚¡ç¥¨ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [7,1,5,3,6,4] è¾“å‡º: 5 è§£é‡Š: åœ¨ç¬¬ 2 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 1ï¼‰çš„æ—¶å€™ä¹°å…¥ï¼Œåœ¨ç¬¬ 5 å¤©ï¼ˆè‚¡ç¥¨ä»·æ ¼ = 6ï¼‰çš„æ—¶å€™å–å‡ºï¼Œæœ€å¤§åˆ©æ¶¦ = 6-1 = 5 ã€‚ æ³¨æ„åˆ©æ¶¦ä¸èƒ½æ˜¯ 7-1 = 6, å› ä¸ºå–å‡ºä»·æ ¼éœ€è¦å¤§äºä¹°å…¥ä»·æ ¼ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [7,6,4,3,1] è¾“å‡º: 0 è§£é‡Š: åœ¨è¿™ç§æƒ…å†µä¸‹, æ²¡æœ‰äº¤æ˜“å®Œæˆ, æ‰€ä»¥æœ€å¤§åˆ©æ¶¦ä¸º 0ã€‚è§£é¢˜æ€è·¯ï¼šä»å¤´éå†æ•°ç»„ï¼Œæ¯”è¾ƒä¸¤ä¸ªæ•°ä¹‹ä¸­è°æ¯”è¾ƒå¤§ï¼Œè¿™é‡Œæ³¨æ„å–å‡ºä»·æ ¼è¦å¤§äºä¹°å…¥ä»·æ ¼ï¼Œå¦‚æœç¬¬ä¸€ä¸ªå€¼æ¯”ç¬¬äºŒä¸ªå€¼å¤§ï¼Œç”±äºè´ªå¿ƒç­–ç•¥ï¼Œè¦æ±‚æœ€å¤§æ”¶ç›Šï¼Œå› æ­¤æŠŠæœ€å°ä»·æ ¼èµ‹å€¼ç»™ç¬¬äºŒä¸ªï¼Œå¦‚æœç¬¬ä¸€ä¸ªå€¼æ¯”ç¬¬äºŒä¸ªå°ï¼Œåˆ™å°†å½“å‰ä»·æ ¼ å³ å”®å‡ºä»·æ ¼å‡å»æœ€å°ä»·æ ¼ï¼Œåˆ™ä¸ºæœ€å¤§åˆ©ç›Šï¼Œéå†å®Œå³å¯ã€‚ class Solution { public int maxProfit(int[] prices) { if (prices.length &lt;= 1) { return 0; } int temp = prices[0]; //æœ€å°ä»·æ ¼ int max = 0; //æœ€å¤§æ”¶ç›Š for (int i = 1; i &lt; prices.length; i++){ if (temp > prices[i]) { temp = prices[i]; } else { max = Math.max(max,prices[i] - temp); } } return max; } } 665. Non-decreasing Arrayé¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ï¼Œä½ çš„ä»»åŠ¡æ˜¯åˆ¤æ–­åœ¨æœ€å¤šæ”¹å˜ 1 ä¸ªå…ƒç´ çš„æƒ…å†µä¸‹ï¼Œè¯¥æ•°ç»„èƒ½å¦å˜æˆä¸€ä¸ªéé€’å‡æ•°åˆ—ã€‚ æˆ‘ä»¬æ˜¯è¿™æ ·å®šä¹‰ä¸€ä¸ªéé€’å‡æ•°åˆ—çš„ï¼š å¯¹äºæ•°ç»„ä¸­æ‰€æœ‰çš„ i (1 &lt;= i &lt; n)ï¼Œæ»¡è¶³ array[i] &lt;= array[i + 1]ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: [4,2,3] è¾“å‡º: True è§£é‡Š: ä½ å¯ä»¥é€šè¿‡æŠŠç¬¬ä¸€ä¸ª4å˜æˆ1æ¥ä½¿å¾—å®ƒæˆä¸ºä¸€ä¸ªéé€’å‡æ•°åˆ—ã€‚ ç¤ºä¾‹ 2: è¾“å…¥: [4,2,1] è¾“å‡º: False è§£é‡Š: ä½ ä¸èƒ½åœ¨åªæ”¹å˜ä¸€ä¸ªå…ƒç´ çš„æƒ…å†µä¸‹å°†å…¶å˜ä¸ºéé€’å‡æ•°åˆ—ã€‚ è¯´æ˜: n çš„èŒƒå›´ä¸º [1, 10,000]ã€‚è§£é¢˜æ€è·¯ï¼šå¦‚æœæˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå¤±è´¥çš„æƒ…å†µï¼Œå³ä¸æ˜¯éé€’å‡æ•°åˆ—ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¿®æ­£ã€‚å¯ä»¥é€šè¿‡ä»¥ä¸‹ä¸¤ç§æ–¹å¼ä¹‹ä¸€è¿›è¡Œæ›´æ­£ï¼š ä½¿å‰ä¸€ä¸ªæ•°å­—å°äºæˆ–ç­‰äºå½“å‰æ•°å­— ä½¿å½“å‰æ•°å­—ç­‰äºå…ˆå‰çš„æ•°å­—å½“æ‰¾åˆ°nums[i-1] &gt; nums[i]ï¼Œé‡‡ç”¨æ–¹å¼ä¸€ï¼Œé€šè¿‡æ”¹å˜nums[i-1]çš„å€¼ï¼Œè¿™æ ·ä¸ä¼šå½±å“äº†åç»­æ“ä½œã€‚è¿˜æœ‰ï¼Œå¦‚æœnums[i-2] &gt; nums[i]ï¼Œé‡‡ç”¨æ–¹å¼äºŒï¼Œæ”¹å˜nums[i]çš„å€¼ã€‚class Solution { public boolean checkPossibility(int[] nums) { int length = nums.length; int count = 0; for (int i = 1; i &lt; length &amp;&amp; count &lt; 2; i++) { if (nums[i] >= nums[i - 1]) { continue; } count++; if (i - 2 >= 0 &amp;&amp; nums[i - 2] > nums[i]) { nums[i] = nums[i - 1]; //ä½¿å½“å‰æ•°å­—ç­‰äºå…ˆå‰çš„æ•°å­— } else { nums[i - 1] = nums[i]; //ä½¿å‰ä¸€ä¸ªæ•°å­—å°äºæˆ–ç­‰äºå½“å‰æ•°å­— } } return count &lt;= 1; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/è´ªå¿ƒ/"}]},{"title":"LeetCodeä¸­å¸¸è§çš„åŒæŒ‡é’ˆé¢˜ç›®","slug":"åŒæŒ‡é’ˆ","date":"2019-03-20T10:45:28.000Z","updated":"2019-09-10T09:45:37.599Z","comments":true,"path":"2019/03/20/shuang-zhi-zhen/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/20/shuang-zhi-zhen/","excerpt":"","text":"åŒæŒ‡é’ˆï¼šæœ€è¿‘åœ¨åˆ·leetcodeï¼Œç¢°åˆ°äº†è®¸å¤šåŒæŒ‡é’ˆç±»çš„é¢˜ç›®ï¼Œåœ¨è¿™é‡Œæ€»ç»“ä¸‹ï¼šæ‰€è°“åŒæŒ‡é’ˆï¼ŒæŒ‡çš„æ˜¯åœ¨éå†å¯¹è±¡çš„è¿‡ç¨‹ä¸­ï¼Œä¸æ˜¯æ™®é€šçš„ä½¿ç”¨å•ä¸ªæŒ‡é’ˆè¿›è¡Œè®¿é—®ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸¤ä¸ªç›¸åŒæ–¹å‘æˆ–è€…ç›¸åæ–¹å‘çš„æŒ‡é’ˆè¿›è¡Œæ‰«æï¼Œä»è€Œè¾¾åˆ°ç›¸åº”çš„ç›®çš„ã€‚æ¢è¨€ä¹‹ï¼ŒåŒæŒ‡é’ˆæ³•å……åˆ†ä½¿ç”¨äº†æ•°ç»„æœ‰åºè¿™ä¸€ç‰¹å¾ï¼Œä»è€Œåœ¨æŸäº›æƒ…å†µä¸‹èƒ½å¤Ÿç®€åŒ–ä¸€äº›è¿ç®—ã€‚ (æ³¨ï¼šè¿™é‡Œçš„æŒ‡é’ˆï¼Œå¹¶éä¸“æŒ‡cä¸­æŒ‡é’ˆçš„æ¦‚å¿µï¼Œè€Œæ˜¯æŒ‡ç´¢å¼•ï¼Œæ¸¸æ ‡æˆ–æŒ‡é’ˆï¼Œå¯è¿­ä»£å¯¹è±¡ç­‰) 167 .ä¸¤ä¸ªSum II - è¾“å…¥æ•°ç»„å·²æ’åºé¢˜ç›®ï¼šå®šç»™ä¸€ä¸ªå·²æŒ‰ç…§å‡åºä¸ªç»“æœæ’åˆ— çš„æœ‰åºæ•°ç»„ï¼Œæ‰¾åˆ°ä¸¤ä¸ªæ•°ä½¿å¾—å®ƒä»¬ç›¸åŠ ä¹‹å’Œç­‰äºç›®æ ‡æ•°ã€‚ å‡½æ•°åº”è¯¥è¿”å›è¿™ä¸¤ä¸ªä¸‹æ ‡å€¼ index1å’Œindex2ï¼Œå…¶ä¸­index1å¿…é¡»å°äºindex2 ã€‚ è¯´æ˜ï¼š è¿”å›çš„ä¸‹æ ‡å€¼ï¼ˆindex1å’Œindex2ï¼‰ä¸æ˜¯ä»é›¶å¼€å§‹çš„ã€‚ ä½ å¯ä»¥å‡è®¾æ¯ä¸ªè¾“å…¥åªå¯¹åº”å”¯ä¸€çš„ç­”æ¡ˆï¼Œè€Œä¸”ä½ ä¸å¯ä»¥é‡å¤ä½¿ç”¨ç›¸åŒçš„å…ƒç´ ã€‚ ç¤ºä¾‹ï¼š è¾“å…¥ï¼šæ•°å­—= [ 2,7,11,15 ]ï¼Œç›®æ ‡= 9 è¾“å‡ºï¼š [1,2] è§£é‡Šï¼š 2ä¸7ä¹‹å’Œç­‰äºç›®æ ‡æ•°9.å› æ­¤index1 = 1ï¼Œindex2 = 2ã€‚è§£å†³æ–¹æ³•ï¼š ä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å€¼è¾ƒå°çš„å…ƒç´ ï¼Œä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘å€¼è¾ƒå¤§çš„å…ƒç´ ã€‚æŒ‡å‘è¾ƒå°å…ƒç´ çš„æŒ‡é’ˆä»å¤´å‘å°¾éå†ï¼ŒæŒ‡å‘è¾ƒå¤§å…ƒç´ çš„æŒ‡é’ˆä»å°¾å‘å¤´éå†ã€‚ å¦‚æœä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘å…ƒç´ çš„å’Œsum == targetï¼Œé‚£ä¹ˆå¾—åˆ°è¦æ±‚çš„ç»“æœ; å¦‚æœsum&gt; targetï¼Œç§»åŠ¨è¾ƒå¤§çš„å…ƒç´ ï¼Œä½¿sumå˜å°ä¸€äº›; å¦‚æœsum &lt;targetï¼Œç§»åŠ¨è¾ƒå°çš„å…ƒç´ ï¼Œä½¿sumå˜å¤§ä¸€äº›ã€‚ public int[] twoSum(int[] numbers, int target) { int i = 0, j = numbers.length - 1; while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[]{i + 1, j + 1}; } else if (sum &lt; target) { i++; } else { j--; } } return null; } 141. ç¯å½¢é“¾è¡¨é—®é¢˜ï¼šç»™å®šä¸€ä¸ªé“¾è¡¨ï¼Œåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦æœ‰ç¯ã€‚ ä¸ºäº†è¡¨ç¤ºç»™å®šé“¾è¡¨ä¸­çš„ç¯ï¼Œæˆ‘ä»¬ä½¿ç”¨æ•´æ•° pos æ¥è¡¨ç¤ºé“¾è¡¨å°¾è¿æ¥åˆ°é“¾è¡¨ä¸­çš„ä½ç½®ï¼ˆç´¢å¼•ä» 0 å¼€å§‹ï¼‰ã€‚ å¦‚æœ pos æ˜¯ -1ï¼Œåˆ™åœ¨è¯¥é“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šhead = [3,2,0,-4], pos = 1 è¾“å‡ºï¼štrue è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šhead = [1,2], pos = 0 è¾“å‡ºï¼štrue è§£é‡Šï¼šé“¾è¡¨ä¸­æœ‰ä¸€ä¸ªç¯ï¼Œå…¶å°¾éƒ¨è¿æ¥åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ **ç¤ºä¾‹ 3ï¼š** è¾“å…¥ï¼šhead = [1], pos = -1 è¾“å‡ºï¼šfalse è§£é‡Šï¼šé“¾è¡¨ä¸­æ²¡æœ‰ç¯ã€‚ è§£å†³ï¼šä½¿ç”¨åŒæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå¦‚æœå­˜åœ¨ç¯ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæŒ‡é’ˆä¸€å®šä¼šç›¸é‡ï¼Œå¥½æ¯”äºæ“åœºï¼Œå¦‚æœä¸€ä¸ªç”¨èµ°ï¼Œä¸€ä¸ªç”¨è·‘ï¼Œä¸¤ä¸ªè‚¯å®šç›¸é‡ã€‚ public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode l1 = head, l2 = head.next; while (l1 != null &amp;&amp; l2 != null &amp;&amp; l2.next != null) { if (l1 == l2) { return true; } l1 = l1.next; l2 = l2.next.next; } return false; } 345 .åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯é—®é¢˜ï¼šç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œä»¥å­—ç¬¦ä¸²ä½œä¸ºè¾“å…¥ï¼Œåè½¬è¯¥å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: &quot;hello&quot; è¾“å‡º: &quot;holle&quot;ç¤ºä¾‹ 2: è¾“å…¥: &quot;leetcode&quot; è¾“å‡º: &quot;leotcede&quot;è§£å†³ï¼šä½¿ç”¨åŒæŒ‡é’ˆæŒ‡å‘å¾…åè½¬çš„ä¸¤ä¸ªå…ƒéŸ³å­—ç¬¦ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å¤´å‘å°¾éå†ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å°¾åˆ°å¤´éå†ã€‚ private final static HashSet&lt;Character> vowels = new HashSet&lt;>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); public String reverseVowels(String s) { int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) { char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) { result[i++] = ci; } else if (!vowels.contains(cj)) { result[j--] = cj; } else { result[i++] = cj; result[j--] = ci; } } return new String(result); } 680. éªŒè¯å›æ–‡å­—ç¬¦ä¸² â…¡é—®é¢˜ï¼šç»™å®šä¸€ä¸ªéç©ºå­—ç¬¦ä¸² sï¼Œæœ€å¤šåˆ é™¤ä¸€ä¸ªå­—ç¬¦ã€‚åˆ¤æ–­æ˜¯å¦èƒ½æˆä¸ºå›æ–‡å­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 1: è¾“å…¥: &quot;aba&quot; è¾“å‡º: Trueç¤ºä¾‹ 2: è¾“å…¥: &quot;abca&quot; è¾“å‡º: True è§£é‡Š: ä½ å¯ä»¥åˆ é™¤cå­—ç¬¦ã€‚æ³¨æ„: å­—ç¬¦ä¸²åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚å­—ç¬¦ä¸²çš„æœ€å¤§é•¿åº¦æ˜¯50000ã€‚ è§£å†³ï¼šå…ˆå†™ä¸€ä¸ªæ˜¯å¦æ˜¯å›æ–‡çš„å‡½æ•°ï¼Œç„¶åå†ä½¿ç”¨åŒæŒ‡é’ˆï¼Œåªè¦æ˜¯å›æ–‡æ•°ï¼Œå¤´å°¾æŒ‡é’ˆåœ¨éå†æ—¶è‚¯å®šä¸€æ ·ï¼Œå¦‚æœä¸ä¸€æ ·ï¼Œå¯ä»¥å»æ‰ä¸€ä¸ªï¼Œå¢åŠ iæˆ–å‡å°jï¼› public boolean validPalindrome(String s) { int i = -1, j = s.length(); while (++i &lt; --j) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j); } } return true; } private boolean isPalindrome(String s, int i, int j) { while (i &lt; j) { if (s.charAt(i++) != s.charAt(j--)) { return false; } } return true; } 88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„é—®é¢˜ï¼šç»™å®šä¸¤ä¸ªæœ‰åºæ•´æ•°æ•°ç»„ nums1 å’Œ nums2*ï¼Œå°† *nums2 åˆå¹¶åˆ° nums1 ä¸­ï¼Œä½¿å¾— num1 æˆä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ã€‚ è¯´æ˜: åˆå§‹åŒ– nums1 å’Œ nums2 çš„å…ƒç´ æ•°é‡åˆ†åˆ«ä¸º m å’Œ nã€‚ ä½ å¯ä»¥å‡è®¾ nums1 æœ‰è¶³å¤Ÿçš„ç©ºé—´ï¼ˆç©ºé—´å¤§å°å¤§äºæˆ–ç­‰äº m + n*ï¼‰æ¥ä¿å­˜ *nums2 ä¸­çš„å…ƒç´ ã€‚ ç¤ºä¾‹: è¾“å…¥: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 è¾“å‡º: [1,2,2,3,5,6] è§£å†³ï¼šä½¿ç”¨åŒæŒ‡é’ˆï¼Œéœ€è¦ä»å°¾å¼€å§‹éå†ï¼Œå¦åˆ™åœ¨nums1ä¸Šå½’å¹¶å¾—åˆ°çš„å€¼ä¼šè¦†ç›–è¿˜æœªè¿›è¡Œå½’å¹¶æ¯”è¾ƒçš„å€¼ã€‚ public void merge(int[] nums1, int m, int[] nums2, int n) { int index1 = m - 1, index2 = n - 1; int indexMerge = m + n - 1; while (index1 >= 0 || index2 >= 0) { if (index1 &lt; 0) { nums1[indexMerge--] = nums2[index2--]; } else if (index2 &lt; 0) { nums1[indexMerge--] = nums1[index1--]; } else if (nums1[index1] > nums2[index2]) { nums1[indexMerge--] = nums1[index1--]; } else { nums1[indexMerge--] = nums2[index2--]; } } } 633. å¹³æ–¹æ•°ä¹‹å’Œé—®é¢˜ï¼šç»™å®šä¸€ä¸ªéè´Ÿæ•´æ•° c ï¼Œä½ è¦åˆ¤æ–­æ˜¯å¦å­˜åœ¨ä¸¤ä¸ªæ•´æ•° a å’Œ bï¼Œä½¿å¾— a2 + b2 = cã€‚ ç¤ºä¾‹1: è¾“å…¥: 5 è¾“å‡º: True è§£é‡Š: 1 * 1 + 2 * 2 = 5ç¤ºä¾‹2: è¾“å…¥: 3 è¾“å‡º: Falseè§£å†³ï¼šä¸€ä¸ªä»å¤´éå†ï¼Œä¸€ä¸ªä»ç›®æ ‡æ•°å­—çš„å¼€æ–¹å¾€å›éå†ï¼Œå¦‚æœç›®æ ‡æ•°å­—å¤§äºå®é™…æ•°å­—ï¼Œåˆ™i++;å¦‚æœç›®æ ‡æ•°å­—å°äºå®é™…æ•°å­—ï¼Œåˆ™jâ€“;å¦‚æœç›®æ ‡æ•°å­—ç­‰äºå®é™…æ•°å­—ï¼Œåˆ™æ‰¾åˆ°äº†; public boolean judgeSquareSum(int c) { int i = 0, j = (int) Math.sqrt(c); while (i &lt;= j) { int powSum = i * i + j * j; if (powSum == c) { return true; } else if (powSum > c) { j--; } else { i++; } } return false; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"åŒæŒ‡é’ˆ","slug":"åŒæŒ‡é’ˆ","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/åŒæŒ‡é’ˆ/"}]},{"title":"LeetCodeä¸­çš„äºŒåˆ†æŸ¥æ‰¾","slug":"äºŒåˆ†æŸ¥æ‰¾","date":"2019-03-08T07:25:08.000Z","updated":"2019-09-10T09:40:34.940Z","comments":true,"path":"2019/03/08/er-fen-cha-zhao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/08/er-fen-cha-zhao/","excerpt":"","text":"äºŒåˆ†æŸ¥æ‰¾æœ€è¿‘åœ¨çœ‹ç®—æ³•ç¬¬å››ç‰ˆï¼Œå…¶ä¸­æœ‰è¯´åˆ°äºŒåˆ†æœç´¢ï¼Œä¹Ÿå°±æ˜¯äºŒåˆ†æŸ¥æ‰¾ï¼Œä¹Ÿåœ¨LeetCodeä¸Šåˆ·é¢˜ï¼Œæ€»ç»“ä¸‹ å®šä¹‰äºŒåˆ†æŸ¥æ‰¾åˆå«æŠ˜åŠæŸ¥æ‰¾ï¼Œè¦æ±‚å¾…æŸ¥æ‰¾çš„åºåˆ—æœ‰åºã€‚æ¯æ¬¡å–ä¸­é—´ä½ç½®çš„å€¼ä¸å¾…æŸ¥å…³é”®å­—æ¯”è¾ƒï¼Œå¦‚æœä¸­é—´ä½ç½®çš„å€¼æ¯”å¾…æŸ¥å…³é”®å­—å¤§ï¼Œåˆ™åœ¨å‰åŠéƒ¨åˆ†å¾ªç¯è¿™ä¸ªæŸ¥æ‰¾çš„è¿‡ç¨‹ï¼Œå¦‚æœä¸­é—´ä½ç½®çš„å€¼æ¯”å¾…æŸ¥å…³é”®å­—å°ï¼Œåˆ™åœ¨ååŠéƒ¨åˆ†å¾ªç¯è¿™ä¸ªæŸ¥æ‰¾çš„è¿‡ç¨‹ã€‚ç›´åˆ°æŸ¥æ‰¾åˆ°äº†ä¸ºæ­¢ï¼Œå¦åˆ™åºåˆ—ä¸­æ²¡æœ‰å¾…æŸ¥çš„å…³é”®å­—ã€‚ ä¼˜ç¼ºç‚¹ä¼˜ç‚¹æ˜¯æ¯”è¾ƒæ¬¡æ•°å°‘ï¼ŒæŸ¥æ‰¾é€Ÿåº¦å¿«ï¼Œå¹³å‡æ€§èƒ½å¥½ï¼›å…¶ç¼ºç‚¹æ˜¯è¦æ±‚å¾…æŸ¥è¡¨ä¸ºæœ‰åºè¡¨ï¼Œä¸”æ’å…¥åˆ é™¤å›°éš¾ã€‚å› æ­¤ï¼ŒæŠ˜åŠæŸ¥æ‰¾æ–¹æ³•é€‚ç”¨äºä¸ç»å¸¸å˜åŠ¨è€ŒæŸ¥æ‰¾é¢‘ç¹çš„æœ‰åºåˆ—è¡¨ã€‚ä½¿ç”¨æ¡ä»¶ï¼šæŸ¥æ‰¾åºåˆ—æ˜¯é¡ºåºç»“æ„ï¼Œæœ‰åºã€‚ æ—¶é—´å¤æ‚åº¦æ¯æ¬¡éƒ½èƒ½å°†æŸ¥æ‰¾åŒºé—´å‡åŠï¼Œè¿™ç§æŠ˜åŠç‰¹æ€§çš„ç®—æ³•æ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚ ç©ºé—´å¤æ‚åº¦ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦å¹¶ä¸æ˜¯è®¡ç®—å®é™…å ç”¨çš„ç©ºé—´ï¼Œè€Œæ˜¯è®¡ç®—æ•´ä¸ªç®—æ³•çš„è¾…åŠ©ç©ºé—´å•å…ƒçš„ä¸ªæ•° éé€’å½’æ–¹å¼ï¼š ç”±äºè¾…åŠ©ç©ºé—´æ˜¯å¸¸æ•°çº§åˆ«çš„æ‰€ä»¥ï¼š ç©ºé—´å¤æ‚åº¦æ˜¯O(1); é€’å½’æ–¹å¼ï¼š é€’å½’çš„æ¬¡æ•°å’Œæ·±åº¦éƒ½æ˜¯log2 N,æ¯æ¬¡æ‰€éœ€è¦çš„è¾…åŠ©ç©ºé—´éƒ½æ˜¯å¸¸æ•°çº§åˆ«çš„ï¼š ç©ºé—´å¤æ‚åº¦ï¼šO(log2N ) å®ç°1.éé€’å½’ä»£ç (ä½¿ç”¨çš„æ¯”è¾ƒå¤š) public static int biSearch(int []array,int a){ int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi){ mid=(lo+hi)/2; if(array[mid]==a){ return mid+1; }else if(array[mid]&lt;a){ lo=mid+1; }else{ hi=mid-1; } } return -1; } 2.é€’å½’å®ç° public static int sort(int []array,int a,int lo,int hi){ if(lo&lt;=hi){ int mid=(lo+hi)/2; if(a==array[mid]){ return mid+1; } else if(a>array[mid]){ return sort(array,a,mid+1,hi); }else{ return sort(array,a,lo,mid-1); } } return -1; } å˜ç§äºŒåˆ†æŸ¥æ‰¾å¯ä»¥æœ‰å¾ˆå¤šå˜ç§ï¼Œè¿™é‡Œä»‹ç»ä¸¤ä¸ªå˜ç§ï¼Œå®ç°æ—¶è¦æ³¨æ„è¾¹ç•Œå€¼å’ŒåŒºé—´çš„åˆ¤æ–­ã€‚ä¾‹å¦‚åœ¨ä¸€ä¸ªæœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ä¸­æŸ¥æ‰¾ key çš„æœ€å·¦ä½ç½®çš„å®ç°å¦‚ä¸‹ï¼š å¾ªç¯æ¡ä»¶ä¸º l &lt; h h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = m æœ€åè¿”å› l è€Œä¸æ˜¯ -1 å¦å¤–ï¼Œåœ¨ h çš„èµ‹å€¼è¡¨è¾¾å¼ä¸º h = mid çš„æƒ…å†µä¸‹ï¼Œå¦‚æœå¾ªç¯æ¡ä»¶ä¸º l &lt;= hï¼Œé‚£ä¹ˆä¼šå‡ºç°å¾ªç¯æ— æ³•é€€å‡ºçš„æƒ…å†µï¼Œå› æ­¤å¾ªç¯æ¡ä»¶åªèƒ½æ˜¯ l &lt; hã€‚public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt; h) { //æ³¨æ„åŒºé—´èŒƒå›´ int m = l + (h - l) / 2; if (nums[m] >= key) { h = m;//æ³¨æ„è¿™é‡Œhçš„èµ‹å€¼ } else { l = m + 1; } } return l;//æœ€åè¿”å›l } åœ¨ä¸€ä¸ªæœ‰é‡å¤å…ƒç´ çš„æ•°ç»„ä¸­æŸ¥è¯¢å…ƒç´ æœ€åä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼š public static int biSearch(int []array,int a){ int n=array.length; int low=0; int hi=n-1; int mid=0; while(low&lt;hi){ mid=(low+hi+1)/2; if(array[mid]&lt;=a){ low=mid; }else{ hi=mid-1; } } if(array[low]!=a){ return -1; }else{ return hi; } } Leetcodeé¢˜ç›®ï¼š744ã€Find Smallest Letter Greater Than Target (Easy) é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªæœ‰åºçš„å­—ç¬¦æ•°ç»„ letters å’Œä¸€ä¸ªå­—ç¬¦ targetï¼Œè¦æ±‚æ‰¾å‡º letters ä¸­å¤§äº target çš„æœ€å°å­—ç¬¦ï¼Œå¦‚æœæ‰¾ä¸åˆ°å°±è¿”å›ç¬¬ 1 ä¸ªå­—ç¬¦ã€‚Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œaâ€Output: â€œcâ€ Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œcâ€Output: â€œfâ€ Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œdâ€Output: â€œfâ€ Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œgâ€Output: â€œjâ€ Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œjâ€Output: â€œcâ€ Input:letters = [â€œcâ€, â€œfâ€, â€œjâ€]target = â€œkâ€Output: â€œcâ€ è§£é¢˜æ€è·¯ï¼šå…¸å‹çš„äºŒåˆ†æŸ¥æ‰¾çš„æ­£å¸¸å®ç°ï¼Œæœ€åçš„æ—¶å€™é€šè¿‡ä¸‰å…ƒè¿ç®—ç¬¦åˆ¤æ–­lè·Ÿnå¤§å°æ¥å†³å®šè¾“å‡ºlè¿˜æ˜¯nï¼Œåœ¨äºŒåˆ†æŸ¥æ‰¾ä¸­ï¼Œä¸­é—´å€¼çš„è®¡ç®—ç”¨m = l + (h - l) / 2 æ¯”ç”¨ m = (l + h) / 2è®¡ç®—è¦å¥½ï¼Œå¯ä»¥é˜²æ­¢l + h å‡ºç°åŠ æ³•æº¢å‡ºã€‚ public char nextGreatestLetter(char[] letters, char target) { int n = letters.length; int l = 0, h = n - 1; while (l &lt;= h) { int m = l + (h - l) / 2; if (letters[m] &lt;= target) { l = m + 1; } else { h = m - 1; } } return l &lt; n ? letters[l] : letters[0]; } 34ã€Search for a Range (Medium) é¢˜ç›®æè¿°ï¼šç»™å®šæ•´æ•°æ•°ç»„ï¼Œæ•°ç»„æŒ‰å‡åºæ’åºï¼Œæ‰¾å‡ºç»™å®šç›®æ ‡å€¼çš„èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®ã€‚ æ‚¨çš„ç®—æ³•çš„è¿è¡Œæ—¶å¤æ‚æ€§å¿…é¡»æ˜¯Oï¼ˆlog nï¼‰çš„é¡ºåºã€‚ å¦‚æœåœ¨æ•°ç»„ä¸­æ‰¾ä¸åˆ°ç›®æ ‡ï¼Œåˆ™è¿”å›[-1ï¼Œ-1]ã€‚ Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] è§£é¢˜æ€è·¯ï¼šæœ¬é¢˜åŸºäºäºŒåˆ†æŸ¥æ‰¾çš„å˜ç§ï¼Œè€ƒè™‘å…ˆå†™ä¸€ä¸ªæ–¹æ³•æ¥åˆ¤æ–­target(å¯é‡å¤)åœ¨æ•°ç»„ä¸­å‡ºç°çš„æœ€å·¦ä½ç½®ï¼Œå†æ±‚æ±‚target+1å‡ºç°çš„æœ€å·¦ä½ç½®ï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒå³å¯ã€‚ class Solution { public int[] searchRange(int[] nums, int target) { int first = binarySearch(nums,target); int last = binarySearch(nums,target + 1) -1;//æ±‚target+1å‡ºç°çš„æœ€å·¦ä½ç½® if(first ==nums.length || nums[first]!=target){ return new int []{-1,-1}; }else{ return new int[]{first,first>last?first:last};//å½“æŸ¥æ‰¾çš„ç›®æ ‡æ•°åœ¨æœ€åä¸€ä¸ªæ—¶,firstå¤§äºlast } } //ä»æ•°ç»„ä¸­æ‰¾å‡ºé‡å¤å…ƒç´ çš„æœ€å·¦ä½ç½® private static int binarySearch(int [] nums,int a){ int l = 0,h = nums.length;//æ³¨æ„è¿™é‡Œhçš„å–å€¼ï¼Œå½“æ•°ç»„ä¸­ä¸º[2,2]ç›®æ ‡ä¸º2æ—¶ï¼Œfirstå’Œlastéƒ½ä¸º0ï¼Œæ‰€ä»¥è¿™é‡Œhä¸èƒ½ä¸ºnums.length-1; while(l &lt; h){ int min = l + (h - l) / 2; if(nums[min] >= a){ h = min; }else{ l = min + 1; } } return l; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BinarySearch/"}]}]}