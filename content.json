{"meta":{"title":"森森的博客","subtitle":"乐观阳光，爱好运动","description":"20毕业，后台方向，还未上岸。","author":"ForeverSen","url":"http://github.com/ForeverSen/ForeverSen.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:56:23.417Z","comments":true,"path":"about/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:27:12.433Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-01T13:25:30.000Z","updated":"2019-09-10T04:28:42.208Z","comments":true,"path":"friends/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-01T10:23:38.000Z","updated":"2019-09-10T04:28:54.241Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"排序","date":"2019-09-06T13:44:28.040Z","updated":"2019-09-10T06:45:02.465Z","comments":true,"path":"2019/09/06/pai-xu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/06/pai-xu/","excerpt":"","text":"堆排序今天在刷leetcode215题，碰到求解 TopK Elements问题，一共有三种方法，总结一下： 题目描述：找到未排序数组中的第k个最大元素。请注意，它是排序顺序中的第k个最大元素，而不是第k个不同元素。 Input: [3,2,1,5,6,4] and k = 2 Output: 5 Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 解题方法：1、对整个输入数组进行排序，然后通过它的索引（即O（1））操作访问该元素： ​ 时间复杂度 O(NlogN)，空间复杂度 O(1)。 public int findKthLargest(int[] nums, int k) { final int N = nums.length; Arrays.sort(nums); return nums[N - k]; } 2、堆排序也可以用于求解 Kth Element 问题，堆顶元素就是 Kth Element。使用面向最小值的优先级队列来存储第K个最大值。该算法迭代整个输入并维持优先级队列的大小。优先队列可以用堆来实现： 时间复杂度 O(NlogK)，空间复杂度 O(K)。 public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); // 小顶堆 for (int val : nums) { pq.add(val); if (pq.size() &gt; k) // 维护堆的大小为 K pq.poll(); } return pq.peek(); } 3、基于切分partion的快速选择算法；快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 k 个元素。 时间复杂度 最佳情况：O(N) 最坏情况：O（N ^ 2），空间复杂度 O(1) 我们如何才能改进上述解决方案并使其保证O（N）？答案非常简单，刚开始时要对数组进行洗牌shuffle，使其随机化输入，这样即使提供最坏情况输入，算法也不会受到影响。因此，所需要做的就是改变输入。 public int findKthLargest(int[] nums, int k) { shuffle(nums);//打乱数组 k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) { final int j = partition(nums, lo, hi); if(j &lt; k) { lo = j + 1; } else if (j &gt; k) { hi = j - 1; } else { break; } } return nums[k]; } //切分 private int partition(int[] a, int lo, int hi) { int i = lo; int j = hi + 1; while(true) { while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j &gt; lo &amp;&amp; less(a[lo], a[--j])); if(i &gt;= j) { break; } exch(a, i, j); } exch(a, lo, j); return j; } //交换 private void exch(int[] a, int i, int j) { final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } //比较是否小于 private boolean less(int v, int w) { return v &lt; w; } private void shuffle(int a[]) { final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) { final int r = random.nextInt(ind + 1); exch(a, ind, r); } } 桶排序Leetcode : 347. Top K Frequent Elements (Medium) 找出出现频率最多的 k 个数 题目描述：给定非空的整数数组，返回k个最常见的元素。 Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]解决方法：设置若干个桶，每个桶存储出现频率相同的数，并且桶的下标代表桶中数出现的频率。 class Solution { public List&lt;Integer> topKFrequent(int[] nums, int k) { Map&lt;Integer,Integer> map = new HashMap&lt;>(); for(int a : nums){ map.put(a,map.getOrDefault(a,0)+1);//判断a是否存在，如果没出现 } List&lt;Integer> [] buckets = new ArrayList[nums.length + 1]; for(int i : map.keySet()){ int frequency = map.get(i); if(buckets[frequency]==null){ buckets[frequency] = new ArrayList&lt;>(); } buckets[frequency].add(i); } List&lt;Integer> topK = new ArrayList&lt;>(); //从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数 for(int i = buckets.length - 1; i >= 0 &amp;&amp; topK.size() &lt; k;i--){ if(buckets[i]!=null){ topK.addAll(buckets[i]); } } return topK; } } 荷兰国旗问题：75. Sort Colors (Medium) 题目描述：给定一个具有红色，白色或蓝色的n个对象的数组，对它们进行就地 排序，使相同颜色的对象相邻，颜色顺序为红色，白色和蓝色。 这里，我们将使用整数0,1和2分别表示红色，白色和蓝色。 注意： 您不应该使用库的排序功能来解决此问题。 Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]解决方法：使用三向切分快速排序，将数组分成三个区间：等于红色、等于白色、等于蓝色。 class Solution { public void sortColors(int[] nums) { int zero = 0; int two = nums.length - 1; int one = 0; while(one &lt;= two){ if (nums[one] == 0){ swap(nums,zero++,one++);//从前面开始交换的已经比较过了 }else if (nums[one] == 2){ swap(nums,two--,one);//这里注意one不要++，从后面交换到前面的还无法比较 }else { one++; } } } private static void swap(int [] nums,int a,int b){ int i = nums[a]; nums[a] = nums[b]; nums[b] = i; } }","categories":[],"tags":[]},{"title":"","slug":"二分查找","date":"2019-09-06T06:27:01.138Z","updated":"2019-09-10T06:44:50.905Z","comments":true,"path":"2019/09/06/er-fen-cha-zhao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/06/er-fen-cha-zhao/","excerpt":"","text":"二分查找最近在看算法第四版，其中有说到二分搜索，也就是二分查找，也在LeetCode上刷题，总结下 定义二分查找又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。 优缺点优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。 时间复杂度每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数 非递归方式： 由于辅助空间是常数级别的所以： 空间复杂度是O(1); 递归方式： 递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的： 空间复杂度：O(log2N ) 实现1.非递归代码(使用的比较多) public static int biSearch(int []array,int a){ int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi){ mid=(lo+hi)/2; if(array[mid]==a){ return mid+1; }else if(array[mid]&lt;a){ lo=mid+1; }else{ hi=mid-1; } } return -1; } 2.递归实现 public static int sort(int []array,int a,int lo,int hi){ if(lo&lt;=hi){ int mid=(lo+hi)/2; if(a==array[mid]){ return mid+1; } else if(a>array[mid]){ return sort(array,a,mid+1,hi); }else{ return sort(array,a,lo,mid-1); } } return -1; } 变种二分查找可以有很多变种，这里介绍两个变种，实现时要注意边界值和区间的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下： 循环条件为 l &lt; h h 的赋值表达式为 h = m 最后返回 l 而不是 -1 另外，在 h 的赋值表达式为 h = mid 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt; h) { //注意区间范围 int m = l + (h - l) / 2; if (nums[m] >= key) { h = m;//注意这里h的赋值 } else { l = m + 1; } } return l;//最后返回l } 在一个有重复元素的数组中查询元素最后一次出现的位置： public static int biSearch(int []array,int a){ int n=array.length; int low=0; int hi=n-1; int mid=0; while(low&lt;hi){ mid=(low+hi+1)/2; if(array[mid]&lt;=a){ low=mid; }else{ hi=mid-1; } } if(array[low]!=a){ return -1; }else{ return hi; } } Leetcode题目：744、Find Smallest Letter Greater Than Target (Easy) 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。Input:letters = [“c”, “f”, “j”]target = “a”Output: “c” Input:letters = [“c”, “f”, “j”]target = “c”Output: “f” Input:letters = [“c”, “f”, “j”]target = “d”Output: “f” Input:letters = [“c”, “f”, “j”]target = “g”Output: “j” Input:letters = [“c”, “f”, “j”]target = “j”Output: “c” Input:letters = [“c”, “f”, “j”]target = “k”Output: “c” 解题思路：典型的二分查找的正常实现，最后的时候通过三元运算符判断l跟n大小来决定输出l还是n，在二分查找中，中间值的计算用m = l + (h - l) / 2 比用 m = (l + h) / 2计算要好，可以防止l + h 出现加法溢出。 public char nextGreatestLetter(char[] letters, char target) { int n = letters.length; int l = 0, h = n - 1; while (l &lt;= h) { int m = l + (h - l) / 2; if (letters[m] &lt;= target) { l = m + 1; } else { h = m - 1; } } return l &lt; n ? letters[l] : letters[0]; } 34、Search for a Range (Medium) 题目描述：给定整数数组，数组按升序排序，找出给定目标值的起始位置和结束位置。 您的算法的运行时复杂性必须是O（log n）的顺序。 如果在数组中找不到目标，则返回[-1，-1]。 Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：本题基于二分查找的变种，考虑先写一个方法来判断target(可重复)在数组中出现的最左位置，再求求target+1出现的最左位置，然后进行比较即可。 class Solution { public int[] searchRange(int[] nums, int target) { int first = binarySearch(nums,target); int last = binarySearch(nums,target + 1) -1;//求target+1出现的最左位置 if(first ==nums.length || nums[first]!=target){ return new int []{-1,-1}; }else{ return new int[]{first,first>last?first:last};//当查找的目标数在最后一个时,first大于last } } //从数组中找出重复元素的最左位置 private static int binarySearch(int [] nums,int a){ int l = 0,h = nums.length;//注意这里h的取值，当数组中为[2,2]目标为2时，first和last都为0，所以这里h不能为nums.length-1; while(l &lt; h){ int min = l + (h - l) / 2; if(nums[min] >= a){ h = min; }else{ l = min + 1; } } return l; } }","categories":[],"tags":[]}]}