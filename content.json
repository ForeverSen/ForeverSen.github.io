{"meta":{"title":"森森的博客","subtitle":"会挽雕弓如满月，西北望，射天狼。","description":"20毕业，后台方向，还未上岸。","author":"ForeverSen","url":"http://github.com/ForeverSen/ForeverSen.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:27:12.433Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:56:23.417Z","comments":true,"path":"about/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-01T13:25:30.000Z","updated":"2019-09-10T04:28:42.208Z","comments":true,"path":"friends/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-01T10:23:38.000Z","updated":"2019-09-10T04:28:54.241Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode中BFS&DFS","slug":"BFS","date":"2019-05-02T10:25:08.000Z","updated":"2019-09-10T09:52:30.929Z","comments":true,"path":"2019/05/02/bfs/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/02/bfs/","excerpt":"","text":"深度优先遍历DFS： 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 DFS应用：使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解 单点连通性、单点可达性、单点路径等。 实现：使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以用递归。 LeetCode相关题解：695. Max Area of Island给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路:使用dfs计算每个岛屿的面积，在dfs期间，将岛中每个点的值设置为0，表示为已标记。 /* *使用DFS，先用二维数组存储四个方向，然后分别递归遍历每个点 *遍历过的点将其置为0，不再遍历 */ class Solution { private int m, n; private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};//四个方向 public int maxAreaOfIsland(int[][] grid) { m = grid.length;//行 n = grid[0].length;//列 int maxArea = 0; if (m == 0 || grid == null) { return 0; } for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { maxArea = Math.max(maxArea,dfs(grid,i,j)); } } return maxArea; } private int dfs(int [][] grid,int i,int j){ if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || grid[i][j] == 0) { return 0; } grid[i][j] = 0;//设为已标记 int area = 1; for (int [] d : direction) { area += dfs(grid,i + d[0],j + d[1]); } return area; } } 200. Number of Islands 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3解题思路：本题跟上面leetcode695有点类似，都是岛屿问题，可以将矩阵表示看成一张有向图，把问题转换为对每个点进行DFS遍历，如果有遍历完一个，那么岛屿数量+1 class Solution { private int directions[][] = {{0,1},{0,-1},{1,0},{-1,0}}; private int m , n; public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } m = grid.length; n = grid[0].length; int num = 0;//岛屿数量 for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { if (grid[i][j] != '0') { dfs(grid,i,j); num++; } } } return num; } private void dfs(char [][] grid,int i,int j){ if(i >= m || i &lt; 0 || j >= n || j &lt; 0 || grid[i][j] =='0'){ return; } grid[i][j] = '0';//遍历过的不再遍历 for(int d[] : directions){ dfs(grid,i + d[0],j + d[1]); } } } 547. Friend Circles班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1解题思路： DFS中的朋友圈问题，注意这是个N*N矩阵，可以使用一个hasVisited数组, 依次判断每个节点, 如果其未访问, 朋友圈数加1并对该节点进行dfs搜索标记所有访问到的节点。 class Solution { private int m; //N*N矩阵 public int findCircleNum(int[][] M) { if (M.length == 0 || M == null) { return -1; } m = M.length; boolean [] hasVisited = new boolean[m]; //是否访问 int circleNum = 0; for (int i = 0; i &lt; m; i++) { if (!hasVisited[i]) { dfs(M,i,hasVisited); circleNum++; } } return circleNum; } private void dfs(int [][] M,int i,boolean [] hasVisited) { hasVisited[i] = true; for (int k = 0; k &lt; m; k++) { if (M[i][k] == 1 &amp;&amp; !hasVisited[k]) dfs(M,k,hasVisited); } } } 207. Course Schedule现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。解题思路：构建逆邻接表，实现深度优先遍历，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。另外，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。 /** *采用深度优先遍历解决有无环 *如果采用BFS会更快 **/ class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List&lt;Integer> [] graphic = new List[numCourses]; boolean [] marked = new boolean[numCourses];//判断那个数是否被标记 for (int i = 0;i &lt; numCourses;i++){ graphic[i] = new ArrayList();//对每个数字生成一个链表 } for (int [] pre : prerequisites){ graphic[pre[0]].add(pre[1]); } for (int i = 0;i &lt; numCourses;i++){ if(hasCycle(graphic,marked,i)){ return false; } } return true; } //判断是否含环 private boolean hasCycle(List&lt;Integer> [] graphic,boolean [] marked,int cur){ if (marked[cur]){ return true;//如果被标记，则直接返回true } marked[cur] = true; for (int next : graphic[cur]){ if (hasCycle(graphic,marked,next)){ return true; } } marked[cur] = false; return false; } } 130. Surrounded Regions给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。示例: X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为： X X X XX X X XX X X XX O X X解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路：首先对矩阵边界上所有的O做深度优先搜索，将相连的O更改为 * ，然后编辑数组，将数组中O更改为X，将数组中 * 更改为O。 class Solution { private int m,n; private int [] [] directions = {{0,1},{0,-1},{1,0},{-1,0}}; public void solve(char[][] board) { if (board == null || board.length == 0){ return; } m = board.length; n = board[0].length; //边界值遍历 for (int i = 0; i &lt; m; i++) { dfs(board, i, 0); dfs(board, i, n-1); } for (int j = 0; j &lt; n; j++) { dfs(board, 0, j); dfs(board, m - 1, j); } for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++){ if(board[i][j] == 'O') { board [i][j] = 'X'; //将被包围在中间的置为X }else if (board[i][j] == '*'){ board [i][j] = 'O'; //将边界的置为O } } } } private void dfs(char [][] board, int i, int j) { if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || board[i][j] != 'O'){ return; } board[i][j] = '*'; //将被包围的O，并且O不在边界 置为其他符号 for (int [] d: directions) { dfs(board, i + d[0],j + d[1]); } } } 总结：通过刷题知道DFS类型的解题思路，大概有岛屿问题，朋友圈问题，此时解题模板也是类似的，用递归遍历，遍历过了点设为已标记。 广度优先遍历BFS： 广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。需要注意，遍历过的节点不能再次被遍历。 BFS应用：BFS可用于解决2类问题： 从A出发是否存在到达B的路径；从A出发到达B的最短路径(这个应该叫最少步骤合理，第一次遍历到目的节点，其所经过的路径为最短路径)；注意，使用 BFS 只能求解无权图的最短路径。 实现：使用队列来存储每一轮遍历得到的节点,对于遍历过的节点，应该将它标记，防止重复遍历。 典例：计算在网格中从原点到特定点的最短路径长度 [[1,1,0,1],[1,0,1,0],[1,1,1,1],[1,0,1,1]] 1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。 由于每个点需要保存x坐标，y坐标以及长度，所以必须要用一个类将三个属性封装起来。 由于bfs每次只将距离加一，所以当位置抵达终点时，此时的距离就是最短路径了。 private static class Position { int r, c, length; public Position(int r, int c, int length) { this.r = r; this.c = c; this.length = length; } } public static int minPathLength(int[][] grids, int tr, int tc) { int[][] next = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int m = grids.length, n = grids[0].length; Queue&lt;Position> queue = new LinkedList&lt;>(); queue.add(new Position(0, 0, 1)); while (!queue.isEmpty()) { Position pos = queue.poll(); for (int i = 0; i &lt; 4; i++) {//4是数组next的长度 Position nextPos = new Position(pos.r + next[i][0], pos.c + next[i][1], pos.length + 1); if (nextPos.r &lt; 0 || nextPos.r >= m || nextPos.c &lt; 0 || nextPos.c >= n) continue; if (grids[nextPos.r][nextPos.c] != 1) continue; grids[nextPos.r][nextPos.c] = 0; if (nextPos.r == tr &amp;&amp; nextPos.c == tc) return nextPos.length; queue.add(nextPos); } } return -1; } LeetCode相关题解：279. Perfect Square(Medium) 题目描述：给定一个正整数n，求和为n的最小全平方数（例如，1，4，9，16，…）。Input: n = 12Output: 3Explanation: 12 = 4 + 4 + 4. Input: n = 13Output: 2Explanation: 13 = 4 + 9. 解题思路: 思路来源参考@CyC2018Leetcode刷题题解 可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。 要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。 首先生成平方数序列放入数组，然后通过队列，每次减去一个平方数，把剩下的数加入队列，也就是通过bfs的方式，当此时的数刚好等于平方数，则满足题意，由于每次循环level加一，所以最后输出的level就是需要的平方数个数 class Solution { public int numSquares(int n) { List&lt;Integer> squares = getSquares(n);//获取所有平方数，存在链表中 Queue&lt;Integer> queue = new LinkedList&lt;>(); boolean[] marked = new boolean[n + 1];//这里是n+1，比较好计算 queue.add(n); marked[n] = true; int level = 0;//level为第几层 while(!queue.isEmpty()){ int size = queue.size(); level++; while(size-- > 0){ int top = queue.poll(); for(int s : squares){ if (top - s==0){ return level; } if (top - s &lt; 0){ break; } if (marked[top - s]){ continue; } marked[top - s] =true;//标记为true的不再遍历 queue.add(top - s); } } } return n; } //先定义一个求小于n的所有平方数的方法 private List getSquares(int n){ List&lt;Integer> list = new ArrayList&lt;>(); int square = 1; int i = 3; while (square &lt;= n){ list.add(square); square += i; i += 2; } return list; } } ```","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BFS-DFS/"}]},{"title":"LeetCode中常见的链表题目","slug":"链表","date":"2019-04-28T07:45:28.000Z","updated":"2019-09-10T09:47:00.811Z","comments":true,"path":"2019/04/28/lian-biao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/28/lian-biao/","excerpt":"","text":"开始对LeetCode中链表相关问题进行刷题🤔 206. Reverse Linked List题目描述：反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路：1 → 2 → 3 → 4→ 5→ Ø，改成 Ø ← 1 ← 2 ← 3←4←5定义一个前结点pre和当前结点cur，在遍历列表时，将当前节点的 next 指针改为指向前面一个元素。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; //前一个节点 ListNode cur = head; while (cur != null) { ListNode nextNode = cur.next; cur.next = pre; //指针指向前一个结点 pre = cur; cur = nextNode; } return pre; } } 21. Merge Two Sorted Lists题目描述：合并两个已排序的链表，并将其作为一个新列表返回。新列表应该通过将前两个列表的节点拼接在一起来创建。 Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路：利用递归，比较两个链表第一个结点的大小，确定头结点的位置 ，头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复上述步骤，直到有链表为空。 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; //先判断两个链表的第一个数谁比较大 if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; } else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 83. Remove Duplicates from Sorted List题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 Example 1: Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3解题思路：可以使用一个临时指针node，需要注意头指针“head”不应该直接移动或更新，因为它指向列表的头部，你需要在最后返回这个头部。所有操作都应该使用“node”来防止丢失头部。 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null){ return null; } ListNode node = head; //使用临时指针 while (node.next != null) { if (node.val == node.next.val) { node.next = node.next.next; }else{ node = node.next; } } return head; } } 也可以使用递归： class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; } } 24. Swap Nodes in Pairs题目描述：定一个链表，交换每两个相邻节点并返回其头部。 不能修改列表节点中的值，只能更改节点本身。 Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.解题思路：本题同样可以使用递归或者按照迭代，两种方式运行速度和内存都差不多。 迭代： // 1->2->3->4 class Solution { public ListNode swapPairs(ListNode head) { ListNode node = new ListNode(0); node.next = head; ListNode temp = node; while (temp.next != null &amp;&amp; temp.next.next != null) { ListNode l1 = temp.next; ListNode l2 = temp.next.next; ListNode next = l2.next; temp.next = l2; l2.next = l1; l1.next = next; temp = l1; } return node.next; //head此时已被改变 } } 递归： class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; } } 19.Remove Nth Node From End of List题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.解题思路：题目那里描述可否用一次遍历就完成，刚开始我只想到用两次遍历，后来发现还可以使用双指针实现一次遍历就解题： 两次遍历：删除从列表开头数起的第 (L - n + 1) 个结点，其中 L 是列表的长度。第一次遍历中先算出链表长度，第二次遍历删除该数，注意添加一个临时结点作为辅助，该结点位于列表头部。该结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode temp= new ListNode(0); //临时结点 temp.next = head; ListNode node = head; int length = 0; //链表长度 while (node != null) { node = node.next; length++; } length -= n; node = temp; while (length > 0) { length--; node = node.next; } node.next = node.next.next; return temp.next; } } 一次遍历：使用两个指针，第一个指针fast先开始移动n步，然后第二个指针slow从头开始移动，此时第一个指针也一起移动，这样就可以使得在移动过程中两个指针保持n步的距离，直到fast到达最后一个结点。此时slow将指向从最后一个结点数起的第 n 个结点，我们重新链接slow所引用的结点的 next 指针指向该结点的下下个结点。 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head; while (n-- > 0) { fast = fast.next; } if (fast == null) return head.next; //防止极端情况 ListNode slow = head; while (fast.next != null) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return head; } } 725. Split Linked List in Parts题目描述：给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个符合上述规则的链表的列表。举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ] 示例 1： 输入: root = [1, 2, 3], k = 5 输出: [[1],[2],[3],[],[]] 解释: 输入输出各部分都应该是链表，而不是数组。 例如, 输入的结点 root 的 val= 1, root.next.val = 2, \\root.next.next.val = 3, 且 root.next.next.next = null。 第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。 最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。 示例 2： 输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] 解释: 输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。解题思路：首先求出链表长度，然后看链表长度是否平均分配，对其求余数即可，然后用数组来保存每一个切割那部分，最终将切断上一部分的最后一个节点和下一部分的第一个节点之间的链接。 class Solution { public ListNode[] splitListToParts(ListNode root, int k) { ListNode node = root; int length = 0; //链表长度 while (node != null) { length++; node = node.next; } node = root; int mod = length % k; //哪一个多余 int size = length / k; //分成几部分 ListNode result [] = new ListNode[k]; //用数组保存 for (int i = 0; node != null &amp;&amp; i &lt; k; i++) { result[i] = node; int cursize = size + (mod-- > 0 ? 1:0); for (int j = 0; j &lt; cursize - 1; j++) { node = node.next; } ListNode next = node.next; node.next = null; node = next; } return result; } } 总结：在链表中要理解每个节点和每个节点是相连的，如何来求链表长度，时刻要注意使用临时指针来代替头部分或者其他部分；用两个指针（一个快指针，一个慢指针）求链表中的中间结点；同时中也要灵活运用递归和迭代。 对链表刷题告一段落，开始新的tag刷题😀","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/链表/"}]},{"title":"LeetCode中栈和队列相关题目","slug":"栈和队列","date":"2019-04-15T08:28:52.000Z","updated":"2019-09-10T09:48:53.469Z","comments":true,"path":"2019/04/15/zhan-he-dui-lie/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/15/zhan-he-dui-lie/","excerpt":"","text":"栈和队列开始对数据结构中栈和队列相关题目进行刷题~ 155. 最小栈题目描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 解题思路：最小值栈问题，可以使用两个栈，一个存放数据，一个存放最小值，每次插入数据时两个栈都要插入，删除时每个栈也要删除。 这里还有一个栈的解决方案值得参考 class MinStack { private Stack&lt;Integer> dataStack; //存放数据 private Stack&lt;Integer> minStack; //存最小值 int min; /** initialize your data structure here. */ public MinStack() { dataStack = new Stack&lt;>(); minStack = new Stack&lt;>(); min = Integer.MAX_VALUE; } public void push(int x) { dataStack.push(x); min = Math.min(min,x); minStack.push(min); } public void pop() { dataStack.pop(); minStack.pop(); min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek(); } public int top() { return dataStack.peek(); } public int getMin() { return minStack.peek(); } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 232. 用栈实现队列题目描述：使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 示例：MyQueue queue = new MyQueue(); queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 解题思路：栈的特点是后进先出，而队列是先进先出，因此，可以考虑用两个栈来实现，这样就能达到先进先出的效果。stack1表示入栈，stack2表示出栈。 class MyQueue { private Stack&lt;Integer> stack1; //入栈 private Stack&lt;Integer> stack2; //出栈 /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;>(); stack2 = new Stack&lt;>(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { peek(); //执行代码类同peek() 故用peek代替 return stack2.pop(); } /** Get the front element. */ public int peek() { if (stack2.isEmpty()){ while (!stack1.isEmpty()) { int temp = stack1.pop(); stack2.push(temp); } } return stack2.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack2.isEmpty() &amp;&amp; stack1.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈题目描述：使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空 解题思路：用队列实现栈的话使用一个队列就可以，因为在一开始队列为空，需要进行push操作，所以将 x 插入队列尾部之后，需要让除了 x 之外的所有元素先出队列，再入队列。 class MyStack { private Queue&lt;Integer> queue; /** Initialize your data structure here. */ public MyStack() { queue = new LinkedList&lt;>(); } /** Push element x onto stack. */ public void push(int x) { queue.offer(x); int size = queue.size(); while(--size > 0) { queue.offer(queue.poll()); } } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue.poll(); } /** Get the top element. */ public int top() { return queue.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 20. 有效的括号题目描述： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true解题思路： 先判断开头，然后用一个栈来保存结尾，根据其后进先出得特点，然后每次再弹出。 class Solution { public boolean isValid(String s) { Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()){ if (c == '('){ stack.push(')'); } else if (c == '{') { stack.push('}'); } else if (c == '[') { stack.push(']'); } else if (stack.isEmpty() || stack.pop() != c) { return false; } } return stack.isEmpty(); } } 对栈和队列的刷题告一段落，开始继续新的阶段刷题。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/栈和队列/"}]},{"title":"LeetCode中常见的堆排序","slug":"排序","date":"2019-04-07T01:25:08.000Z","updated":"2019-09-10T09:42:21.787Z","comments":true,"path":"2019/04/07/pai-xu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/07/pai-xu/","excerpt":"","text":"堆排序今天在刷leetcode215题，碰到求解 TopK Elements问题，一共有三种方法，总结一下： 题目描述：找到未排序数组中的第k个最大元素。请注意，它是排序顺序中的第k个最大元素，而不是第k个不同元素。 Input: [3,2,1,5,6,4] and k = 2 Output: 5 Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 解题方法：1、对整个输入数组进行排序，然后通过它的索引（即O（1））操作访问该元素： ​ 时间复杂度 O(NlogN)，空间复杂度 O(1)。 public int findKthLargest(int[] nums, int k) { final int N = nums.length; Arrays.sort(nums); return nums[N - k]; } 2、堆排序也可以用于求解 Kth Element 问题，堆顶元素就是 Kth Element。使用面向最小值的优先级队列来存储第K个最大值。该算法迭代整个输入并维持优先级队列的大小。优先队列可以用堆来实现： 时间复杂度 O(NlogK)，空间复杂度 O(K)。 public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>(); // 小顶堆 for (int val : nums) { pq.add(val); if (pq.size() > k) // 维护堆的大小为 K pq.poll(); } return pq.peek(); } 3、基于切分partion的快速选择算法；快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 k 个元素。 时间复杂度 最佳情况：O(N) 最坏情况：O（N ^ 2），空间复杂度 O(1) 我们如何才能改进上述解决方案并使其保证O（N）？答案非常简单，刚开始时要对数组进行洗牌shuffle，使其随机化输入，这样即使提供最坏情况输入，算法也不会受到影响。因此，所需要做的就是改变输入。 public int findKthLargest(int[] nums, int k) { shuffle(nums);//打乱数组 k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) { final int j = partition(nums, lo, hi); if(j &lt; k) { lo = j + 1; } else if (j > k) { hi = j - 1; } else { break; } } return nums[k]; } //切分 private int partition(int[] a, int lo, int hi) { int i = lo; int j = hi + 1; while(true) { while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j > lo &amp;&amp; less(a[lo], a[--j])); if(i >= j) { break; } exch(a, i, j); } exch(a, lo, j); return j; } //交换 private void exch(int[] a, int i, int j) { final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } //比较是否小于 private boolean less(int v, int w) { return v &lt; w; } private void shuffle(int a[]) { final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) { final int r = random.nextInt(ind + 1); exch(a, ind, r); } } 桶排序Leetcode : 347. Top K Frequent Elements (Medium) 找出出现频率最多的 k 个数 题目描述：给定非空的整数数组，返回k个最常见的元素。 Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]解决方法：设置若干个桶，每个桶存储出现频率相同的数，并且桶的下标代表桶中数出现的频率。 class Solution { public List&lt;Integer> topKFrequent(int[] nums, int k) { Map&lt;Integer,Integer> map = new HashMap&lt;>(); for(int a : nums){ map.put(a,map.getOrDefault(a,0)+1);//判断a是否存在，如果没出现 } List&lt;Integer> [] buckets = new ArrayList[nums.length + 1]; for(int i : map.keySet()){ int frequency = map.get(i); if(buckets[frequency]==null){ buckets[frequency] = new ArrayList&lt;>(); } buckets[frequency].add(i); } List&lt;Integer> topK = new ArrayList&lt;>(); //从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数 for(int i = buckets.length - 1; i >= 0 &amp;&amp; topK.size() &lt; k;i--){ if(buckets[i]!=null){ topK.addAll(buckets[i]); } } return topK; } } 荷兰国旗问题：75. Sort Colors (Medium) 题目描述：给定一个具有红色，白色或蓝色的n个对象的数组，对它们进行就地 排序，使相同颜色的对象相邻，颜色顺序为红色，白色和蓝色。 这里，我们将使用整数0,1和2分别表示红色，白色和蓝色。 注意： 您不应该使用库的排序功能来解决此问题。 Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]解决方法：使用三向切分快速排序，将数组分成三个区间：等于红色、等于白色、等于蓝色。 class Solution { public void sortColors(int[] nums) { int zero = 0; int two = nums.length - 1; int one = 0; while(one &lt;= two){ if (nums[one] == 0){ swap(nums,zero++,one++);//从前面开始交换的已经比较过了 }else if (nums[one] == 2){ swap(nums,two--,one);//这里注意one不要++，从后面交换到前面的还无法比较 }else { one++; } } } private static void swap(int [] nums,int a,int b){ int i = nums[a]; nums[a] = nums[b]; nums[b] = i; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Sort/"}]},{"title":"LeetCode中常见的贪心题目","slug":"贪心算法","date":"2019-04-01T10:45:28.000Z","updated":"2019-09-10T09:45:03.856Z","comments":true,"path":"2019/04/01/tan-xin-suan-fa/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/01/tan-xin-suan-fa/","excerpt":"","text":"贪心算法：定义：贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 455. Assign Cookies题目描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.解题思路：贪心就是给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因为最小的孩子最容易得到满足，所以先满足最小的孩子。通过使用这种贪婪的方法，浪费的cookie的总和将是最小的。因此要对两个数组进行排序，然后进行比较即可。 //[1,2], [1,2,3] class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int gi = 0, si = 0; while (si &lt; s.length &amp;&amp; gi &lt; g.length) { if (g[gi] &lt;= s[si]) { gi++; } si++; } return gi; } } 435. Non-overlapping Intervals题目描述：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。解题思路：经典的贪婪问题：间隔调度，下面那一题LeetCode452也是同样思路 先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。 按区间的结尾进行升序排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 在对数组进行排序的时候也可以使用 lambda 表示式来创建 Comparator ，不过算法运行时间会比较长点。 class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length == 0) { return 0; } Arrays.sort(intervals,new Comparator&lt;int [] >(){ public int compare(int [] a1,int [] a2) { return a1[1] - a2[1]; //升序排列 } }); int count = 1; //最多能组成的不重叠区间个数 int end = intervals[0][1]; for (int i = 0; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; end) { continue; } end = intervals[i][1]; count++; } return intervals.length - count; } } 452. Minimum Number of Arrows to Burst Balloon题目描述：在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 输入: [[10,16], [2,8], [1,6], [7,12]] 输出: 2 解释: 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。解题思路：本题跟上一题几乎一样的实现方法，说白了就是计算不重叠的区间个数，并且按结束坐标对数组进行排序，然后遍历判断不过这里注意[1, 2] 和 [2, 3] 在本题中算是重叠区间。在这里我对数组进行排序时用lambda表达式，相对实现Comparator接口较慢。代码如下： class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points,(i1,i2) -> (i1[1] - i2[1])); //使用Lambda表达式排序，按 int count = 1; int end = points[0][1]; for (int i = 0; i &lt; points.length; i++) { if (points[i][0] &lt;= end) { //注意这里是&lt;= continue; //属于重复区间，跳过，不用增加count次数 } end = points[i][1]; count++; } return count; } } 605. Can Place Flowers题目描述：假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 解题思路：贪婪地在从左到右遍历，在遇到的每个空地上放一朵花。获取上一个和下一个花坛，如果i位于首位或者末端，则前一个或者下一个被认为是0。 class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int length = flowerbed.length; int count = 0; for(int i = 0; i &lt; length &amp;&amp; count &lt; n; i++) { if (flowerbed[i] == 0) { int pre = (i == 0)? 0 : flowerbed[i-1]; //上一个花坛 int next = (i == length - 1)? 0 : flowerbed[i+1]; //下一个花坛 if(pre == 0 &amp;&amp; next == 0) { count++; flowerbed[i] = 1; } } } return count == n; } } 121. Best Time to Buy and Sell Stock题目描述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。解题思路：从头遍历数组，比较两个数之中谁比较大，这里注意卖出价格要大于买入价格，如果第一个值比第二个值大，由于贪心策略，要求最大收益，因此把最小价格赋值给第二个，如果第一个值比第二个小，则将当前价格 即 售出价格减去最小价格，则为最大利益，遍历完即可。 class Solution { public int maxProfit(int[] prices) { if (prices.length &lt;= 1) { return 0; } int temp = prices[0]; //最小价格 int max = 0; //最大收益 for (int i = 1; i &lt; prices.length; i++){ if (temp > prices[i]) { temp = prices[i]; } else { max = Math.max(max,prices[i] - temp); } } return max; } } 665. Non-decreasing Array题目描述：给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。 示例 1: 输入: [4,2,3] 输出: True 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: [4,2,1] 输出: False 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: n 的范围为 [1, 10,000]。解题思路：如果我们遇到一个失败的情况，即不是非递减数列，我们需要进行修正。可以通过以下两种方式之一进行更正： 使前一个数字小于或等于当前数字 使当前数字等于先前的数字当找到nums[i-1] &gt; nums[i]，采用方式一，通过改变nums[i-1]的值，这样不会影响了后续操作。还有，如果nums[i-2] &gt; nums[i]，采用方式二，改变nums[i]的值。class Solution { public boolean checkPossibility(int[] nums) { int length = nums.length; int count = 0; for (int i = 1; i &lt; length &amp;&amp; count &lt; 2; i++) { if (nums[i] >= nums[i - 1]) { continue; } count++; if (i - 2 >= 0 &amp;&amp; nums[i - 2] > nums[i]) { nums[i] = nums[i - 1]; //使当前数字等于先前的数字 } else { nums[i - 1] = nums[i]; //使前一个数字小于或等于当前数字 } } return count &lt;= 1; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/贪心/"}]},{"title":"LeetCode中常见的双指针题目","slug":"双指针","date":"2019-03-20T10:45:28.000Z","updated":"2019-09-10T09:45:37.599Z","comments":true,"path":"2019/03/20/shuang-zhi-zhen/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/20/shuang-zhi-zhen/","excerpt":"","text":"双指针：最近在刷leetcode，碰到了许多双指针类的题目，在这里总结下：所谓双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。 (注：这里的指针，并非专指c中指针的概念，而是指索引，游标或指针，可迭代对象等) 167 .两个Sum II - 输入数组已排序题目：定给一个已按照升序个结果排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1和index2，其中index1必须小于index2 。 说明： 返回的下标值（index1和index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入：数字= [ 2,7,11,15 ]，目标= 9 输出： [1,2] 解释： 2与7之和等于目标数9.因此index1 = 1，index2 = 2。解决方法： 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和sum == target，那么得到要求的结果; 如果sum&gt; target，移动较大的元素，使sum变小一些; 如果sum &lt;target，移动较小的元素，使sum变大一些。 public int[] twoSum(int[] numbers, int target) { int i = 0, j = numbers.length - 1; while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[]{i + 1, j + 1}; } else if (sum &lt; target) { i++; } else { j--; } } return null; } 141. 环形链表问题：给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 **示例 3：** 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 解决：使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇，好比于操场，如果一个用走，一个用跑，两个肯定相遇。 public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode l1 = head, l2 = head.next; while (l1 != null &amp;&amp; l2 != null &amp;&amp; l2.next != null) { if (l1 == l2) { return true; } l1 = l1.next; l2 = l2.next.next; } return false; } 345 .反转字符串中的元音字母问题：编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: &quot;hello&quot; 输出: &quot;holle&quot;示例 2: 输入: &quot;leetcode&quot; 输出: &quot;leotcede&quot;解决：使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。 private final static HashSet&lt;Character> vowels = new HashSet&lt;>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); public String reverseVowels(String s) { int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) { char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) { result[i++] = ci; } else if (!vowels.contains(cj)) { result[j--] = cj; } else { result[i++] = cj; result[j--] = ci; } } return new String(result); } 680. 验证回文字符串 Ⅱ问题：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: &quot;aba&quot; 输出: True示例 2: 输入: &quot;abca&quot; 输出: True 解释: 你可以删除c字符。注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解决：先写一个是否是回文的函数，然后再使用双指针，只要是回文数，头尾指针在遍历时肯定一样，如果不一样，可以去掉一个，增加i或减小j； public boolean validPalindrome(String s) { int i = -1, j = s.length(); while (++i &lt; --j) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j); } } return true; } private boolean isPalindrome(String s, int i, int j) { while (i &lt; j) { if (s.charAt(i++) != s.charAt(j--)) { return false; } } return true; } 88. 合并两个有序数组问题：给定两个有序整数数组 nums1 和 nums2*，将 *nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n*）来保存 *nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解决：使用双指针，需要从尾开始遍历，否则在nums1上归并得到的值会覆盖还未进行归并比较的值。 public void merge(int[] nums1, int m, int[] nums2, int n) { int index1 = m - 1, index2 = n - 1; int indexMerge = m + n - 1; while (index1 >= 0 || index2 >= 0) { if (index1 &lt; 0) { nums1[indexMerge--] = nums2[index2--]; } else if (index2 &lt; 0) { nums1[indexMerge--] = nums1[index1--]; } else if (nums1[index1] > nums2[index2]) { nums1[indexMerge--] = nums1[index1--]; } else { nums1[indexMerge--] = nums2[index2--]; } } } 633. 平方数之和问题：给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5示例2: 输入: 3 输出: False解决：一个从头遍历，一个从目标数字的开方往回遍历，如果目标数字大于实际数字，则i++;如果目标数字小于实际数字，则j–;如果目标数字等于实际数字，则找到了; public boolean judgeSquareSum(int c) { int i = 0, j = (int) Math.sqrt(c); while (i &lt;= j) { int powSum = i * i + j * j; if (powSum == c) { return true; } else if (powSum > c) { j--; } else { i++; } } return false; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/双指针/"}]},{"title":"LeetCode中的二分查找","slug":"二分查找","date":"2019-03-08T07:25:08.000Z","updated":"2019-09-10T09:40:34.940Z","comments":true,"path":"2019/03/08/er-fen-cha-zhao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/08/er-fen-cha-zhao/","excerpt":"","text":"二分查找最近在看算法第四版，其中有说到二分搜索，也就是二分查找，也在LeetCode上刷题，总结下 定义二分查找又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。 优缺点优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。 时间复杂度每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数 非递归方式： 由于辅助空间是常数级别的所以： 空间复杂度是O(1); 递归方式： 递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的： 空间复杂度：O(log2N ) 实现1.非递归代码(使用的比较多) public static int biSearch(int []array,int a){ int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi){ mid=(lo+hi)/2; if(array[mid]==a){ return mid+1; }else if(array[mid]&lt;a){ lo=mid+1; }else{ hi=mid-1; } } return -1; } 2.递归实现 public static int sort(int []array,int a,int lo,int hi){ if(lo&lt;=hi){ int mid=(lo+hi)/2; if(a==array[mid]){ return mid+1; } else if(a>array[mid]){ return sort(array,a,mid+1,hi); }else{ return sort(array,a,lo,mid-1); } } return -1; } 变种二分查找可以有很多变种，这里介绍两个变种，实现时要注意边界值和区间的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下： 循环条件为 l &lt; h h 的赋值表达式为 h = m 最后返回 l 而不是 -1 另外，在 h 的赋值表达式为 h = mid 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt; h) { //注意区间范围 int m = l + (h - l) / 2; if (nums[m] >= key) { h = m;//注意这里h的赋值 } else { l = m + 1; } } return l;//最后返回l } 在一个有重复元素的数组中查询元素最后一次出现的位置： public static int biSearch(int []array,int a){ int n=array.length; int low=0; int hi=n-1; int mid=0; while(low&lt;hi){ mid=(low+hi+1)/2; if(array[mid]&lt;=a){ low=mid; }else{ hi=mid-1; } } if(array[low]!=a){ return -1; }else{ return hi; } } Leetcode题目：744、Find Smallest Letter Greater Than Target (Easy) 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。Input:letters = [“c”, “f”, “j”]target = “a”Output: “c” Input:letters = [“c”, “f”, “j”]target = “c”Output: “f” Input:letters = [“c”, “f”, “j”]target = “d”Output: “f” Input:letters = [“c”, “f”, “j”]target = “g”Output: “j” Input:letters = [“c”, “f”, “j”]target = “j”Output: “c” Input:letters = [“c”, “f”, “j”]target = “k”Output: “c” 解题思路：典型的二分查找的正常实现，最后的时候通过三元运算符判断l跟n大小来决定输出l还是n，在二分查找中，中间值的计算用m = l + (h - l) / 2 比用 m = (l + h) / 2计算要好，可以防止l + h 出现加法溢出。 public char nextGreatestLetter(char[] letters, char target) { int n = letters.length; int l = 0, h = n - 1; while (l &lt;= h) { int m = l + (h - l) / 2; if (letters[m] &lt;= target) { l = m + 1; } else { h = m - 1; } } return l &lt; n ? letters[l] : letters[0]; } 34、Search for a Range (Medium) 题目描述：给定整数数组，数组按升序排序，找出给定目标值的起始位置和结束位置。 您的算法的运行时复杂性必须是O（log n）的顺序。 如果在数组中找不到目标，则返回[-1，-1]。 Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：本题基于二分查找的变种，考虑先写一个方法来判断target(可重复)在数组中出现的最左位置，再求求target+1出现的最左位置，然后进行比较即可。 class Solution { public int[] searchRange(int[] nums, int target) { int first = binarySearch(nums,target); int last = binarySearch(nums,target + 1) -1;//求target+1出现的最左位置 if(first ==nums.length || nums[first]!=target){ return new int []{-1,-1}; }else{ return new int[]{first,first>last?first:last};//当查找的目标数在最后一个时,first大于last } } //从数组中找出重复元素的最左位置 private static int binarySearch(int [] nums,int a){ int l = 0,h = nums.length;//注意这里h的取值，当数组中为[2,2]目标为2时，first和last都为0，所以这里h不能为nums.length-1; while(l &lt; h){ int min = l + (h - l) / 2; if(nums[min] >= a){ h = min; }else{ l = min + 1; } } return l; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BinarySearch/"}]}]}