{"meta":{"title":"森森的博客","subtitle":"乐观阳光，爱好运动","description":"20毕业，后台方向，还未上岸。","author":"ForeverSen","url":"http://github.com/ForeverSen/ForeverSen.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"二分查找","date":"2019-09-06T06:27:01.138Z","updated":"2019-09-06T15:06:00.283Z","comments":true,"path":"2019/09/06/二分查找/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/06/二分查找/","excerpt":"","text":"12345678910title: 二分查找date: 2019-05-26 14：43：05 categories: 人生 tags: [Java,LeetCode]# 引言最近在看算法第四版，其中有说到二分搜索，也就是二分查找，也在LeetCode上刷题，总结下&lt;!-- more --&gt;# 后记 二分查找最近在看算法第四版，其中有说到二分搜索，也就是二分查找，也在LeetCode上刷题，总结下 定义二分查找又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。 优缺点优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。 时间复杂度每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数 非递归方式： 由于辅助空间是常数级别的所以： 空间复杂度是O(1); 递归方式： 递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的： 空间复杂度：O(log2N ) 实现1.非递归代码(使用的比较多) 12345678910111213141516public static int biSearch(int []array,int a)&#123; int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi)&#123; mid=(lo+hi)/2; if(array[mid]==a)&#123; return mid+1; &#125;else if(array[mid]&lt;a)&#123; lo=mid+1; &#125;else&#123; hi=mid-1; &#125; &#125; return -1; &#125; 2.递归实现 1234567891011121314public static int sort(int []array,int a,int lo,int hi)&#123; if(lo&lt;=hi)&#123; int mid=(lo+hi)/2; if(a==array[mid])&#123; return mid+1; &#125; else if(a&gt;array[mid])&#123; return sort(array,a,mid+1,hi); &#125;else&#123; return sort(array,a,lo,mid-1); &#125; &#125; return -1; &#125; 变种二分查找可以有很多变种，这里介绍两个变种，实现时要注意边界值和区间的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下： 循环条件为 l &lt; h h 的赋值表达式为 h = m 最后返回 l 而不是 -1 另外，在 h 的赋值表达式为 h = mid 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。123456789101112public int binarySearch(int[] nums, int key) &#123; int l = 0, h = nums.length - 1; while (l &lt; h) &#123; //注意区间范围 int m = l + (h - l) / 2; if (nums[m] &gt;= key) &#123; h = m;//注意这里h的赋值 &#125; else &#123; l = m + 1; &#125; &#125; return l;//最后返回l&#125; 在一个有重复元素的数组中查询元素最后一次出现的位置： 123456789101112131415161718192021public static int biSearch(int []array,int a)&#123; int n=array.length; int low=0; int hi=n-1; int mid=0; while(low&lt;hi)&#123; mid=(low+hi+1)/2; if(array[mid]&lt;=a)&#123; low=mid; &#125;else&#123; hi=mid-1; &#125; &#125; if(array[low]!=a)&#123; return -1; &#125;else&#123; return hi; &#125; &#125; Leetcode题目：744、Find Smallest Letter Greater Than Target (Easy) 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。Input:letters = [“c”, “f”, “j”]target = “a”Output: “c” Input:letters = [“c”, “f”, “j”]target = “c”Output: “f” Input:letters = [“c”, “f”, “j”]target = “d”Output: “f” Input:letters = [“c”, “f”, “j”]target = “g”Output: “j” Input:letters = [“c”, “f”, “j”]target = “j”Output: “c” Input:letters = [“c”, “f”, “j”]target = “k”Output: “c” 解题思路：典型的二分查找的正常实现，最后的时候通过三元运算符判断l跟n大小来决定输出l还是n，在二分查找中，中间值的计算用m = l + (h - l) / 2 比用 m = (l + h) / 2计算要好，可以防止l + h 出现加法溢出。 12345678910111213public char nextGreatestLetter(char[] letters, char target) &#123; int n = letters.length; int l = 0, h = n - 1; while (l &lt;= h) &#123; int m = l + (h - l) / 2; if (letters[m] &lt;= target) &#123; l = m + 1; &#125; else &#123; h = m - 1; &#125; &#125; return l &lt; n ? letters[l] : letters[0];&#125; 34、Search for a Range (Medium) 题目描述：给定整数数组，数组按升序排序，找出给定目标值的起始位置和结束位置。 您的算法的运行时复杂性必须是O（log n）的顺序。 如果在数组中找不到目标，则返回[-1，-1]。 Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：本题基于二分查找的变种，考虑先写一个方法来判断target(可重复)在数组中出现的最左位置，再求求target+1出现的最左位置，然后进行比较即可。 123456789101112131415161718192021222324class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int first = binarySearch(nums,target); int last = binarySearch(nums,target + 1) -1;//求target+1出现的最左位置 if(first ==nums.length || nums[first]!=target)&#123; return new int []&#123;-1,-1&#125;; &#125;else&#123; return new int[]&#123;first,first&gt;last?first:last&#125;;//当查找的目标数在最后一个时,first大于last &#125; &#125; //从数组中找出重复元素的最左位置 private static int binarySearch(int [] nums,int a)&#123; int l = 0,h = nums.length;//注意这里h的取值，当数组中为[2,2]目标为2时，first和last都为0，所以这里h不能为nums.length-1; while(l &lt; h)&#123; int min = l + (h - l) / 2; if(nums[min] &gt;= a)&#123; h = min; &#125;else&#123; l = min + 1; &#125; &#125; return l; &#125;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-06T05:34:41.592Z","updated":"2019-09-06T05:34:41.592Z","comments":true,"path":"2019/09/06/hello-world/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}