{"meta":{"title":"森森的博客","subtitle":"正在更新...","description":"I hear and I forget. I see and I remember. I do and I understand.","author":"ForeverSen","url":"http://github.com/ForeverSen/ForeverSen.github.io","root":"/"},"pages":[{"title":"about","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:56:23.417Z","comments":true,"path":"about/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-01T10:23:38.000Z","updated":"2019-09-10T04:28:54.241Z","comments":true,"path":"tags/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-01T09:25:30.000Z","updated":"2019-09-10T04:27:12.433Z","comments":true,"path":"categories/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-01T13:25:30.000Z","updated":"2019-09-10T04:28:42.208Z","comments":true,"path":"friends/index.html","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"常见排序代码总结(Java语言实现)","slug":"常见排序代码总结(Java语言实现)","date":"2019-09-10T10:25:08.000Z","updated":"2019-09-30T14:33:44.251Z","comments":true,"path":"2019/09/10/chang-jian-pai-xu-dai-ma-zong-jie-java-yu-yan-shi-xian/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/10/chang-jian-pai-xu-dai-ma-zong-jie-java-yu-yan-shi-xian/","excerpt":"","text":"最近继续重温下数据结构中的排序，其实之前在三月份得时候也有复习过了一遍，其实前人已经总结得很不错了，这次重新再过一遍，重新手写一下代码：以下代码的swap代码都是基于如下代码：使用位运算，更快更有逼格~ private static swap(int [] arr, int i, int j) { arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; } 冒泡排序： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。public static void bubbleSort (int [] array) { for (int i = array.length - 1; i > 0; i--) { boolean flag = true; for (int j = 0; j &lt; i; j++) { if (array[j] > array[j+1]) { swap(arr,j,j+1); flag = false; } } if (flag) break; } } 选择排序： 在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列； 再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。public void selectSort(int [] arr) { for (int i = 0; i &lt; arr.length; i++) { int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) { minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; } swap(arr,i,minIdex); } } 插入排序 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）public static void insertSort(int [] arr) { for (int i = 1; i &lt; arr.length; i++) { int tmp = arr[i]; for (int j = i - 1; j >= 0 &amp;&amp; tmp &lt; arr[j]; j--) { arr[j+1] = arr[j]; } arr[j+1] = tmp; } } 希尔排序希尔排序是更高效的插入排序，它把数组分成几块，每一块进行一个插入排序；而分块的依据在于增量的选择分好块之后，从gap开始到n，每一组和自己组内的元素进行插入排序；这里以gap为2为例。 public void shellSort(int [] arr) { //增量序列,这里为2 for (gap = arr.length; gap > 0; gap /= 2){ //从数组第gap个元素开始 for (int i = gap; i &lt; gap; i++) { int tmp = arr[i],j; //每个元素与自己组内的数据进行直接插入排序 for (j = i - gap; j >= 0 &amp;&amp; tmp &lt; arr[j]; j-= gap) { arr[j+gap] = arr[j]; } arr[j] = tmp; } } } 快速排序原始快速排序： static void quickSort(int [] arr) { if (arr == null || arr.length &lt;= 1){ return; } quick(arr,0,arr.length - 1); } static void quick(int [] arr, int L, int R){ if (L >= R) return; int p = partition(arr,L,R); quick(arr,L,p - 1); quick(arr,p + 1,R); } // 返回pivot，使得左边都小于切分数，右边都大于切分数 static int partition(int [] arr, int L, int R) { //获取第一个为切分元素 int num = arr[L]; int pivot = L; for (int i = L + 1; i &lt;= R; i++) { if (arr[i] &lt; num) { swap(arr,i,++pivot); } } swap(arr,L,pivot); return pivot; } 这种情况的快速排序有两种弊端，一是每次选第一个为切分元素，如果是最小值或者最大值，这样比较不好，还有就是说上面那种在partition中的时候只有一个指针，如果排序的数组重复元素很多的情况下，还是会使得划分极其的不均匀。 改进版快速排序（推荐）：(注意区分与上面的不同) 写一个切分方法partition 然后每一次切分完成后递归调用quick方法，缩小区间。static void quickSort(int [] arr) { if (arr.length &lt;= 1) return; quick(arr,0,arr.length - 1); } static void quick(int [] arr,int L, int R) { if (L >= R) return; // 随机选取 swap(arr,L,L+(int)(Math.random()*(R - L + 1))); int p = partition(arr,L,R); quick(arr, L, p - 1); quick(arr, p + 1, R); } static int partition(int [] arr,int L, int R) { int num = arr[L]; //两个节点 int less = L + 1, more = R; while (true) { while (less &lt; R &amp;&amp; arr[less] &lt; num) less++; while (more > L) &amp;&amp; arr[more] > num) more--; if (less >= more) break; swap(arr, less++, more--); } //最后跟L交换的是more swap(arr,L,more); return more; } 堆排序堆排序的过程是一个反复调整堆的过程： 利用数组建立一个大根堆（父亲比孩子的值大）； 把堆顶元素和堆尾元素互换； 把堆（无序区）的尺寸缩小1，并下沉； 重复步骤，直到堆的大小为1； private void HeapSort(int [] arr) { int N = arr.length - 1; for (int i = N / 2; i >= 1; i--) { sink(arr,i,N); } while (N > 1){ swap(arr,1,N--); sink(arr,1,N); } } //下沉 private void sink(int [] arr,int k,int N) { while (2 * k &lt;= N) { int j = 2 * k; //与两个子节点中最大的节点进行交换 if (j &lt; N &amp;&amp; arr[j] &lt; arr[j+1]) j++; if (arr[k] >= arr[j]) { break; } // 下沉 swap(arr,k,j) k = j; } } 归并排序归并排序采用分治的思想，这里用递归实现，首先先递归拆分子序列，然后将两个已经有序的子序列合并成一个有序序列，需要准备一个额外的数组(temp)，使其大小为原来数组长度，该空间用来存放合并后的序列。关键代码是 merge那一部分 private void mergeSort(int [] arr) { //创建临时数组 int temp[] = new int[arr.length]; sort(arr,0,arr.length - 1,temp); } private void sort(int []arr,int l,int r,int [] temp) { if (l &lt; r){ int mid = (l + r) / 2; //递归，左边归并排序，使得左子序列有序 sort(arr,l,mid,temp); //右边归并排序，使得右子序列有序 sort(arr,mid+1,r,temp); //将两个有序子数组合并操作 merge(arr,l,mid,r,temp); } } //关键代码 private void merge(int []arr,int l,int mid,int r,int [] temp) { int i = l; int j = mid + 1; // 临时变量 int t = 0; while (i &lt;= mid &amp;&amp; j&lt;= r) { if (arr[i] &lt;= arr[j]) { temp[t++] = arr[i++]; } else { temp[t++] = arr[j++]; } } //将左边剩余元素填充进temp中 while (i &lt;= mid) { temp[t++] = arr[i++]; } //将右边剩余元素填充进temp中 while (j &lt;= r) { temp[t++] = arr[j++]; } //将temp中的元素全部拷贝到原数组中 t = 0; while (l &lt;= r) { arr[l++] = temp[t++]; } } 这里七个排序算是比较常见的排序方式了，要好好熟悉，尤其是快排、堆排，平时刷题偶尔也可以用到，比如说快排的partition可以用来求无序数组中的第K大的数字，堆排序用来做优先队列可以用来求最大值最小值等等。end~","categories":[{"name":"Java","slug":"Java","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/Java/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/排序/"}]},{"title":"剑指Offer（30-39Java语言描述）","slug":"剑指Offer（30-39)","date":"2019-09-06T10:25:08.000Z","updated":"2019-09-30T14:32:46.566Z","comments":true,"path":"2019/09/06/jian-zhi-offer-30-39/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/06/jian-zhi-offer-30-39/","excerpt":"","text":"emm最近这段时间回学校复习了，时间相对也比较充裕，继续向前，保持激情 ~~顺便附带亮剑经典语录 四：什么他他娘的精锐，老子打的就是精锐！什么武士道,老子打的就是武士道! 30. 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路：借用一个辅助的栈，遍历压栈顺序，然后判断栈顶元素是不是出栈顺序的第一个元素，等到最后如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 import java.util.Stack; public class Solution { public boolean IsPopOrder(int [] pushA,int [] popA) { Stack&lt;Integer> stack = new Stack&lt;>(); int index = 0; //index 为弹出序列下标 for (int i = 0; i &lt; pushA.length; i++) { stack.push(pushA[i]); while (!stack.isEmpty() &amp;&amp; stack.peek() == popA[index]) { stack.pop(); index++; } } return stack.isEmpty(); } } 31. 从上往下打印二叉树题目描述：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路：第一种 ：二叉树的层次遍历，类似BFS，使用一个队列来解决。 import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&lt;Integer> PrintFromTopToBottom(TreeNode root) { ArrayList&lt;Integer> list = new ArrayList&lt;>(); Queue&lt;TreeNode> queue = new LinkedList&lt;>(); queue.add(root); while (!queue.isEmpty()){ int length = queue.size(); while (length-- > 0) { TreeNode t = queue.poll(); if (t == null) continue; list.add(t.val); queue.offer(t.left); queue.offer(t.right); } } return list; } } 第二种：递归按顺序添加。 import java.util.ArrayList; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { private ArrayList&lt;Integer> list = new ArrayList&lt;>(); public ArrayList&lt;Integer> PrintFromTopToBottom(TreeNode root) { if (root != null) { list.add(root.val); } print(root); return list; } private void print(TreeNode node) { if (node != null) { if (node.left != null) { list.add(node.left.val); } if (node.right != null) { list.add(node.right.val); } print(node.left); print(node.right); } } } 32. 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路：这道题其实跟上面一道很类似，可以用BFS思想，只是要注意 同一层的时候是在第二个while循环那边添加 小list。 import java.util.*; /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { ArrayList&lt;ArrayList&lt;Integer> > Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer>> BigArrayList = new ArrayList&lt;>(); Queue&lt;TreeNode> queue = new LinkedList&lt;>(); queue.offer(pRoot); while (!queue.isEmpty()) { int cnt = queue.size(); ArrayList&lt;Integer> list = new ArrayList&lt;>(); //同一层 while (cnt-- > 0) { TreeNode t = queue.poll(); if (t != null) { list.add(t.val); if (t.left != null) { queue.offer(t.left); } if (t.right != null) { queue.offer(t.right); } } } if (list.size() > 0) { BigArrayList.add(list); } } return BigArrayList; } } 33. 按之字形顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路：第一种：依旧是层次遍历，这里我们还是跟上题一样的方法，不过当遇到偶数层是，我们反转链表，再进行添加，牛客的评论中说这样的时间复杂度太大了，可以考虑使用两个栈来实现，下面第二种就是用两个栈来实现。 import java.util.*; /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&lt;ArrayList&lt;Integer> > Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer> > bigList = new ArrayList&lt;>(); Queue&lt;TreeNode> queue = new LinkedList&lt;>(); int len = 0; if (pRoot != null) { queue.offer(pRoot); len++; //层数 } while (!queue.isEmpty()) { ArrayList&lt;Integer> list = new ArrayList&lt;>(); int cnt = queue.size(); while (cnt-- > 0) { TreeNode t = queue.poll(); if (t == null) continue; list.add(t.val); queue.offer(t.left); queue.offer(t.right); } if (list.size() > 0) { if (len % 2 == 0) { Collections.reverse(list); // 偶数层反转 } bigList.add(list); len++; } } return bigList; } } 第二种：使用两个栈，利用栈后进先出的特点。leftStack 存储奇数层，从左到右。当遇到奇数层时在rightStack中添加元素。rightStack存储偶数层，从右到左。当遇到偶数层时在leftStack 中添加元素。并注意顺序 import java.util.*; /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&lt;ArrayList&lt;Integer> > Print(TreeNode pRoot) { ArrayList&lt;ArrayList&lt;Integer> > bigList = new ArrayList&lt;>(); Stack&lt;TreeNode> leftStack = new Stack&lt;>(); Stack&lt;TreeNode> rightStack = new Stack&lt;>(); int len = 1; if (pRoot != null) { leftStack.push(pRoot); } while (!leftStack.isEmpty() || !rightStack.isEmpty()) { // 从左到右 if (len % 2 != 0) { ArrayList&lt;Integer> list = new ArrayList&lt;>(); while (!leftStack.isEmpty()) { TreeNode t = leftStack.pop(); if (t == null) continue; list.add(t.val); rightStack.push(t.left); ////利用栈的特性可以实现下一层从右到左 rightStack.push(t.right); } if (list.size() > 0) { bigList.add(list); len++; } } // 从右到左 else { ArrayList&lt;Integer> list = new ArrayList&lt;>(); while (!rightStack.isEmpty()) { TreeNode t = rightStack.pop(); if (t == null) continue; list.add(t.val); leftStack.push(t.right); //利用栈的特性可以实现下一层从左到右 leftStack.push(t.left); } if (list.size() > 0) { bigList.add(list); len++; } } } return bigList; } } 34. 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路：利用二叉树后序遍历的性质，后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则。 public class Solution { public boolean VerifySquenceOfBST(int [] sequence) { if (sequence == null || sequence.length == 0) { return false; } return verify(sequence,0,sequence.length - 1); } private boolean verify(int [] arr, int first, int last) { if (first >= last) return true; //递归出口 int index = first; while (index &lt; last &amp;&amp; arr[index] &lt;= arr[last]) { index++; //找到二叉树顶点 } for (int i = index; i &lt; last; i++) { if (arr[i] &lt; arr[last]) { return false; } } return verify(arr,first,index - 1) &amp;&amp; verify(arr,index,last - 1); } } 35. 二叉树中和为某一值的路径题目描述输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路：这里使用深度优先遍历，需要注意的是如果递归到叶子节点如果还没有找到路径，就要回退到父节点继续寻找，然后最终需要对链表进行排序，因为递归不能确保第一个就是最长的链表。不过好像牛客的测试用例没有排序也能ac。。。 import java.util.*; /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { public ArrayList&lt;ArrayList&lt;Integer>> FindPath(TreeNode root,int target) { ArrayList&lt;ArrayList&lt;Integer>> bigList = new ArrayList&lt;>(); ArrayList&lt;Integer> list = new ArrayList&lt;>(); dfs(root,target,bigList,list); //需要对bigList里面的list进行排序 Collections.sort(bigList,new Comparator&lt;ArrayList&lt;Integer>>(){ public int compare(ArrayList&lt;Integer> o1, ArrayList&lt;Integer> o2){ return o2.size() - o1.size(); } }); return bigList; } private void dfs(TreeNode root,int target,ArrayList&lt;ArrayList&lt;Integer>> bigList,ArrayList&lt;Integer> list){ if (root == null) return; list.add(root.val); target -= root.val; if (target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) { bigList.add(new ArrayList&lt;Integer>(list)); //这里需要重新new链表，这样大链表才会指向不同链表 } dfs(root.left,target,bigList,list); dfs(root.right,target,bigList,list); list.remove(list.size() - 1); //到叶子节点如果还没有找到路径，就要回退到父节点继续寻找 } } 36. 复杂链表的复制题目描述输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路：1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;3、拆分链表，将链表拆分为原链表和复制后的链表 /* public class RandomListNode { int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) { this.label = label; } } */ public class Solution { public RandomListNode Clone(RandomListNode pHead){ if (pHead == null) return null; // 插入新节点，但是不赋随即方向 RandomListNode cur = pHead; while (cur != null) { RandomListNode tmp = new RandomListNode(cur.label); tmp.next = cur.next; cur.next = tmp; cur = tmp.next; } //重新引用到头 cur = pHead; // 为兄弟节点赋值 while (cur != null) { RandomListNode tmp = cur.next; if (cur.random != null) { tmp.random = cur.random.next; } cur = tmp.next; } // 拆分 cur = pHead; RandomListNode res = pHead.next; while (cur.next != null) { RandomListNode next = cur.next; cur.next = next.next; cur = next; } return res; } } 37. 二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路：结合画图比较好理解，使用递归二叉树的中序遍历，用pLast用于记录当前链表的末尾节点，然后将这些小段链表一个接一个地加到末尾。 /** public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { private TreeNode pLast = null; public TreeNode Convert(TreeNode pRootOfTree) { if (pRootOfTree == null) return null; //如果左子树为空，根节点为双向链表的头节点 TreeNode head = Convert(pRootOfTree.left); if (head == null) { head = pRootOfTree; } //将小段链表一个接一个地加到末尾 pRootOfTree.left = pLast; if (pLast != null) { pLast.right = pRootOfTree; } pLast = pRootOfTree; Convert(pRootOfTree.right); return head; } } 38. 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 解题思路：这里使用前序遍历序列来序列化二叉树，当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。结点之间的数值用逗号隔开。全局变量index用来反序化的时候被分割数组的下标。 import java.lang.*; /* public class TreeNode { int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) { this.val = val; } } */ public class Solution { private int index = -1; //反序列化时下标 String Serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); if (root == null) { sb.append(\"#,\"); return sb.toString(); } sb.append(root.val + \",\"); sb.append(Serialize(root.left)); sb.append(Serialize(root.right)); return sb.toString(); } TreeNode Deserialize(String str) { index++; String [] strArr = str.split(\",\"); TreeNode node = null; if (!strArr[index].equals(\"#\")) { node = new TreeNode(Integer.parseInt(strArr[index])); node.left = Deserialize(str); node.right = Deserialize(str); } return node; } } 39. 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路：固定第一个字符，递归取得首位后面的各种字符串组合，再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合，递归的出口，就是只剩一个字符的时候。 import java.util.ArrayList; import java.util.Collections; public class Solution { public ArrayList&lt;String> Permutation(String str) { ArrayList&lt;String> resList = new ArrayList&lt;>(); if (str.length() == 0) return resList; backtracking(str.toCharArray(),resList,0); Collections.sort(resList); return resList; } private void backtracking(char[] arr,ArrayList&lt;String> list,int i) { if (i == arr.length - 1){ if (!list.contains(new String(arr))) { list.add(new String(arr)); return; } } else { for (int j = i; j &lt; arr.length; j++) { swap(arr,i,j); backtracking(arr,list,i+1); //字符数组的顺序回到进入递归前的状态，这样才不会影响外部的遍历顺序。 swap(arr,i,j); } } } private void swap(char[]arr,int i, int j) { char t = arr[i]; arr[i] = arr[j]; arr[j] = t; } }","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/剑指Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/剑指Offer/"}]},{"title":"Java 并发编程复习（二）","slug":"Java 并发编程复习（二）","date":"2019-09-02T10:25:08.000Z","updated":"2019-09-30T14:31:37.621Z","comments":true,"path":"2019/09/02/java-bing-fa-bian-cheng-fu-xi-er/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/09/02/java-bing-fa-bian-cheng-fu-xi-er/","excerpt":"","text":"既上篇复习一后，继续再来了解 J.U.C 下包的相关类 1. JUC 包中的原子类是哪4类?参考synchronized采用的是悲观锁策略来达到线程安全的目的，这并不是特别高效的一种解决方案在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。 基本类型 AtomicBoolean：以原子更新的方式更新boolean； AtomicInteger：以原子更新的方式更新Integer; AtomicLong：以原子更新的方式更新Long； AtomicInteger：（可以阅读下相关源码）atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是采用乐观锁策略，因此，这种数据更新的方法也具有高效性。 数组类型 AtomicIntegerArray：原子更新整型数组中的元素； AtomicLongArray：原子更新长整型数组中的元素； AtomicReferenceArray：原子更新引用类型数组中的元素 引用类型 AtomicReference：原子更新引用类型； AtomicReferenceFieldUpdater：原子更新引用类型里的字段； AtomicMarkableReference：原子更新带有标记位的引用类型； 字段类型 AtomicIntegeFieldUpdater：原子更新整型字段类； AtomicLongFieldUpdater：原子更新长整型字段类； AtomicStampedReference：原子更新引用类型，这种更新方式会带有版本号。在更新的时候会带有版本号，是为了解决CAS的ABA问题； 2. 什么是AQS？AQS原理是什么？可参考AQS详解（JavaGuide) （基于队列同步器AbstractQueueSychronier（简称同步器） ，在说队列同步器时，我提到了两大点：队列同步器维护一个同步队列，是双向链表，同时也维护一个同步状态state；还说到它的方法分类：独占式锁和分享式锁。 说说独占式锁的实现：我说到了最重要的一点就是加入同步队列的时结点需要自旋查看它的前一个结点是否获取锁，如果获取的话，它应该尝试获取锁（tryAcquire）） AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 原理：同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量state来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState,setState以及compareAndSetState这三个方法。AQS底层使用了模板方法模式 AQS定义两种资源共享方式: Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。 Semaphore(信号量)： 允许多个线程同时访问synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch （倒计时器，一个线程等待）： 用来控制一个或者多个线程等待多个线程，直到其他线程的操作执行完后再执行。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 CyclicBarrier（循环栅栏，一组线程等待）：用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CountDownLatch与CyclicBarrier的比较： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行； CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能； CountDownLatch是不能复用的，而CyclicLatch是可以复用的。 读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了,相对ReentrantLock。 3. ConcurrentHashMap是什么，实现？ConcurrentHashMap就是线程安全的map，其中利用了锁分段的思想提高了并发度。在JDK 1.7版本中： ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。 Segment实现了ReentrantLock，所以Segment是一种可重入锁，扮演锁的角色.HashEntry用于存储键值对数据。 在JDK 1.8版本中： 取消了Segment分段锁，采用CAS和synchronized来保证并发安全。 数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树.Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O（N））转换为红黑树（寻址时间复杂度为O（log（N））） ConcurrentHashMap和Hashtable的区别 1.7版本与1.8版本的ConcurrentHashMap的实现对比 4. CopyOnWriteArrayList是什么，作用？实现？CopyOnWriteArrayList 读取是完全不用加锁的，并且更厉害的是：写入也不会阻塞读取操作。只有写入和写入之间需要进行同步等待。这样一来，读操作的性能就会大幅度提升。 CopyOnWriteArrayList 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。 5. ConcurrentLinkedQueue 是什么？Java提供的线程安全的 Queue 可以分为阻塞队列和非阻塞队列,ConcurrentLinkedQueue 非阻塞队列的一种实现，阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现。ConcurrentLinkedQueue 主要使用 CAS 非阻塞算法来实现线程安全。ConcurrentLinkedQueue 适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的ConcurrentLinkedQueue来替代。 6. BlockingQueue阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。 相关几个实现类： ArrayBlockingQueue：数组实现的有界阻塞队列，该队列命令元素FIFO（先进先出） LinkedBlockingQueue：LinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性与ArrayBlockingQueue 相比起来具有更高的吞吐量。 PriorityBlockingQueue：一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 compareTo() 方法来指定元素排序规则，或者初始化时通过构造器参数 Comparator 来指定排序规则。 7. JMM 是什么，三大特性？Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。三大特性： 原子性：原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败 可见性：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改 有序性：为了性能优化，编译器和处理器会进行指令重排序；也就是说java有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。 指令重排：在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 参考文献： 《Java并发编程的艺术》 Java 并发专题27篇 CyC2018/Java并发 JavaGuide/Java并发","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/Java并发/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/并发编程/"}]},{"title":"剑指Offer（20-29Java语言描述）","slug":"剑指Offer（20-29)","date":"2019-08-28T10:25:08.000Z","updated":"2019-09-30T14:31:05.196Z","comments":true,"path":"2019/08/28/jian-zhi-offer-20-29/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/08/28/jian-zhi-offer-20-29/","excerpt":"","text":"继续向前，很快九月份就到了！第三波。。亮剑语录：“天下没有打不破的包围圈，对我们独立团来说，老子就不把它当成是突围战，当成什么？当成进攻。向我们正面的敌人发起进攻，记住，全团哪怕只剩一个人，也要继续进攻，死也要死在冲锋的路上。” 20.链表中倒数第 K 个结点题目描述输入一个链表，输出该链表中倒数第k个结点。解题思路： 这题在leetcode中也有出现，之前也做过，我的思路是首先遍历一次求链表的长度，然后再重新遍历到 倒数第k个结点，这样的话需要遍历2次。 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } }*/ public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if (head == null ) return null; int length = 1; ListNode temp = head; while (temp.next != null) { length++; temp = temp.next; } if (k > length || k &lt;= 0) return null; for (int i = 0; i &lt; length - k ; i++) { head = head.next; } return head; } } 也可以只做到遍历一次，就是让first 指针先走k步，然后让first指针和second指针一起走，知道first指针指向为空。需要注意的就是k的取值不能大于链表长度，这里要判断。 public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if (head == null) return null; ListNode first = head; ListNode second = head; if (k &lt;= 0) return null; for (int i = 0; i &lt; k; i++) { if (first == null) return null; first = first.next; } while (first != null) { first = first.next; second = second.next; } return second; } } 21. 链表中环的入口结点题目描述：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。解题思路：利用双指针法，一个走一步slow，一个走两步fast，然后当两者首次相遇时，利用数学逻辑可以推断出，此时将fast 设置为头节点，然后两者再次同时前进一步，如果再次相遇，那么这个点就是环的入口节点。 public class Solution { public ListNode EntryNodeOfLoop(ListNode pHead){ if (pHead == null || pHead.next == null) return null; ListNode fast = pHead; ListNode slow = pHead; while (fast.next.next != null &amp;&amp; slow.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } fast = pHead; while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } 22. 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。解题思路：使用头插法，将所有节点的next指向前一个节点 public class Solution { public ListNode ReverseList(ListNode head) { ListNode newList = new ListNode(-1); while (head != null) { ListNode next = head.next; head.next = newList.next;////将当前节点对下一个节点的引用指向前一个节点 newList.next = head;////将前一个节点指向当前节点 head = next; } return newList.next; } } 也可以使用递归： public class Solution { public ListNode ReverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode next = head.next; head.next = null; ListNode newHead = ReverseList(next); next.next = head; return newHead; } } 24. 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则解题思路：迭代两个链表，然后进行比较，哪一个比较小就在前面，需要注意的就是需要有个临时节点newList public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; ListNode head = new ListNode(0); ListNode newList = head; while (list1 != null &amp;&amp; list2 != null) { if (list1.val &lt; list2.val) { newList.next = list1; list1 = list1.next; } else { newList.next = list2; list2 = list2.next; } newList = newList.next; if (list1 == null) { newList.next = list2; } if (list2 == null) { newList.next = list1; } } return head.next; } } 也可以使用递归，更加简洁方便。。 public class Solution { public ListNode Merge(ListNode list1,ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val &lt; list2.val) { list1.next = Merge(list1.next,list2); return list1; } else { list2.next = Merge(list1,list2.next); return list2; } } } 25. 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）解题思路：递归思想，当出现树总要考虑递归，方便，这里isSame为判断两个节点是否相同，这里需要注意t2为空时是一种子结构，应返回true。 public class Solution { public boolean HasSubtree(TreeNode root1,TreeNode root2) { if (root1 == null || root2 == null) return false; return isSame(root1,root2) || HasSubtree(root1.left,root2) || HasSubtree(root1.right,root2); } private boolean isSame(TreeNode t1,TreeNode t2) { if (t2 == null) return true; //t2为空时为子结构，返回真 if (t1 == null) return false; //t1为空时直接返回false if (t1.val != t2.val) return false; return isSame(t1.left,t2.left) &amp;&amp; isSame(t1.right,t2.right); } } 26. 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 二叉树的镜像定义：源二叉树 8 / \\ 6 10 / \\ / \\ 5 7 9 11 镜像二叉树 8 / \\ 10 6 / \\ / \\ 11 9 7 5 解题思路：同样考虑使用递归来解决问题，中间部分为交换左右节点的代码，后面递归。 public class Solution { public void Mirror(TreeNode root) { if (root == null) return; TreeNode temp = null; temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); } } 27. 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。二叉树的镜像可以参考26题 解题思路：重载方法isSymmetrical，然后判断，递归。 public class Solution { boolean isSymmetrical(TreeNode pRoot){ if (pRoot == null) return true; return isSymmetrical(pRoot.left,pRoot.right); } boolean isSymmetrical(TreeNode t1, TreeNode t2) { if (t1 == null &amp;&amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return isSymmetrical(t1.left,t2.right) &amp;&amp; isSymmetrical(t1.right,t2.left); } } 28. 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路：分别从四个方向开始遍历放进链表中 import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer> printMatrix(int [][] matrix) { int m1 = 0; int m2 = matrix.length - 1; int n1 = 0; int n2 = matrix[0].length - 1; ArrayList&lt;Integer> list = new ArrayList&lt;>(); while (m1 &lt;= m2 &amp;&amp; n1 &lt;= n2) { // 从左到右 for (int i = m1; i &lt;= n2; i++) { list.add(matrix[m1][i]); } // 从上到下 for (int i = m1+1; i &lt;= m2; i++) { list.add(matrix[i][n2]); } //从右到左 if (m1 != m2) { for (int i = n2 - 1; i >= n1; i--){ list.add(matrix[m2][i]); } } // 从下到上 if (n1 != n2) { for (int i = m2 - 1; i > m1; i--) list.add(matrix[i][n1]); } m1++; m2--; n1++; n2--; } return list; } } 29. 包含min函数的栈题目描述：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。解题思路：使用一个最小元素栈， 每次压栈操作时, 如果压栈元素比当前最小元素更小, 就把这个元素压入最小元素栈, 原本的最小元素就成了次小元素. 同理, 弹栈时, 如果弹出的元素和最小元素栈的栈顶元素相等, 就把最小元素的栈顶弹出. import java.util.Stack; public class Solution { public Stack&lt;Integer> stack = new Stack&lt;>(); public Stack&lt;Integer> minStack = new Stack&lt;>(); public void push(int node) { stack.push(node); if (minStack.isEmpty()) { minStack.push(node); } else if (node &lt;= minStack.peek()){ minStack.push(node); } } public void pop() { if (minStack.peek() == stack.pop()) { minStack.pop(); } } public int top() { return stack.peek(); } public int min() { return minStack.peek(); } } 这周回学校报到了，这十道刷的有点久，要加快进度了呀。。","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/剑指Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/剑指Offer/"}]},{"title":"剑指Offer（10-19Java语言描述）","slug":"剑指Offer（10-19)","date":"2019-08-19T10:25:08.000Z","updated":"2019-09-30T14:29:57.361Z","comments":true,"path":"2019/08/19/jian-zhi-offer-10-19/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/08/19/jian-zhi-offer-10-19/","excerpt":"","text":"继续刷剑指，提高效率，第二波。。 亮剑经典语录 二：逢敌必亮剑，倒在对手的剑下不丢脸，丢脸的是不敢亮剑。 10. 斐波那契数列题目描述：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39解题思路：斐波那契数列，经典递归说明例子，不过递归的话从上到下递归，而且有很多重复项，这里应当使用动态规划来解决，时间复杂度O(n)，空间复杂度O(1）。 public class Solution { public int Fibonacci(int n) { if (n &lt;= 1) return n; int pre1 = 1; int pre2 = 0; for (int i = 2; i &lt;= n; i++) { int cur = pre1 + pre2; pre2 = pre1; pre1 = cur; } return pre1; } } 11.矩阵覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？解题思路：其实代码跟第十题一样，只是换个思路，关键理解涂掉最后一级矩阵的时候，可以选择使用横向完成，也可以使用竖向完成，而使用横向完成是f(n - 1),使用竖向完成是f(n - 2) public class Solution { public int RectCover(int target) { if (target &lt;= 2) return target; int pre1 = 2, pre2 = 1; for (int i = 3; i &lt;= target; i++) { int cur = pre1 + pre2; pre2 = pre1; pre1 = cur; } return pre1; } } 12.跳台阶题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。解题思路：其实还是跟斐波那契数列一样，就是当target = 1 时，只有一种，target = 2时有两种，当target = n时 ：F(n) = F(n - 1) + F(n - 2) public class Solution { public int JumpFloor(int target) { if (target &lt; 2) return target; int pre1 = 2, pre2 = 1; for (int i = 2; i &lt; target; i++) { int cur = pre1 + pre2; pre2 = pre1; pre1 = cur; } return pre1; } } 13.变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。解题思路：思路跟12题差不多，只不过这题在求的过程中把值都暂时放在数组里，最后求的时候遍历数据这些求好的对应的阶级种数之和即为新的下级阶梯种数。需要注意每一个dp[i]都要++，因为都可以直接从第0阶一步跳过去。 public class Solution { public int JumpFloorII(int target) { if (target &lt; 2) return target; int dp[] = new int[target]; dp[0] = 1; dp[1] = 2; for (int i = 2;i&lt; target; i++) { for (int j = 0; j &lt; i; j++) { dp[i] += dp[j]; } dp[i]++; } return dp[target - 1]; } } 14.旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。解题思路：遍历一遍，因为两边是非递减的，所以如果下一个数字比上一个小，那么这个就是最小的。如果没找的，那么第一个就是最小的。 import java.util.ArrayList; public class Solution { public int minNumberInRotateArray(int [] array) { if (array.length == 0) return 0; for (int i = 0; i &lt; array.length; i++) { if (array[i] > array[i+1]) { return array[i+1]; } } return array[0]; } } 还可以皮一点：直接Array.sort(); import java.util.Arrays; public class Solution { public int minNumberInRotateArray(int [] array) { if (array.length == 0) return 0; Arrays.sort(array); return array[0]; } } 15.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bccced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路：使用深度优先遍历，暴力搜索全部每一个字符的所有可能，这里根据题意，要进行回溯，在一次搜索结束时需要进行回溯，将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。首先，题目给我们的是一维数组，我们需要将他转变为矩阵，也就是二维数组，然后再用深度搜索dfs解决， public class Solution { private static int[][] direction = {{0,1},{0,-1},{1,0},{-1,0}}; public boolean hasPath(char[] matrix, int rows, int cols, char[] str){ char m [][] = new char[rows][cols]; //将一维矩阵转成二维矩阵 for (int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) { m[i][j] = matrix[i*cols+j]; } } boolean[][] visited = new boolean[rows][cols]; //记录每个点是否被访问 for (int i = 0; i &lt; rows; i++) { for (int j = 0; j &lt; cols; j++) { if (str[0] == m[i][j] &amp;&amp; dfs(m,i,j,str,visited,0)){ return true; } } } return false; } // index表示str的下标 private boolean dfs(char[][] m, int i, int j, char[] str,boolean[][]visited,int index) { if (i >= m.length || i &lt; 0 || j >= m[0].length || j &lt; 0) return false; if (!visited[i][j] &amp;&amp; m[i][j] == str[index]){ if (index == str.length - 1) return true; else { visited[i][j] = true; //上下左右dfs for (int[] d : direction) { if (dfs(m,i + d[0],j + d[1],str,visited,index + 1)) return true; } visited[i][j] = false; //回溯 } } return false; } } 16. 表示数值中的字符串题目描述：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路：如果按照常规逻辑判断的话 代码比较长，这里可以参考正则表达式进行求解。具体可以参考菜鸟教程。 public class Solution { public boolean isNumeric(char[] str) { if (str.length == 0 || str == null) return false; return new String(str).matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?([eE][+-]?\\\\d+)?\"); } } 17. 调整数组顺序使奇数位于偶数前面题目描述:输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路：考虑拷贝一个相同的数组arr，首先计算出奇数的个数， 然后遍历判断。 public class Solution { public void reOrderArray(int [] array) { int count = 0; for (int i : array) { if (i % 2 != 0) { count++; //奇数个数 } } int first = 0; int len = array.length; int arr[] = array.clone(); for (int i = 0; i &lt; len; i++) { if (arr[i] % 2 != 0) { array[first++] = arr[i]; } else { array[count++] = arr[i]; } } } } 也可以使用排序来实现，可以实现以时间换取空间，双重循环，时间复杂度O(n2) 18. 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5解题思路：递归版本，然后判断就是： public class Solution { public ListNode deleteDuplication(ListNode pHead){ if (pHead == null || pHead.next == null) return pHead; ListNode next = pHead.next; if (next.val == pHead.val) { while (next != null &amp;&amp; pHead.val == next.val){ next = next.next; } return deleteDuplication(next); }else { pHead.next = deleteDuplication(next); return pHead; } } } 非递归版本：有时候做链表相关的题目时，可以考虑new一个ListNode指向第一个指针，这样可以解决边界问题。首先添加一个头节点head，以防止碰到第一个，第二个节点就相同的情况。设置 first ，last 指针， first指针指向当前确定不重复的那个节点，而last指针相当于工作指针，一直往后面搜索。 /* public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; } } */ public class Solution { public ListNode deleteDuplication(ListNode pHead){ if (pHead == null || pHead.next == null) return pHead; ListNode head = new ListNode(0); head.next = pHead; ListNode first = head; ListNode last = head.next; while (last != null) { if (last.next != null &amp;&amp; last.next.val == last.val){ // 找到最后的一个相同节点 while (last.next != null &amp;&amp; last.next.val == last.val){ last = last.next; } first.next = last.next; last = last.next; } else { first = first.next; last = last.next; } } return head.next; } } 19.机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路：采用DFS遍历搜索，定义一个是否访问的数组，如果已访问，就设为true，然后四个方向分别递归，这里要注意将坐标的值转换为值，比如（35，37）转换为（8，10）。类似的题目在LeetCode中还有岛屿问题，朋友圈问题，可以参考下。传送门 public class Solution { private int [][] direction = {{0,1},{0,-1},{1,0},{-1,0}}; private int count = 0; private int threshold; private int rows; private int cols; private int[][] nums; public int movingCount(int threshold, int rows, int cols){ this.threshold = threshold; this.rows = rows; this.cols = cols; boolean b[][] = new boolean[rows][cols]; getNum(); hasRange(b,0,0); return count; } //dfs遍历 private void hasRange(boolean [][] b,int i, int j) { if (i >= rows || i &lt; 0 || j >= cols || j &lt; 0 || b[i][j] || this.nums[i][j] > threshold ){ return; } b[i][j] = true; count++; for (int d[] : direction) { hasRange(b,i + d[0],j + d[1]); } } //将坐标转换为值 private void getNum(){ int [] nums2 = new int [Math.max(rows,cols)]; for (int i = 0; i &lt; nums2.length; i++) { int temp = i; while (temp > 0) { nums2[i] += temp % 10; temp /= 10; } } this.nums = new int[rows][cols]; for (int i = 0; i &lt; this.rows; i++) { for (int j = 0; j &lt; this.cols; j++) { this.nums[i][j] = nums2[i] + nums2[j]; } } } }","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/剑指Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/剑指Offer/"}]},{"title":"Java 并发编程复习（一）","slug":"Java 并发编程复习（一）","date":"2019-08-10T10:25:08.000Z","updated":"2019-09-30T14:29:09.345Z","comments":true,"path":"2019/08/10/java-bing-fa-bian-cheng-fu-xi-yi/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/08/10/java-bing-fa-bian-cheng-fu-xi-yi/","excerpt":"","text":"周末抽空看了 Java并发编程的艺术，暑假从图书馆借的，趁带复习并总结下并发编程相关知识点，很多都是大佬们总结好的，做了知识的搬运工，附加自己的理解。 1.synchronized是什么，实现原理怎样的？synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。java代码中使用synchronized是使用在代码块和方法中：synchronized可以用在方法上也可以使用在代码块中，其中方法是实例方法和静态方法分别锁的是该类的实例对象和该类的对象。而使用在代码块中也可以分为三种。需要注意的是：如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。（可参考cyc博客） 实现原理： 修饰代码块： public class SynchronizedDemo { public static void main(String[] args) { synchronized (SynchronizedDemo.class) { } method(); } private static void method() { } } 可以通过 java -p 查看编译后的class文件 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817154617332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjk5MzM5,size_16,color_FFFFFF,t_70) synchronized 同步语句块的实现使用的是 **monitorenter 和 monitorexit 指令**，其中 monitorenter 指令指向同步代码块的**开始位置**，monitorexit 指令则指明同步代码块的**结束位置**。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 - 修饰方法： synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 **ACC_SYNCHRONIZED** 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 #### 2.有哪几种锁？锁的优化？ 这里的锁优化主要是指 JVM 对 synchronized 的优化。 synchronized 在同步的时候是获取对象的monitor,即获取到对象的锁，用的锁是存在 Java 对象头里的。 锁主要存在四种状态，依次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**，他们会随着竞争的激烈而逐渐升级。注意**锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。** 引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了**没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。**但是不同是：**轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉。** - 偏向锁： 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，**那么持有偏向锁的线程就不需要进行同步，连 CAS 操作也不需要。** 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向后恢复到未锁定状态或者轻量级锁状态。 - 轻量级锁： 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段。轻量级锁是相对于传统的重量级锁而言，它**使用 CAS 操作来避免重量级锁使用互斥量的开销**，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，**不需要申请互斥量。**另外，**轻量级锁的加锁和解锁都用到了CAS操作。** 如果有两条以上的线程争用同一个锁，轻量级锁比传统的重量级锁更慢，轻量级锁就不再有效，要膨胀为重量级锁。 - 三种锁比较：来自《Java 并发编程的艺术》 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190817163501345.png) - 自旋锁： 轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。 互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。**自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。** 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 - 锁消除： 锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 - 锁粗化： 如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。即原本加锁多次的，加锁一次就可以了。 #### 3. volatile 关键字，实现原理 作用： - 被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。 - volatile 关键字也可以防止指令重排，如单例模式中的双重校验锁实现。 我们知道，变量可以保存在本地缓存，也可以保存在内存中，如果一个线程在内存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，就会造成数据的不一致。 **实现原理：** 生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令**，该指令有两个作用： - 将当前处理器缓存行的数据写回系统内存； - 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效； - 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。 synchronized 关键字和 volatile 关键字的区别： - volatile关键字是线程同步的轻量级实现，所以volatile性能比synchronized关键字要好。 - volatile关键字只能用于变量，而synchronized关键字可以修饰方法以及代码块； - 多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞； - volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证； - volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。 #### 4.synchronized和ReentrantLock 的区别 Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 区别： - synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 - ReentrantLock提供了一种能够**中断等待锁**的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。 - ReentrantLock支持两种锁：公平锁和非公平锁。**默认非公平**。公平性是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO，可以通过 ReentrantLock类的ReentrantLock(boolean fair)，而**synchronized 中的锁是非公平的。** - 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 - JDK1.6后 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 的性能大致相同。 选择： 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 #### 5. ThreadLocal是什么，实现原理： 通常解决线程安全的问题我们会利用synchronzed或者lock控制线程对临界区资源的同步顺序从而解决线程安全的问题，但是这种加锁的方式会让未获取到锁的线程进行阻塞等待，很显然这种方式的时间效率并不是很好。 **ThreadLocal 实现了每个线程都使用自己的“共享资源”，各自使用各自的，又互相不影响到彼让多个线程间达到隔离的状态**，这样就不会出现线程安全的问题。这就是一种“空间换时间”的方案，每个线程都会都拥有自己的“共享资源”无疑内存会大很多，但是由于不需要同步也就减少了线程可能存在的阻塞等待的情况从而提高的时间效率。 实现原理： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 ThreadLocal.et(); ~~~ java public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; }ThreadLocal.get(); public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; } } return setInitialValue(); } ThreadLocal 内存泄露问题：ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。 使用场景：ThreadLocal 不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap,也就是说每个不同的线程都拥有专属于自己的数据容器（threadLocalMap），彼此不影响。因此threadLocal只适用于 共享对象会造成线程安全 的业务场景。比如通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的session,若将session共享出去被多线程访问，必然会带来线程安全问题。 private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException { Session s = (Session) threadSession.get(); try { if (s == null) { s = getSessionFactory().openSession(); threadSession.set(s); } } catch (HibernateException ex) { throw new InfrastructureException(ex); } return s; } 6. 什么是线程池，有什么好处使用线程池管理线程主要有如下好处： 降低资源消耗。通过复用已存在的线程和降低线程关闭的次数来尽可能降低系统性能损耗； 提升系统响应速度。通过复用线程，省去创建线程的过程，因此整体上提升了系统的响应速度； 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此，需要使用线程池来管理线程。 Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 线程池的工作原理：线程池的创建、关闭、如何合理配置线程池参数可以参考下面这篇文章。线程池详解 如何设计一个线程池，需要考虑什么？ 一个线程池包括以下四个基本组成部分： • 线程管理器 (Thread Pool ) ：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务； • 工作线程 (PoolWorker) ：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务； • 任务接口 (Task) ：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等； • 任务队列 (TaskQueue) ：用于存放没有处理的任务。提供一种缓冲机制； ○ 所包含的方法 • private ThreadPool() 创建线程池 • public static ThreadPool getThreadPool() 获得一个默认线程个数的线程池 • public void execute(Runnable task) 执行任务 , 其实只是把任务加入任务队列，什么时候执行有线程池管理器决定 • public void execute(Runnable[] task) 批量执行任务 , 其实只是把任务加入任务队列，什么时候执行有线程池管理器 决定• public void destroy() 销毁线程池 , 该方法保证在所有任务都完成的情况下才销毁所有线程，否则等待任务完成才销毁 • public int getWorkThreadNumber() 返回工作线程的个数 • public int getFinishedTasknumber() 返回已完成任务的个数 , 这里的已完成是只出了任务队列的任务个数，可能该任务并没有实际执行完成 • public void addThread() 在保证线程池中所有线程正在执行，并且要执行线程的个数大于某一值时。增加线程池中线程的个数 • public void reduceThread() 在保证线程池中有很大一部分线程处于空闲状态，并且空闲状态的线程在小于某一s值时，减少线程池中线程的个数 参考文献： 《Java并发编程的艺术》 Java 并发专题27篇 CyC2018/Java并发 JavaGuide/Java并发","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/Java并发/"}],"tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/并发编程/"}]},{"title":"剑指Offer（1-9Java语言描述）","slug":"剑指Offer（1-9Java语言描述）","date":"2019-08-02T10:25:08.000Z","updated":"2019-09-30T14:27:26.485Z","comments":true,"path":"2019/08/02/jian-zhi-offer-1-9java-yu-yan-miao-shu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/08/02/jian-zhi-offer-1-9java-yu-yan-miao-shu/","excerpt":"","text":"很快秋招就来了，今天开始刷剑指，应该不会太慢吧，之前刷了一百道leetcode，按照tag刷的，想着这个月前把剑指刷一遍，第一波，记录下： 顺便附带亮剑经典语录 一：碰到我们独立团，就是碰到了一群野狼，在咱们眼里，任何对手，都是我们嘴里的一块肉。 不说鸡汤了，上题 1. 二进制中 1 的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。解题思路：这道题之前leetcode也有看到，也做过。第一种可以直接用api Integer.bitCount(n) public class Solution { public int NumberOf1(int n) { return Integer.bitCount(n); } } 第二种可以用 &amp; 运算的性质，n &amp; （n - 1） 去除n的二进制最低位。 public class Solution { public int NumberOf1(int n) { int count = 0; while (n != 0) { n = n &amp; (n - 1); count++; } return count; } } 2. 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。解题思路：自己直接的遍历循环解法，时间复杂度O(n) public class Solution { public double Power(double base, int exponent) { if (base == 0.0) return 0; if (exponent == 0) return 1; double temp = base; for (int i = 1; i &lt; Math.abs(exponent); i++) { base *= temp; } return exponent > 0 ? base : 1 / base; } } 大神的解法思路:有这样的规律。。。 当n为偶数，a^n =（a^n/2）*（a^n/2） 当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a因此 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。 public class Solution { public double Power(double base, int exponent) { if (base == 0) return 0; if (exponent == 0) return 1; if (exponent == 1) return base; double res = Power(base * base, Math.abs(exponent / 2)); if (exponent % 2 != 0) { res *= base; } return exponent > 0 ? res : 1 / res; } } 3.重复的数字题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。解题思路：本题可以用排序，然后判断即可，不过如果要去时间复杂度O(n)，空间复杂度O(n)的话，就不能用排序了，因此注意题目特点，数组元素在 [0, n-1] 范围内，可以将值为 i 的元素调整（交换）到第 i 个位置上，然后遍历的时候判断对应位置是否已经存在值，进行求解。 public class Solution { public boolean duplicate(int numbers[],int length,int [] duplication) { if (length == 0) return false; for (int i = 0; i &lt; length; i++) { if (numbers[i] == i) continue; else{ if (numbers[i] == numbers[numbers[i]] ) { duplication[0] = numbers[i]; return true; } swap(numbers,i,numbers[i]); } } return false; } private void swap(int [] arr,int a ,int b){ int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; } } 4.二维数组中的查找题目描述:在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。解题思路：这道题刚开始考虑二分查找，结果发现不行，后来看数组的特点，从左到右递增，从上到下递减，因此右下角的数字肯定最大，左上角的数字肯定最小，可以考虑从右上角或者左下角判断与target值 得大小，然后进行移动。这里我从右上角开始判断。 public class Solution { public boolean Find(int target, int [][] array) { if (array.length == 0) return false; int row = array.length; int column = array[0].length; int r = 0, c = column - 1; while (r &lt; row &amp;&amp; c >= 0) { if (target == array[r][c]) return true; else if (target > array[r][c]) r++; else c--; } return false; } } 5.替换空格为指定字符 题目描述： 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路： 其实可以使用Java一行代码即可实现，用replace 方法。。。皮了。 也可以用StringBuffer中的append来实现，这样就需要再创建一个Strinbuffer对象。 这里还是老老实实从后往前遍历，首先先定义两个长度，temp1 和 temp2 ，当遍历到一个空格时，在尾部填充两个任意字符。 public class Solution { public String replaceSpace(StringBuffer str) { int temp1 = str.length() - 1; for (int i = 0; i &lt;= temp1; i++) { if (str.charAt(i) == ' '){ str.append(\" \"); //有多少空格就加多少 \" \" } } int temp2 = str.length() - 1; while (temp1 >=0 &amp;&amp; temp2 > temp1) { char c = str.charAt(temp1--); if (c == ' '){ str.setCharAt(temp2--,'0'); str.setCharAt(temp2--,'2'); str.setCharAt(temp2--,'%'); } else { str.setCharAt(temp2--,c); } } return str.toString(); } } 6.从尾到头打印链表题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。Input : 1 -&gt; 2 -&gt; 3Output : 3 -&gt; 2 -&gt; 1 解题思路：题目刚看，感觉就是链表反转，那么如何进行链表反转呢，其实可以使用 头插法，这里 head 就是头，head不存储数据，head.next存储反转后的链表。反转后再遍历就是了。 import java.util.ArrayList; public class Solution { public ArrayList&lt;Integer> printListFromTailToHead(ListNode listNode) { ListNode head = new ListNode(-1); while (listNode != null) { ListNode temp = listNode.next; listNode.next = head.next; head.next = listNode; listNode = temp; } ArrayList&lt;Integer> list = new ArrayList(); head = head.next; while (head != null) { list.add(head.val); head = head.next; } return list; } } 本题也可以说用栈来实现，利用栈的特点，后进先出。 import java.util.*; public class Solution { public ArrayList&lt;Integer> printListFromTailToHead(ListNode listNode) { Stack&lt;Integer> stack = new Stack(); while (listNode != null) { stack.push(listNode.val); listNode = listNode.next; } ArrayList&lt;Integer> list = new ArrayList(); while (!stack.isEmpty() ) { list.add(stack.pop()); } return list; } } 7.重建二叉树题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路：注意二叉树性质，如果涉及到二叉树，应当考虑使用递归来解决，首先根据前序遍历第一个值就是根节点，然后根据根结点在中序序列中的位置分割出左右两个子序列，最后递归地对左子树和右子树分别递归使用同样的方法继续分解。这里注意Arrays.copyOfRange()的用法，（左闭右开）附上API： import java.util.Arrays; public class Solution { public TreeNode reConstructBinaryTree(int [] pre,int [] in) { if (pre.length == 0 || in.length == 0) return null; int value = pre[0]; TreeNode root = new TreeNode(value); for (int i = 0; i &lt; in.length; i++){ if (in[i] == value) { root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i)); root.right =reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,in.length),Arrays.copyOfRange(in,i+1,in.length)); break; } } return root; } } 8.二叉树的下一个结点题目描述:给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。解题思路：由于每个节点都有指向父节点的指针，因此先求的根节点，然后再利用根节点和用链表存储中序遍历的值，然后判断返回链表下一个即可，需注意是否是最后一个。 /* public class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } */ import java.util.*; public class Solution { static List&lt;TreeLinkNode> list = new ArrayList(); public TreeLinkNode GetNext(TreeLinkNode pNode){ if (pNode == null) return null; TreeLinkNode p = pNode; while (pNode.next != null) { pNode = pNode.next; } getMidTravel(pNode); for (int i = 0; i &lt; list.size(); i++) { if (list.get(i) == p) { return (i == list.size() - 1) ? null : list.get(i+1); } } return null; } //中序遍历 private static void getMidTravel(TreeLinkNode node) { if (node != null) { getMidTravel(node.left); list.add(node); getMidTravel(node.right); } } } 上述方法时间复杂度O（N),空间复杂度：O(n),下面这种可以做到空间复杂度O(n)可以把中序下一结点归为几种类型： 有右子树，下一结点是右子树中的最左结点 无右子树，且结点是该结点父结点的左子树，则下一结点是该结点的父结点 无右子树，且结点是该结点父结点的右子树，则我们一直沿着父结点追朔，直到找到某个结点是其父结点的左子树，如果存在这样的结点，那么这个结点的父结点就是我们要找的下一结点。 /* public class TreeLinkNode { int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) { this.val = val; } } */ public class Solution { public TreeLinkNode GetNext(TreeLinkNode pNode){ if (pNode == null) return null; if (pNode.right != null) { TreeLinkNode temp = pNode.right; if (temp.left != null) { return temp.left; } return temp; }else { while (pNode.next != null) { TreeLinkNode temp = pNode.next; if (temp.left == pNode) return temp; pNode = pNode.next; } } return null; } } 9. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路：之前在LeetCode刷过类似题目，当时还写了一篇文章LeetCode中的栈和队列的问题，这里使用两个栈，利用栈后进先出特点和队列先进先出特点进行解决即可。需要注意的就是当第二个栈stack2为空时才往里面push。 import java.util.Stack; public class Solution { Stack&lt;Integer> stack1 = new Stack&lt;Integer>(); Stack&lt;Integer> stack2 = new Stack&lt;Integer>(); public void push(int node) { stack1.push(node); } public int pop() { //当第二个栈stack2为空时才往里面push。 while (stack2.empty()){ while (!stack1.empty()){ stack2.push(stack1.pop()); } } return stack2.pop(); } }","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/剑指Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/剑指Offer/"}]},{"title":"MySQL杂记","slug":"MySQL面试常见题目","date":"2019-07-12T10:25:08.000Z","updated":"2019-09-30T14:23:58.128Z","comments":true,"path":"2019/07/12/mysql-mian-shi-chang-jian-ti-mu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/07/12/mysql-mian-shi-chang-jian-ti-mu/","excerpt":"","text":"最近在复习 MySQL，感觉知识点很零散，顺便巩固总结下相关的知识。 1.事务四个特性：面试常客，再基础不过 A 原子性（Atomicity） C 一致性（Consistency） I 隔离性（Isolation） D 持久性（Durability）2.并发事务带来的问题（要理解每个概念） 脏读 丢失修改 不可重复读 幻读 3.事务隔离级别有哪些 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。（MySQL默认的事务隔离级别） SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。3.MyISAM和InnoDB区别MyISAM是MySQL的默认数据库引擎（5.5版之前）。但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。 大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃回复问题的话）。 二者区别： MyISAM 不支持外键，而 InnoDB 支持 MyISAM 是非事务安全型的，而 InnoDB 是事务安全型的。 MyISAM 锁的粒度是表级，而 InnoDB 支持行级锁定。 MyISAM 支持全文类型索引，而 InnoDB 不支持全文索引。 MyISAM 相对简单，所以在效率上要优于 InnoDB，小型应用可以考虑使用 MyISAM。 MyISAM 表是保存成文件的形式，在跨平台的数据转移中使用 MyISAM 存储会省去不少的麻烦。 InnoDB 表比 MyISAM 表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。 锁的区别: InnoDB(默认) ：事务优先 （适合高并发操作；行锁） MyISAM ：性能优先 （表锁） 应用场景: MyISAM 管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的 SELECT 查询，那么 MyISAM 是更好的选择。 InnoDB 用于事务处理应用程序，具有众多特性，包括 ACID 事务支持。如果应用中需要执行大量的 INSERT 或 UPDATE 操作，则应该使用 InnoDB，这样可以提高多用户并发操作的性能。 4.B树和B+树有什么区别？为什么索引不用B树？B-树是一种平衡的多路查找(又称排序)树，就是B树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance) B-树 ： 定义任意非叶子结点最多只有M个儿子；且M&gt;2； 根结点的儿子数为[2, M]； 除根结点以外的非叶子结点的儿子数为[M/2, M]； 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 所有叶子结点位于同一层；（图片来自网上，侵删）B-树的搜索：从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；其搜索的特点： 关键字集合分布在整颗树中； 任何一个关键字出现且只出现在一个结点中； 搜索有可能在非叶子结点结束； 其搜索性能等价于在关键字全集内做一次二分查找； 由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最低搜索性能为lgN； B-树的性能总是等价于二分查找（与M值无关），没有B树平衡的问题； B+树性质：B+树是B-树的变体，也是一种多路搜索树： 其定义基本与B-树同，有以下不同点： 非叶子结点的子树指针与关键字个数相同； 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； 为所有叶子结点增加一个链指针； 所有关键字都在叶子结点出现； B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在 非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；（图片来自网上，侵删） B+的特性： 所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 更适合文件索引系统； 5.数据库的索引有什么作用？优点： 提高查询效率（降低IO使用率） 降低CPU使用率 （…order by age desc，因为 B树索引 本身就是一个 好排序的结构，因此在排序时 可以直接使用） 缺点： 索引本身很大， 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的； 索引在以下情况不适用： a. 少量数据，b.频繁更新的字段，c.很少使用的字段 索引会降低增删改的效率；MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息。 6.乐观锁和悲观锁区别： 乐观锁：乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。乐观锁是否在事务中其实是无所谓的。 悲观锁：悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 区别：乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。 7.一条sql语句在mysql中如何执行的 MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。 查询语句的执行流程如下：权限校验（如果命中缓存）—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎 更新语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log(prepare 状态—》binlog—》redo log(commit状态)参考一条sql语句在mysql中如何执行的","categories":[{"name":"数据库","slug":"数据库","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/MySQL/"}]},{"title":"递归刷题","slug":"LeetCode 中有关递归的题目","date":"2019-07-10T10:25:08.000Z","updated":"2019-09-30T14:19:52.027Z","comments":true,"path":"2019/07/10/leetcode-zhong-you-guan-di-gui-de-ti-mu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/07/10/leetcode-zhong-you-guan-di-gui-de-ti-mu/","excerpt":"","text":"递归，其实就是在运行的过程中调用自己。平时解决递归三部曲，可以考虑下： 找整个递归的终止条件：递归应该在什么时候结束？ 找返回值：应该给上一级返回什么信息？ 本级递归应该做什么：在这一级递归中，应该完成什么任务？ 构成递归需具备的条件： 子问题须与原始问题为同样的事，且更为简单； 不能无限制地调用本身，须有个出口，化简为非递归状况处理。 112. 路径总和题目描述：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路：递归遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；时间复杂度：每访问每个节点一次，时间复杂度为 O(N)O(N) ，其中 NN 是节点个数空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 NN 次（树的高度），因此栈的空间开销是 O(N)O(N)最好情况下，树是完全平衡的，高度只有 \\log(N)log(N)，因此在这种情况下空间复杂度只有 O(\\log(N))O(log(N)) /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public static int res = 0; public boolean hasPathSum(TreeNode root, int sum) { if (root == null) return false; if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } } 111. 二叉树的最小深度题目描述：给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2.解题思路：这里注意 叶子节点是指没有子节点的节点，然后当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度，当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; int left = minDepth(root.left); int right = minDepth(root.right); if (left == 0 || right == 0) return left + right + 1; return Math.min(left,right)+1; } } 617. 合并二叉树题目描述：给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回它的最小深度 2. ##### 解题思路： 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。解题思路：首先先判断t1是否为空，如果为空返回t2；如果t2为空则返回t1 当前面的if语句都没运行那么证明两方都不为空。那么先将两节点的值相加，然后再递归左节点，递归右节点。需要注意的就是需要创建临时节点root。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null &amp;&amp; t2 == null) return null; if (t1 == null) return t2; if (t2 == null) return t1; TreeNode root = new TreeNode(t1.val + t2.val); root.left = mergeTrees(t1.left, t2.left); root.right = mergeTrees(t1.right, t2.right); return root; } } 437. 路径总和 III题目描述：给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -&gt; 3 2. 5 -&gt; 2 -&gt; 1 3. -3 -&gt; 11解题思路：递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架必然要出现在主函数 pathSum 中。这道题中 其中count(root,sum) 为自己为开头的路径数pathSum(root.left,sum) 左边路径总数pathSum(root.right,sum) 右边路径总数 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int pathSum(TreeNode root, int sum) { if (root == null) return 0; return count(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum); } private int count(TreeNode root,int sum) { if (root == null) return 0; int res = 0; if (root.val == sum) res++; res += count(root.left,sum - root.val) + count(root.right,sum - root.val); return res; } } 572. 另一个树的子树题目描述：给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1: 给定的树 s: 3 / \\ 4 5 / \\ 1 2 给定的树 t： 4 / \\ 1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。解题思路：跟LeetCode 437 题有点类似，同样写一个递归方法 isRoot ，该方法用来判断两个节点值是否相等(包括它们的左右子树)，然后在 isSubtree 中 递归调用左右子树判断即可。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSubtree(TreeNode s, TreeNode t) { if (s == null) return false; return isRoot(s,t) || isSubtree(s.left,t) || isSubtree(s.right,t); } private boolean isRoot(TreeNode t1, TreeNode t2) { if (t1 == null &amp;&amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return isRoot(t1.left,t2.left) &amp;&amp; isRoot(t1.right,t2.right); } } 101. 对称二叉树题目描述：给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3解题思路：其实跟上面题差不多，就是递归判断左右子树是否相等，subSymmetric 方法，就是判断子树中的值是否相同，本题也可以用栈迭代的方法来解题。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if (root == null) return true; return subSymmetric(root.left,root.right); } private boolean subSymmetric(TreeNode t1,TreeNode t2) { if (t1 == null &amp;&amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return subSymmetric(t1.left,t2.right) &amp;&amp; subSymmetric(t1.right,t2.left); } } 404. 左叶子之和题目描述：计算给定二叉树的所有左叶子之和。 示例： 3 / \\ 9 20 / \\ 15 7 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24解题思路：首先写一个判断是不是叶子结点的方法，然后在主方法递归调用根节点的左右节点 然后累加sum。 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { private int sum = 0; public int sumOfLeftLeaves(TreeNode root) { if (root == null) return 0; if (isLeaf(root.left)) sum += root.left.val; sumOfLeftLeaves(root.left); sumOfLeftLeaves(root.right); return sum; } private boolean isLeaf(TreeNode t) { if (t == null) return false; if (t.left == null &amp;&amp; t.right == null) return true; return false; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"递归","slug":"递归","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/递归/"}]},{"title":"Linux学习笔记（二）","slug":"Linux 学习笔记（二）","date":"2019-07-06T10:25:08.000Z","updated":"2019-09-30T14:22:16.440Z","comments":true,"path":"2019/07/06/linux-xue-xi-bi-ji-er/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/07/06/linux-xue-xi-bi-ji-er/","excerpt":"","text":"今天线上生产环境出了问题，于是通过用Linux命令查看日志得方法来解决问题，最终找到根源，这里查看日志等命令还是比较简单，稍微深入学习下 Linux。接上一篇。。 CPUtop：查看每个进程的情况 在top模式下，输入1：查看每个CPU的性能数据，注意观察是否有CPU100%占用率 CPU参数含义： 1）us过高表示Java应用程序消耗了大量CPU，需要定位是哪一个线程，并分析线程堆栈。 在top模式下，输入H：查看每个线程的性能信息如果某个线程CPU利用率一直100%，则说明这个线程可能有死循环，也有可能是GC的问题。jstat命令可以查看GC情况，是不是产生了FullGC。 2）sy过高表示花费了更多时间进行线程切换。同样需要查看Java线程的状态。 文件IO 磁盘ls显示文件夹下的文件详情，包括大小ls –alla表示all，包括隐藏文件 stat（查看文件详情）stat filepath 文本操作命令cat 由第一行开始显示内容，并将所有内容输出tac 从最后一行倒序显示内容，并将所有内容输出more 根据窗口大小，一页一页的显示文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head 只显示头几行tail 只显示最后几行sort、uniqsort 进行排序。 $ sort [-fbMnrtuk] [file or stdin]-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN, DEC-n ：使用数字-r ：反向排序-u ：相当于 unique ，重复内容只出现一次-t ：分隔符，默认为tab-k ：指定排序的区间范例：/etc/passwd 内容是以 : 来分隔的，以第三栏来排序。 $ cat /etc/passwd | sort -t &#39;:&#39; -k 3 root:x:0:0:root:/root:/bin/bash dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash alex:x:1001:1002::/home/alex:/bin/bash arod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。$ uniq [-ic]-i ：忽略大小写-c ：进行计数 使用cat命令可以显示文本文件内容,或 把几个文件内容附加到另一个文件中。使用more命令可以分页显示文本文件的内容。使用less命令可以回卷显示文本文件的内容。使用head命令可以显示指定文件的前若干行文件内容。使用tail命令可以查看文件的末尾数据。 vimvi编辑器有3种基本工作模式,分别是命令行模式、插入模式和末行模式。命令行模式控制屏幕光标的移动,字符、字或行的删除,移动、复制某区域及进入插入模式,或者到末行模式。只有在插入模式下,才可以做文字输入,按“Esc”键可回到命令行模式。末行模式将文件保存或退出vi编辑器,也可以设置编辑环境,如寻找字符串、列出行号等。 在指令列模式下，有以下命令用于离开或者存储文件。 命令 作用:w 写入磁盘:w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关:q 离开:q! 强制离开不保存:wq 写入磁盘后离开:wq! 强制写入磁盘后离开 实时查看日志命令这个算是最近用的比较多得一条命令了。。。tail -f path-f 循环读取 系统日志/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一/var/log/secure 与安全相关的日志信息/var/log/maillog 与邮件相关的日志信息/var/log/cron 与定时任务相关的日志信息/var/log/spooler 与UUCP和news设备相关的日志信息/var/log/boot.log 守护进程启动和停止相关的日志消息/var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件 find查找磁盘上最大的文件的命令find / -type f -size +10G列出当前目录及子目录下所有文件和文件夹 在/home目录下查找以.txt结尾的文件名 find /home -name “*.txt” 同上，但忽略大小写 find /home -iname “*.txt” 根据文件类型进行搜索find . -type 类型参数:类型参数列表：f 普通文件l 符号连接d 目录c 字符设备b 块设备s 套接字p Fifo 基于目录深度搜索:向下最大深度限制为3 find . -maxdepth 3 -type f搜索出深度距离当前目录至少2个子目录的所有文件 find . -mindepth 2 -type f根据文件时间戳进行搜索 find . -type f 时间戳 UNIX/Linux文件系统每个文件都有三种时间戳： 访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。搜索最近七天内被访问过的所有文件 find . -type f -atime -7 搜索恰好在七天前被访问过的所有文件 find . -type f -atime 7 搜索超过七天内被访问过的所有文件 find . -type f -atime +7 搜索访问时间超过10分钟的所有文件 find . -type f -amin +10 找出比file.log修改时间更长的所有文件 find . -type f -newer file.log 根据文件大小进行匹配find . -type f -size 文件大小单元 文件大小单元： b —— 块（512字节）c —— 字节w —— 字（2字节）k —— 千字节M —— 兆字节G —— 吉字节搜索大于10KB的文件find . -type f -size +10k搜索小于10KB的文件find . -type f -size -10k搜索等于10KB的文件find . -type f -size 10k 删除匹配文件删除当前目录下所有.txt文件 find . -type f -name “.txt” -delete根据文件权限/所有权进行匹配当前目录下搜索出权限为777的文件 find . -type f -perm 777找出当前目录下权限不是644的php文件 find . -type f -name “.php” ! -perm 644找出当前目录用户tom拥有的所有文件 find . -type f -user tom 将当前目录下所有以“.txt”结尾的文件打印出来，再追问，除了“.txt”再加上“.abc”结尾的也打印出来。find . -name “*.txt” grep在文件内查找字符串grep “字符串” filename文件权限r：可读(4)w：可写(2)，对于目录来说表示可在目录中新建文件x：可执行(1)，对于目录来说为可进入到该目录中-：表示无对应位上的权限4代表读权限，2代表写权限，1代表执行权限 7=4+2+1,表示拥有可读可写可执行权限5=4+1,表示拥有可读可执行权限，但是没有写权限4 代表拥有可读权限0 代表没有任何权限 chmod 修改文件属性chmod 777 /home/berrychmod u+x /home/berry u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。 chown 修改文件的属主与属组chown guest:guest a.txtchown -R guest /home/berry (把berry文件下的所有文件都改成guest这个组）chgrp 修改文件的所属的用户组chgrp -R guest /var/tmp/f.txtchgrp - R root /home/berry/file/a.txtiostat（查看各个设备的IO状态，查看磁盘读写性能）直接输入iostat：tps是每秒的IO请求数，这是IO消耗情况值得关注的数字。Blk_read/s是指每秒读取的块数量，通过块的大小是512字节Blk_read是指总共读取的块数量 进程ps –ef/-auxps aux 和ps -ef两者的输出结果差别不大，但展示风格不同。aux是BSD风格，-ef是System V风格。这是次要的区别，一个影响使用的区别是aux会截断command列，而-ef不会。当结合grep时这种区别会影响到结果。 ps -ef 显示出的结果： 1.UID 用户ID 2.PID 进程ID 3.PPID 父进程ID 4.C CPU占用率 5.STIME 开始时间 6.TTY 开始此进程的TTY—-终端设备 7.TIME 此进程运行的总时间 8.CMD 命令名lsof 进程打开的文件、端口lsof ［options］ filename-a：列出打开文件存在的进程；-c&lt;进程名&gt;：列出指定进程所打开的文件；-g：列出GID号进程详情；-d&lt;文件号&gt;：列出占用该文件号的进程；+d&lt;目录&gt;：列出目录下被打开的文件；+D&lt;目录&gt;：递归列出目录下被打开的文件；-n&lt;目录&gt;：列出使用NFS的文件；-i&lt;条件&gt;：列出符合条件的进程。（4、6、协议、:端口、 @ip ）-p&lt;进程号&gt;：列出指定进程号所打开的文件；-u：列出UID号进程详情；-h：显示帮助信息；-v：显示版本信息。 cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改txt：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序lnn：library references (AIX);er：FD information error (see NAME column);jld：jail directory (FreeBSD);ltx：shared library text (code and data);mxx ：hex memory-mapped type number xx.m86：DOS Merge mapped file;mem：memory-mapped file;mmap：memory-mapped device;pd：parent directory;rtd：root directory;tr：kernel trace file (OpenBSD);v86 VP/ix mapped file;0：表示标准输出1：表示标准输入2：表示标准错误 kill杀死进程 负载 Load Average系统的load被定义为特定时间间隔内运行队列的平均线程数，如果一个线程满足以下条件，该线程就会处于运行队列中： 没有处于I/O等待状态。 没有主动进入等待状态，也就是没有调用wait操作； 没有被终止。 每个CPU的核都维护了一个运行队列，系统的load主要由运行队列来决定。load的值越大，也就意味着系统的CPU越繁忙，这样线程运行完以后等待操作系统分配下一个时间片段的时间也就越长。一般来说，只要每个CPU当前的活动线程数不大于3，我们认为它的负载是正常的，如果每个CPU的线程数大于5，则表示当前系统的负载已经非常高了，需要采取措施来减低系统的负载，以提高响应速度。 使用top命令查看，该值是三个浮点数，表示最近1分钟、5分钟、15分钟的运行队列平均进程数。 cp/mv的区别1、功能上的区别mv：用户可以使用该命令为文件或目录重命名或将文件由一个目录移入另一个目录中。cp: 该命令的功能是将给出的文件或目录拷贝到另一文件或目录中。 2、从inode角度来区分mv：会将存储于indoe索引节点上的文件元信息也移动到新文件中。cp : 只会复制文件数据，不会复制inode索引节点上的文件元信息。 cp 的时候是真正意义上的内容copy，对于 inode 节点却是不会变化的。mv 的时候是把源文件直接删除了（inode 删除了），新的文件其实已经不是以前的文件了，只是名字一样而已。网络 netstat（端口） 查看tcp连接数状态netstat -n | awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’ 统计8080端口上有多少个TCP连接，命令：netstat –nat | grep 8080 | wc –l TCP连接中有多少个连接状态是ESTABLISHED，命令：netstat –nat | grep 8080 | grep ESTABLISHED| wc -l TCP连接中有多少个连接状态是CLOSE_WAITnetstat –nat | grep 8080 | grep CLOSE_WAIT| wc -l TCP连接中有多少个连接状态是TIME_WAITnetstat –nat | grep 8080 | grep TIME_WAIT| wc -l 使用awk来完成统计信息，命令如下netstat –nat | grep 8080 | awk ‘{++S[$NF]} END {for (a in S) print a, S[a]}’sarsar –n FULL 1 2 执行后以1s为频率，总共输出两次网络IO的消耗情况。输出信息包含三部分：网卡上成功的接包和发包的信息 网卡上失败的接包和发包信息 sockets上的统计信息（tcpsck、udpsck）如需详细跟踪tcp/ip通信过程的信息，则可通过tcpdump来进行。 tcpdumptcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ] [ -s snaplen ] [ -w file ] [ expression ] 抓包选项：-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定”-c 10”将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。-i interface：指定tcpdump需要监听的端口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback端口，要抓取loopback接口使用tcpdump -i lo)， ：一旦找到第一个符合条件的端口，搜寻马上结束。可以使用’any’关键字表示所有网络接口。-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。-N：不打印出host的域名部分。例如tcpdump将会打印’nic’而不是’nic.ddn.mil’。-P：指定要抓取的包是流入还是流出的包。可以给定的值为”in”、”out”和”inout”，默认为”inout”。-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断， 输出选项：-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。-v：当分析和打印的时候，产生详细的输出。-vv：产生比-v更详细的输出。-vvv：产生比-vv更详细的输出。 其他功能性选项：-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于”-i”后。-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。-w：将抓包数据输出到文件中而不是标准输出。可以同时配合”-G time”选项使得输出文件每time秒就自动切换到另一个文件。可通过”-r”选项载入这些文件以进行分析和打印。-r：从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。 (1).默认启动tcpdump默认情况下，直接启动tcpdump将监视第一个网络接口(非lo口)上所有流通的数据包。这样抓取的结果会非常多，滚动非常快。 (2).监视指定网络接口的数据包tcpdump -i eth1如果不指定网卡，默认tcpdump只会监视第一个网络接口，如eth0。 (3).监视指定主机的数据包，例如所有进入或离开longshuai的数据包tcpdump host longshuai (4).打印helios&lt;–&gt;hot或helios&lt;–&gt;ace之间通信的数据包tcpdump host helios and ( hot or ace ) (5).打印ace与任何其他主机之间通信的IP数据包,但不包括与helios之间的数据包tcpdump ip host ace and not helios (6).截获主机hostname发送的所有数据tcpdump src host hostname(7).监视所有发送到主机hostname的数据包tcpdump dst host hostname (8).监视指定主机和端口的数据包tcpdump tcp port 22 and host hostname (9).对本机的udp 123端口进行监视(123为ntp的服务端口)tcpdump udp port 123 (10).监视指定网络的数据包，如本机与192.168网段通信的数据包，”-c 10”表示只抓取10个包tcpdump -c 10 net 192.168 AWK/SEDawkawk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。awk ‘{pattern + action}’ {filenames} 统计ipcat test.txt | awk ‘{print $2}’ | sort | uniq -c | sort -n -r | head -n 1sed 编辑文本sed -e ‘s/foo/bar/‘ myfile将 myfile 文件中每行第一次出现的foo用字符串bar替换，然后将该文件内容输出到标准输出 sed -e ‘s/foo/bar/g’ myfile g 使得 sed 对文件中所有符合的字符串都被替换 sed -i ‘s/foo/bar/g’ myfile选项 i 使得 sed 修改文件 sed -i ‘s/foo/bar/g’ ./m*批量操作当前目录下以 m 开头的文件 sed -i ‘s/foo/bar/g’ grep foo -rl --include=&quot;m*&quot; ./ ``括起来的grep命令，表示将grep命令的的结果作为操作文件grep 命令中，选项r表示查找所有子目录，l表示仅列出符合条件的文件名，用来传给sed命令做操作，–include=”m*” 表示仅查找 m 开头的文件管道管道是linux提供的一种常见的进程通信工具管道中的数据只能读取一次管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。 其他关机 数据同步写入磁盘 sync 为了加快对磁盘上文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 shutdown /sbin/shutdown [-krhc] [时间] [警告讯息] -k ： 不会关机，只是发送警告讯息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown 指令内容 其它关机指令reboot、halt、poweroff。运行等级0：关机模式 1：单用户模式（可用于破解root密码） 2：无网络支持的多用户模式 3：有网络支持的多用户模式（文本模式，工作中最常用的模式） 4：保留，未使用 5：有网络支持的 X-windows 支持多用户模式（桌面） 6：重新引导系统，即重启BIOSBIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的 MBR，由 MBR 执行其中的开机管理程序，这个开机管理程序的会加载操作系统的核心文件。 MBR 中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装其它分区的启动扇区上，在启动 MBR 中的开机管理程序时，就可以选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内建的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。数据流重定向重定向有5种方式，分别是: 输出重定向、输入重定向、错误重定向、追加重定向以及同时实现输出和错误的重定向。 重定向就是使用文件代替标准输入、标准输出和标准错误输出。 标准输入 (stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；标准输出 (stdout) ：代码为 1 ，使用 &gt; 或 &gt;&gt; ；标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 /dev/null ，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 $ find /home -name .bashrc &gt; list 2&gt;&amp;1 孤儿进程和僵死进程孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1)所收养，并由 init 进程对它们完成状态收集工作。由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait 或 waitpid 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait 或 waitpid，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。 僵死进程通过 ps 命令显示出来的状态为 Z。 系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵死进程所占有的资源，从而结束僵死进程。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Linux/"}]},{"title":"Linux学习笔记（一）","slug":"Linux 学习笔记（一）","date":"2019-07-02T10:25:08.000Z","updated":"2019-09-30T14:22:28.758Z","comments":true,"path":"2019/07/02/linux-xue-xi-bi-ji-yi/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/07/02/linux-xue-xi-bi-ji-yi/","excerpt":"","text":"我们得程序大多数都是运行在 Linux 上面得，因此平时或多或少接触了不少Linux 命令，最近在公司也用到了相关得命令，其中不外乎查看日志，排除错误，部署程序（目前没部署过公司程序）、编写脚本。因此有必要好好学习一波，这次主要学习命令。 使用Linux优点 免费 很多软件原生是在Linux下运行的，庞大的社区支持，生态环境好。 开源，可被定制，开放，多用户的网络操作系统。 相对安全稳定 Linux目录结构 bin 存放二进制可执行文件(ls,cat,mkdir等) boot 存放用于系统引导时使用的各种文件 dev 用于存放设备文件 etc 存放系统配置文件 home 存放所有用户文件的根目录 lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt 系统管理员安装临时文件系统的安装点 opt 额外安装的可选应用程序包所放置的位置 proc 虚拟文件系统，存放当前内存的映射 root 超级用户目录 sbin 存放二进制可执行文件，只有root才能访问 tmp 用于存放各种临时文件 usr 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 var 用于存放运行时需要改变数据的文件 Linux基本命令命令可以参考这里，真的全 Linux基本命令 目录切换命令cd usr： 切换到该目录下usr目录cd ..（或cd../）： 切换到上一层目录cd /： 切换到系统根目录cd ~： 切换到用户主目录cd -： 切换到上一个操作所在目录 文件搜索 which 指令搜索。 whereis 文件搜索。速度比较快，因为它只搜索几个特定的目录。 locate文件搜索。可以用关键字或者正则表达式进行搜索。locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 find 文件搜索。可以使用文件的属性和权限进行搜索。目录的操作命令mkdir 目录名称： 增加目录 ls或者ll（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息 find 目录 参数： 寻找目录（查） mv 目录名称 新目录名称： 修改目录的名称（改） mv 目录名称 目录的新位置： 移动目录的位置—剪切（改） cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝 rm [-rf] 目录: 删除目录（删） 文件的操作命令touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 文件的查看（查） cat： 查看显示文件内容more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看tail-10 ： 查看文件的后10行，Ctrl+C结束注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，步骤： vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 压缩文件打包并压缩文件： Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名2）解压压缩包：tar [-xvf] 压缩文件 权限命令可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 进程管理ps -ef/ps -aux： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：ps aux|grep redis （查看包括redis字符串的进程），也可使用 pgrep redis -a。 注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。 kill -9 进程的pid： 杀死进程（-9 表示强制终止。） 先用ps查找进程，然后用kill杀掉 top ：实时显示进程信息netstat ：查看占用端口的进程 用户管理 useradd 选项 用户名:添加用户账号 userdel 选项 用户名:删除用户帐号 usermod 选项 用户名:修改帐号 passwd 用户名:更改或创建用户的密码 passwd -S 用户名 :显示用户账号密码信息 passwd -d 用户名: 清除用户密码其他常用命令 pwd： 显示当前所在位置 grep 要搜索的字符串 要搜索的文件 –color： 搜索命令，–color代表高亮显示（常用） 查看当前系统的网卡信息：ifconfig shutdown： shutdown -h now： 指定现在立即关机；shutdown +5 “System will shutdown after 5 minutes”：指定5分钟后关机，同时送出警告信息给登入用户。 reboot： reboot： 重开机。reboot -w： 做个重开机的模拟（只有纪录并不会真的重开机）。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Linux/"}]},{"title":"LeetCode中位运算相关题目","slug":"LeetCode 中有关位运算题目","date":"2019-06-25T10:25:08.000Z","updated":"2019-09-30T14:14:30.188Z","comments":true,"path":"2019/06/25/leetcode-zhong-you-guan-wei-yun-suan-ti-mu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/06/25/leetcode-zhong-you-guan-wei-yun-suan-ti-mu/","excerpt":"","text":"这阶段刷完了 LeetCode 上有关位运算的题目，感觉位运算还是挺难，很难get到点，有空还是要去加强学习，要掌握 与&amp;、异或^、或|、非~，还有算术左移、算术右移、无符号右移 。还有 Java 中 Integer 类中常见位运算的方法（三个）。需要注意以下几点： 1. 与&amp;、异或^、或|、非~ x ^ 1s = ~x x &amp; 0s = 0 x &amp; 1s = x x | 0s = x x | 1s = 1s n&amp;(n-1) 去除 n 的位级表示中最低的那一位 n&amp;(-n) 得到 n 的位级表示中最低的那一位 n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。 2. 移位运算： &gt;&gt; n 为算术右移，相当于除以 2n； &gt;&gt;&gt; n 为无符号右移，左边会补上 0。 &lt;&lt; n 为算术左移，相当于乘以 2n。3. Java中位运算方法：** static int Integer.bitCount(); // 统计 1 的数量 static int Integer.highestOneBit(); // 获得最高位 static String toBinaryString(int i); // 转换为二进制表示的字符串 不用额外变量交换两个整数效率也比较快，感觉还是挺威的。a = a ^ b; b = a ^ b; a = a ^ b; 以下是相关题目： 260. 只出现一次的数字 III题目描述：定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。 示例 : 输入: [1,2,1,3,2,5] 输出: [3,5]注意：结果输出的顺序并不重要，对于上面的例子， [5, 3] 也是正确答案。你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ 解题思路：两个不相等的元素在位级表示上必定会有一位存在不同。将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。 public int[] singleNumber(int[] nums) { int diff = 0; for (int num : nums) diff ^= num; diff &amp;= -diff; // 最后一位，利用这一位就可以将两个元素区分开来。 int[] ret = new int[2]; for (int num : nums) { if ((num &amp; diff) == 0) ret[0] ^= num; else ret[1] ^= num; } return ret; } 136.数组中唯一一个不重复的元素题目描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4解题思路：算法应该具有线性时间复杂度，故应该使用位运算来解决问题，位运算还是比较快的。利用异或运算性质，两个相同的数异或的结果为 0 public int singleNumber(int[] nums) { int ret = 0; for (int n : nums) ret = ret ^ n; return ret; } 268.找出数组中缺失的那个数题目描述：给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1] 输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路：跟上题解法类似。 public int missingNumber(int[] nums) { int ret = 0; for (int i = 0; i &lt; nums.length; i++) { ret = ret ^ i ^ nums[i]; } return ret ^ nums.length; } 231.判断一个数是不是 2 的 n 次方题目描述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 示例 1: 输入: 1 输出: true 解释: 20 = 1 示例 2: 输入: 16 输出: true 解释: 24 = 16 示例 3: 输入: 218 输出: false 解题思路： 可以利用 1000 &amp; 0111 == 0 这种性质求解class Solution { public boolean isPowerOfTwo(int n) { int res = n &amp; (n - 1); return n > 0 &amp;&amp; res == 0; } } 也利用Java API Integer.bitCount() 求解public boolean isPowerOfTwo(int n) { return n > 0 &amp;&amp; Integer.bitCount(n) == 1; } ##### [461统计两个数的二进制表示有多少位不同](https://leetcode-cn.com/problems/hamming-distance/) ###### 题目描述： 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。 给出两个整数 x 和 y，计算它们之间的汉明距离。 注意： 0 ≤ x, y &lt; 231.示例: 输入: x = 1, y = 4 输出: 2 解释:1 (0 0 0 1)4 (0 1 0 0) ↑ ↑ 上面的箭头指出了对应二进制位不同的位置。 ###### 解题思路： 1. 可以使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。 ~~~ java public int hammingDistance(int x, int y) { int z = x ^ y; int cnt = 0; while (z != 0) { z &amp;= (z - 1); cnt++; } return cnt; } 也可以按照常规思路 统计 1 的个数class Solution { public int hammingDistance(int x, int y) { int num = x ^ y; int count = 0; String numStr = Integer.toBinaryString(num); for (char c : numStr.toCharArray()) { if (c == '1') { count++; } } return count; } } 371.实现整数的加法题目描述：不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。 示例 1: 输入: a = 1, b = 2 输出: 3 示例 2: 输入: a = -2, b = 3 输出: 1解题思路：a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。 class Solution { public int getSum(int a, int b) { while (b != 0) { int carry = a &amp; b; a = a ^ b; b = carry &lt;&lt; 1; } return a; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/位运算/"}]},{"title":"我所理解的 Dubbo","slug":"还不会Dubbo？快来Pick这篇","date":"2019-06-20T10:25:08.000Z","updated":"2019-09-30T14:13:01.245Z","comments":true,"path":"2019/06/20/huan-bu-hui-dubbo-kuai-lai-pick-zhe-pian/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/06/20/huan-bu-hui-dubbo-kuai-lai-pick-zhe-pian/","excerpt":"","text":"在公司实习这段时间，虽然知道公司是使用 Dubbo 来调用服务的，但是没有深入理解Dubbo的原理，以及为什么要使用 Dubbo，因此重新深入学习了 Dubbo，总结下： 1. 官方文档Dubbo中文官方文档感觉无论学习什么，看官方文档总是最最最深入学习知识的，另外，Dubbo的Github 地址：https://github.com/apache/incubator-dubbo 。 2.什么是DubboDubbo 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。简单来说 Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题，现在明白了实习公司有些接口是调用其他平台的原因。 3.为什么要用 Dubbo? 把系统拆分成很多的服务，每个人负责一个服务，大家的代码都没有冲突，服务可以自治，自己选用什么技术都可以，每次发布如果就改动一个服务那就上线一个服务好了，不用所有人一起联调，每次发布都是几十万行代码，甚至几百万行代码了。可以参考why use dubbo 现在越来越多项目都是面向服务编程，即SOA，把工程按照业务逻辑拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。 如果你要开发分布式程序，你也可以直接基于 HTTP 接口进行通信，但是为什么要用 Dubbo呢？ 负载均衡——同一个服务部署在不同的机器时该调用那一台机器上的服务。 服务调用链路生成——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。 服务访问压力以及时长统计、资源调度和治理——基于访问压力实时管理集群容量，提高集群利用率。 服务降级——某个服务挂掉之后调用备用服务。 4. Dubbo架构图图片来自官方文档 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送 变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 5. Dubbo工作原理及流程图中从下至上分为十层，各层均为单向依赖，右边的黑色箭头代表层之间的依赖关系，每一层都可以剥离上层被复用，其中，Service 和 Config 层为 API，其它各层均为 SPI。 第一层：service层，接口层，给服务提供者和消费者来实现的 第二层：config层，配置层，主要是对dubbo进行各种配置的 第三层：proxy层，服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton 第四层：registry层，服务注册层，负责服务的注册与发现 第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务 第六层：monitor层，监控层，对rpc接口的调用次数和调用时间进行监控 第七层：protocol层，远程调用层，封装rpc调用 第八层：exchange层，信息交换层，封装请求响应模式，同步转异步 第九层：transport层，网络传输层，抽象mina和netty为统一接口 第十层：serialize层，数据序列化层，网络传输需要 工作流程：第一步：provider 向注册中心去注册第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务第三步：consumer 调用 provider第四步：consumer 和 provider 都异步通知监控中心 注册中心挂了可以继续通信，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。 6.Dubbo的负载均衡策略 random loadbalance默认情况下，dubbo 是 random load balance ，即随机调用实现负载均衡，可以对 provider 不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。 roundrobin loadbalance这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。 leastactive loadbalance这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求。 consistanthash loadbalance一致性 Hash 算法，相同参数的请求一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。 7.Dubbo 集群容错策略ailover cluster 模式失败自动切换，自动重试其他机器，默认就是这个，常见于读操作。（失败重试其它机器） 可以通过以下几种方式配置重试次数： &lt;dubbo:service retries=\"2\" /> 或者 &lt;dubbo:reference retries=\"2\" /> 或者 &lt;dubbo:reference> &lt;dubbo:method name=\"findFoo\" retries=\"2\" /> &lt;/dubbo:reference> failfast cluster 模式一次调用失败就立即失败，常见于非幂等性的写操作，比如新增一条记录（调用失败就立即失败） failsafe cluster 模式出现异常时忽略掉，常用于不重要的接口调用，比如记录日志。 配置示例如下： &lt;dubbo:service cluster=\"failsafe\" /> 或者 &lt;dubbo:reference cluster=\"failsafe\" /> failback cluster 模式失败了后台自动记录请求，然后定时重发，比较适合于写消息队列这种。 forking cluster 模式并行调用多个 provider，只要一个成功就立即返回。常用于实时性要求比较高的读操作，但是会浪费更多的服务资源，可通过 forks=”2” 来设置最大并行数。 broadcacst cluster逐个调用所有的 provider。任何一个 provider 出错则报错（从2.1.0 版本开始支持）。通常用于通知所有提供者更新缓存或日志等本地资源信息。 8.zookeeper宕机与dubbo直连的情况zk经常作为Dubbo 的注册中心，zk后面也会继续深入学习。。在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种提现。 dubbo的健壮性表现： 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。所以，我们可以完全可以绕过注册中心——采用 dubbo 直连 ，即在服务消费方配置服务提供方的位置信息。 &lt;dubbo:reference id=\"userService\" interface=\"com.zzt.malll.service.UserService\" url=\"dubbo://localhost:20880\" 9.其他问题 如何基于 dubbo 进行服务治理、服务降级、失败重试以及超时重试？ 如何自己设计一个类似 Dubbo 的 RPC 框架？ dubbo 的 spi 思想是什么？ 以上就是我对 Dubbo 的入门总结，多总结，多回来看，知识才会一直记得，以后有时间抽空继续写博客hhhhh。","categories":[{"name":"框架","slug":"框架","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/框架/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Dubbo/"}]},{"title":"计算机网络知识总结","slug":"计算机网络学习笔记","date":"2019-06-12T10:25:08.000Z","updated":"2019-09-30T14:11:42.591Z","comments":true,"path":"2019/06/12/ji-suan-ji-wang-luo-xue-xi-bi-ji/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/06/12/ji-suan-ji-wang-luo-xue-xi-bi-ji/","excerpt":"","text":"最近这两星期抽空来看看计算机网络相关的知识，虽然大三上学期有学这门课，但是很快就忘了，记忆不是很深，现在再重温一下。 计算机网络概述： 通信：计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。 分层：分层的方法可以是7层、5层、4层。（了解每层什么作用）物理层： 物理层确保原始的数据可在各种物理媒体上传输，即传输数据比特流。 根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 数据链路层 帧：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。 数据链路层使用的信道主要有以下两种类型： 点对点信道。这种信道使用一对一的点对点通信方式。 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 数据链路层功能： 封装成帧 透明传输 差错检测(循环冗余检验（CRC）) MAC 地址:MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 以太网：以太网采用的协议是具有冲突检测的载波监听多点接入CSMA/CD。协议的特点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。 交换机：交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 网络层 IP数据报： IP地址：IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符，用来定位网络中的计算机和网络设备；IP 地址用 32 位二进制来表示， 也就是32 比特， 换算成字节， 就 是 4 个字节。例如一个采用二进制形式的 IP 地址是10101100 00010000 00011110 00111000 ， 这么长的地址， 处理起来太费劲。于是这些位被分割为4 个部分， 每一部分8位二进制， 中间使用符号 .分开 ，上面的 IP 地址可以表示为172.16.30.56。 子网掩码子网掩码 ( Subnet Mask) 又叫网络掩码、地址掩码，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码只有一个作用，就是将某个IP 地址划分成网络地址和主机地址两部分。例如: 计算机的 IP 地址是 131.107.41.6, 子网掩码是 255.255.0.0, 计算机所在网段是131.107.0.0。该计算机和远程计算机通信 ，目标 IP 地址只要前面两部分是 131.107就认为和 该计算机在同一个网段； IP地址分类： A类地址: 网络地址最高位是 0 的地址为 A 类地址 B类地址: 网络地址最高位是10的地址为B类地址 C类地址: 网络地址最高位是110的地址为C类地址 CIDR(无分类域间路由选择):无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。 子网划分：子网划分就是将一个网段等分成多个网段，也就是等分成多个子网。需要：确定子网掩码的长度；确定子网中第一个可用的IP地址和最后一个可用的IP地址； 网络层的四个主要的协议: ARP（地址解析协议）：网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。ARP完成主机或路由器IP地址到MAC地址的映射。 ICMP（网际控制报文协议 ）：ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会(桥梁作用)。它封装在 IP 数据报中，但是不属于高层协议。主要有两种: ICMP差错报文、ICMP询问报文。Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 传输层网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。 UDPUDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。UDP的主要特点：①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和） TCPTCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP的主要特点是：①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流 TCP 三次握手三次握手原因、为什么需要三次握手（可参考cyc和JavaGuide相关博客） TCP 四次挥手 TCP 协议如何保证可靠传输 超时重传 流量控制 拥塞控制 ARQ协议 ARQ协议停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 TCP 滑动窗口发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。 TCP 流量控制所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复 慢开始：由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。 拥塞避免：让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1. 快重传与快恢复：能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 应用层 DNS： DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在下面两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 FTP： FTP是基于客户/服务器(C/S) 的协议。用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照 FTP 协议提供服务，进行文件传送的计算机就是 FTP 服务器。 连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。 FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。数据连接：用来传送一个文件数据。 电子邮件：电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。 一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 HTTP长连接 短连接： 在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码： Connection:keep-alive在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 在浏览器中输入url地址 到 显示主页的过程： DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 在实习的课余时间，花了两周时间总算看完了计算机网络，深有体会，回头还得多看看，免得遗忘，推荐几个大佬的博客，总结的很详细，复习可参考： CyC JavaGuide—计算机网络 ZXBlog","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/计算机网络/"}]},{"title":"LeetCode中有关哈希表问题","slug":"LeetCode中有关哈希表问题","date":"2019-06-02T10:25:08.000Z","updated":"2019-09-30T14:10:18.446Z","comments":true,"path":"2019/06/02/leetcode-zhong-you-guan-ha-xi-biao-wen-ti/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/06/02/leetcode-zhong-you-guan-ha-xi-biao-wen-ti/","excerpt":"","text":"对LeetCode中几道关于哈希表问题进行总结： 1.两数之和题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]解题思路：经典的LeetCode第一题，刚刷LeetCode时开始刷的第一道!!，刚开始时用两个for循环暴力解决，时间复杂度大，这次用哈希表，一次遍历即可完成，速度和空间都比较好。使用HashMap存储数组元素和索引，然后进行遍历判断map中是否存在target-nums[i]，若存在，则返回就是，若不存在，则往map添加相应的键值。方法的时间复杂度为 O(N)，空间复杂度为 O(N)。 class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer> map = new HashMap&lt;>(); for (int i = 0; i &lt;nums.length; i++) { if (map.containsKey(target - nums[i])){ return new int[]{map.get(target - nums[i]),i}; } else { map.put(nums[i],i); } } return new int[]{}; } } 217. 存在重复元素题目描述：给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 输入: [1,1,1,3,3,4,3,2,4,2] 输出: true 输入: [1,2,3,4] 输出: false解题思路：方法一：利用Set里面包含的元素不重复的性质来解题。时间复杂度：O（N），空间复杂度：O（N） class Solution { public boolean containsDuplicate(int[] nums) { Set&lt;Integer> set = new HashSet&lt;>(); for (int num : nums) { set.add(num); } return set.size() &lt; nums.length; } } 方法二：可以先对其进行排序，然后再判断，这样时间和空间都稍微快点时间复杂度：O（N lg N），内存：O（1） class Solution { public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 1; i++) { if (nums[i] == nums[i+1]) { return true; } } return false; } } 594. 最长和谐子序列题目描述：和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。 现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。 输入: [1,3,2,2,5,2,3,7] 输出: 5 原因: 最长的和谐数组是：[3,2,2,2,3].解题思路：利用map API中的 getOrDefault 方法对每个数字先进行频率统计，然后再用 keySet 遍历map，若包含i + 1的话，则有和谐子序列。要掌握map中对这三个方法的运用。 boolean containsKey(Object key) Set keySet() default V getOrDefault(Object key,V defaultValue) 若存在key，则返回map.get(key)的值，若不存在，则返回defaultValue 的值。class Solution { public int findLHS(int[] nums) { Map&lt;Integer,Integer> map = new HashMap&lt;>(); for (int i : nums) { map.put(i,map.getOrDefault(i,0)+1); //统计每个数字出现次数 } int longest = 0; for (int i : map.keySet()) { if (map.containsKey(i+1)) { //如果有和谐子序列 longest = Math.max(longest,map.get(i+1) + map.get(i)); } } return longest; } } 关于哈希这类题目，要多熟悉HashMap 和 HashSet 的API，熟悉各种方法的运用。也要注意有些方法是有区别的，比如 Set中的contains() 和 Map 中的 containKeys(); SET 常用API：Map 常用API：","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/哈希表/"}]},{"title":"进程调度、同步、通信","slug":"计算机操作系统学习（二）进程的调度、同步、通信、死锁","date":"2019-05-21T10:25:08.000Z","updated":"2019-09-30T13:59:13.746Z","comments":true,"path":"2019/05/21/ji-suan-ji-cao-zuo-xi-tong-xue-xi-er-jin-cheng-de-diao-du-tong-bu-tong-xin-si-suo/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/21/ji-suan-ji-cao-zuo-xi-tong-xue-xi-er-jin-cheng-de-diao-du-tong-bu-tong-xin-si-suo/","excerpt":"","text":"进程的调度、同步、通信进程的组成 PCB(进程控制块): 为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（Process Control Block）。它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。PCB是进程存在的唯一标识，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 程序段: 存放执行的代码； 数据段: 存放程序运行过程中处理的各种数据； 进程的特征 动态性：进程是程序的一次执行过程，动态产生、变化和灭亡的。 并发性：内存中各进程可并发执行。 独立性：进程是系统进行资源分配、调度的独立单位。 异步性：个进程以不可预知速度向前推进，导致运行结果的不确定性。 结构性：每个进程都有一个PCB，进程由PCB、程序段、数据段组成。 进程的状态与转换进程三种基本状态： 运行：占有CPU，并在CPU上运行 就绪：已经具备运行条件，但是没有空闲CPU 阻塞：因等待某一事件而暂时不能运行注意： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态； 而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态； 进程只能自己阻塞自己，因为只有进程自身才知道何时需要等待某种事件的发生； 线程概念：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，线程的并发执行使得在浏览器可以打开一个窗口后继续响应其他事件，QQ可以同时发信息和上传文件。 实现方式： 用户级线程把整个线程包放在用户空间中，内核对线程包一无所知，线程切换可以在用户态下直接完成，无需操作系统干预。在用户看来，是有多个线程，从内核角度考虑，意识不到线程存在。优点：用户线程包可以在不支持线程的操作系统上实现。 内核级线程内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都由内核负责，因此，内核级线程的切换需要在核心态才能完成。优点：内核线程不需要任何新的、非阻塞系统调用，如果某个进程中的线程引起了页面故障，内核可以很方便检查该进程是否有任何其他可运行的线程。缺点：系统调用代价比较大。 两者混合在同时支持用户级线程和内核级线程的系统中，采用两者组合的方式，将n个用户级线程映射到m个内核级线程上(n &gt;=m)，大大提高了灵活度。在这种方法中，内核只识别内核级线程，并对其进行调度，其中一些内核级线程会被多个用户级线程多路复用，每个内核级线程有一个可以轮流使用的用户及线程集合。 进程与线程的异同一个线程只能属于一个进程，但一个进程中可以有多个线程，它们共享进程资源。 拥有资源: 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源； 调度: 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销: 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信: 进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。 进程调度算法概念：操作系统管理了系统的有限资源，当有多个进程或线程同时竞争CPU时，因为资源的有限性，必须按照一定的原则选择进程（请求）来占用资源，只要有两个或更多的进程处于就绪状态，如果只有一个CPU可用，那么就必须选择下一个要运行的进程，这就是调度，其中使用的算法就是调度算法。 不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 1. 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间），有以下三种： 先来先服务 first-come first-serverd（FCFS）即按照请求的顺序进行调度，非抢占式。分析：有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 短作业优先 shortest job first（SJF）按估计运行时间最短的顺序进行调度，非抢占式。分析：长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 最短剩余时间优先 shortest remaining time next（SRTN）按估计剩余时间最短的顺序进行调度，抢占式。 2. 交互式系统交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程，抢占式。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。 优先级调度 为每个进程分配一个优先级，按优先级进行调度，抢占式和非抢占式都有。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列 如果一个进程需要执行 100 个时间片，采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，优先级从高到低，时间片从小到大，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次，抢占式。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 3. 实时系统实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步同步 互斥概念进程同步：指相互合作去完成相同的任务的进程间，由同步机构对执行次序进行协调。(在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。)；进程互斥：指多个进程在对临界资源进行访问的时候，应采用互斥方式；简单来说，同步：多个进程按一定顺序执行；互斥：多个进程在同一时刻只有一个进程能进入临界区。 信号量信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。down 和 up 操作需要被设计成原语，不可分割，保证一旦一个信号量操作开始，则在该操作完成或阻塞之前，其他进程均不允许访问该信号量，这种原子性对解决同步问题和避免竞争条件是绝对必要的。通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 使用信号量实现生产者-消费者问题问题描述：生产者、消费者共享一个初始为空、大小为n的缓冲区；只有缓冲区没满时，生产者才可以放入物品，否则必须等待；只有缓冲区不为空，消费者才可以拿走物品，否则必须等待；缓冲区属于临界资源，各进程必须互斥地访问； 分析：用信号量机制（P、V操作）实现生产者、消费者互斥、同步： semaphore mutex = 1; //互斥信号量 mutex 来控制对缓冲区的互斥访问 semaphore empty= 0; //同步信号量，表示空闲缓冲区的数量，当 empty 不为 0 时，生产者才可以放入物品 semaphore full = 0; //同步信号量，表示产品的数量，当 full 信号量不为 0 时，消费者才可以取走物品#define N 100 /*缓冲区的槽数目 */ typedef int semaphore; semaphore mutex = 1; /*控制对临界区的访问*/ semaphore empty = N; /*计数缓冲区的空槽数目 */ semaphore full = 0; /*计数缓冲区的满槽数目，即产品数量 */ void producer() { while(TRUE) { int item = produce_item(); down(&amp;empty); /*将空槽数目减1 */ down(&amp;mutex); /*进入临界区 */ insert_item(item); /*将新数据项放到缓冲区中*/ up(&amp;mutex); /*离开临界区*/ up(&amp;full); /*将满槽数目加1*/ } } void consumer() { while(TRUE) { down(&amp;full); /*将满槽数目减1 */ down(&amp;mutex); /*进入临界区 */ int item = remove_item(); /*从缓冲区中取出数据项 */ consume_item(item); /*处理数据项*/ up(&amp;mutex); /*离开临界区*/ up(&amp;empty); /*将空槽数目加1*/ } } 注意：不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去，出现“死锁”现象。因此：实现互斥的down（P）操作一定要在实现同步的down（P）操作之后，up（V）操作不会导致进程阻塞，因此两个V操作顺序可以交换。 生产者消费者问题分析： 关系分析：找出各个进程，分析它们之间同步、互斥关系； 根据各进程操作流程确定P、V操作的大致顺序； 设置信号量，并确定信号量初值；通常互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少。 类似的经典同步问题还有： 1. 读者-写者问题：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。互斥关系：写进程——写进程、写进程——读进程、读进程与读进程不存在互斥问题。 一个整型变量 count 记录在对数据进行读操作的进程数量一个互斥量 count_mutex 用于对 count 加锁（防止两个读进程并发执行，这样两个进程先后执行down(&amp;data_mutex)，从而使第二个线程阻塞）一个互斥量 data_mutex 用于对读写的数据加锁，保证对文件的互斥访问。 typedef int semaphore; semaphore count_mutex = 1; semaphore data_mutex = 1; int count = 0; void reader() { while(TRUE) { down(&amp;count_mutex); count++; if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; // 访问文件的读进程数-1 if(count == 0) up(&amp;data_mutex); // 最后一个进程负责解锁 up(&amp;count_mutex); } } void writer() { while(TRUE) { down(&amp;data_mutex); write(); up(&amp;data_mutex); } } 以上这种算法潜在的问题：只要读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。 防止写进程饿死的方法:即在第一个读者到达，且一个写者在等待时，读者在写者之后被挂起，而不是立即允许进入。用这种方式，在一个写者到达时如果有正在工作的读者，那么该写者只要等待这个读者完成，而不用等候其后面到来的读者。但是该方案并发度和效率较低。 图片来自zxzxzx0119的博客 2. 哲学家进餐问题： 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子（一边一根），并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 #define N 5 // 哲学家个数 void philosopher(int i) // 哲学家编号：0 － 4 { while(TRUE) { think(); // 哲学家在思考 take_fork(i); // 去拿左边的叉子 take_fork((i + 1) % N); // 去拿右边的叉子 eat(); // 吃饭 put_fork(i); // 放下左边的叉子 put_fork((i + 1) % N); // 放下右边的叉子 } } 为了防止死锁的发生，可以设置两个条件（临界资源）： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。#define N 5 #define LEFT (i + N - 1) % N // 左邻居 #define RIGHT (i + 1) % N // 右邻居 #define THINKING 0 #define HUNGRY 1 #define EATING 2 typedef int semaphore; int state[N]; // 跟踪每个哲学家的状态 semaphore mutex = 1; // 临界区的互斥 semaphore s[N]; // 每个哲学家一个信号量 void philosopher(int i) { while(TRUE) { think(); // 思考 take_two(i); // 拿起两个筷子 eat(); put_two(i); }} void take_two(int i) { down(&amp;mutex); // 进入临界区 state[i] = HUNGRY; // 我饿了 test(i); // 试图拿两只筷子 up(&amp;mutex); // 退出临界区 down(&amp;s[i]); // 没有筷子便阻塞} void put_two(i) { down(&amp;mutex); state[i] = THINKING; test(LEFT); // 左边的人尝试 test(RIGHT); //右边的人尝试 up(&amp;mutex);} void test(i) { // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) { state[i] = EATING; up(&amp;s[i]); // 通知第i个人可以吃饭了 }} 哲学家问题关键在于解决进程死锁； 这些进程之间只存在互斥关系，但是和之前的互斥关系不同的是: 每个进程都需要同时持有两个临界资源，因此有死锁的可能； #### 管程 管程是一个由过程、变量及数据结构等组成的一个集合，他们组成一个特殊的模块或软件包。 使用用信号量机制实现的生产者消费者问题需要客户端代码做很多控制而且编程麻烦，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 ~~~ pascal monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end; end monitor;管程有基本特性： 每次只能有一个进程使用管程。这一特性使管程能有效完成互斥。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。 各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。 对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有，比如生产者发现缓冲区已满，它会在某个条件变量上如（full）执行wait操作。 signal() 操作用于唤醒被阻塞的进程。 使用管程实现生产者-消费者问题 ：一次只能有一个管程过程活跃 // 管程 monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end; end monitor; // 生产者客户端 procedure producer begin while true do begin item = produce_item; ProducerConsumer.insert(item); end end; // 消费者客户端 procedure consumer begin while true do begin item = ProducerConsumer.remove; consume_item(item); end end; 进程的通信可以参考 进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。 1.管道：管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。 特点： 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。 它只能用于父子进程之间的通信。 当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。 1 #include &lt;unistd.h> 2 int pipe(int fd[2]); // 返回值：若成功返回0，失败返回-1 2.FIFO：FIFO，也称为命名管道，它是一种文件类型，去除了管道只能在父子进程中使用的限制，FIFO可以在无关的进程之间交换数据。 FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 3. 消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 1、特点消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 4. 信号量：信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 特点： 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 支持信号量组。 5. 共享存储：特点： 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。 因为多个进程可以同时操作，所以需要进行同步。 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 总结： 管道：速度慢，容量有限，只有父子进程能通讯 FIFO：任何进程间都能通讯，但速度慢 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题 信号量：不能传递复杂消息，只能用来同步 共享内存：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存 死锁：可参考书本或者cyc死锁: 如果一个进程集合里面的每个进程都在等待只能由这个进程集合中的其他一个进程（包括他自身）才能引发的事件，那么该进程集合就是死锁的。 必要条件： 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁发生时，以上四个条件一定是同时满足的，缺一不可。 四种处理死锁策略： 鸵鸟策略 检测死锁并恢复 动态避免死锁 预防死锁产生 鸵鸟策略忽略该问题，把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。 当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 检测死锁并恢复系统并不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生时，采取措施进行恢复。 每种类型一个资源的死锁检测 每种类型多个资源的死锁检测 死锁恢复： 利用抢占恢复（将某个资源从它的当前所有者那里转移给另一个进程） 利用回滚恢复（将进程复位到一个更早的状态） 通过杀死进程恢复（最简单解决死锁方法，可以杀掉环中的一个进程） 死锁避免安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 单个资源的银行家算法：该模型基于一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 多个资源的银行家算法： 预防死锁产生破坏死锁产生必要条件，使死锁不会产生。1. 破坏互斥条件：将临界资源改造为可共享使用的资源（如SPOOLing技术）缺点：可行性不高，很多时候无法破坏互斥条件 2. 破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源，之后一直保持。 缺点：资源利用率低；可能导致饥饿 3. 破坏不可抢占条件：一种实现方式是申请的资源得不到满足时，立即释放拥有的所有资源缺点：实现复杂，反复申请和释放导致系统开销大 4. 破坏环路等待条件：给资源编号，进程必须按照编号的顺序申请资源缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦 参考书籍：《现代操作系统》","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/操作系统/"}]},{"title":"操作系统基本概念","slug":"计算机操作系统学习（一）操作系统基本概念","date":"2019-05-16T10:25:08.000Z","updated":"2019-09-30T13:58:30.748Z","comments":true,"path":"2019/05/16/ji-suan-ji-cao-zuo-xi-tong-xue-xi-yi-cao-zuo-xi-tong-ji-ben-gai-nian/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/16/ji-suan-ji-cao-zuo-xi-tong-xue-xi-yi-cao-zuo-xi-tong-ji-ben-gai-nian/","excerpt":"","text":"### 概念、特征、系统调用、中断 操作系统基本概念 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境。它是计算机系统的最基本的系统软件。 也是系统软硬资源的管理控制中心，它以尽量合理有效的方法组织多个用户（进程）共享计算机的各种资源并提供使用接口。操作系统的四个特征：1. 并发：并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统；操作系统通过引入进程和线程，使得程序能够并发运行。2. 虚拟：虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时分复用技术和空分复用技术。3. 共享：共享是指系统中的资源可以被多个并发进程共同使用；有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。4. 异步：异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进操作系统的基本功能： 进程管理(进程控制、进程同步、进程通信、死锁处理、处理机调度等) 内存管理(内存分配、地址映射、内存保护与共享、虚拟内存等) 文件管理(文件存储空间的管理、目录管理、文件读写管理和保护等) 设备管理(缓冲管理、设备分配、设备处理、虛拟设备等)系统调用：如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。Linux 的系统调用主要有以下这些： Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); #### 操作系统的运行机制： 两种指令：特权指令和非特权指令 两种处理状态：核心态（管态）和用户态（目态） 两种程序：内核程序（运行在核心态）和应用程序（运行在用户态） 特权指令：只能由操作系统使用、用户程序不能使用。例如：启动I/O，内存清零，修改程序状态字，设置时钟，允许／禁止中断，停机 非特权指令：用户程序可以使用。例如：控制转移，算术运算，访管指令，取数指令 特权指令只能在核心态下运行，内核程序只能在核心态下运行。 内核： 大内核：将操作系统的主要功能都作为系统内核，运行在核心态。缺点：由于各模块共享信息，因此有很高的性能，但是结构混乱，难以维护。 微内核：由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断：分类： 外中断: 由 CPU 执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 内中断: ①异常: 由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。②陷入: 在用户程序中使用系统调用。 用户态与核心态的转换： 中断是实现用户态到核心态的唯一途径。 核心态到用户态的切换是通过执行一个特权指令，将程序状态字(PSW)的标志位设为 “用户态”。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/操作系统/"}]},{"title":"23种设计模式","slug":"23种设计模式全","date":"2019-05-12T10:25:08.000Z","updated":"2019-09-30T13:56:45.793Z","comments":true,"path":"2019/05/12/23-chong-she-ji-mo-shi-quan/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/12/23-chong-she-ji-mo-shi-quan/","excerpt":"","text":"初学设计模式，建议可以参考菜鸟教程，里面讲的很详细，后来发现那里也是从国外的翻译过来的hhh，这里我总结一下常见的23种设计模式。 一、设计模式的六大原则：1、开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等。 2、里氏替换原则（Liskov Substitution Principle） 面向对象设计的基本原则之一，是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。在进行设计的时候,我们应该尽量从抽象类继承,而不是从具体类继承.如果从继承等树来看,所有叶子节点应当是具体类,而所有的树枝节点应当是抽象类或者接口.当然这只是一个一般性的指导原则,使用的时候还要具体情况具体分析。 3、依赖倒转原则（Dependence Inversion Principle） 这个是面向对象设计的核心原则，具体内容：针对接口编程,不针对实现编程。依赖于抽象而不依赖于具体。写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle） 每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle） 一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。即一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。 6、合成复用原则（Composite Reuse Principle） 原则一句话:是尽量首先使用合成/聚合的方式，而不是使用继承。 二、创建型模式(5种)简单工厂模式：简单工厂模式是属于创建型模式，又叫做静态工厂方法（Static Factory Method）模式，它不属于23种GOF设计模式，但是可以被认为是一种特殊的工厂方法模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有相同的父类。 应用： java.text.DateFormat 工厂方法模式：简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，在简单工厂中，创建对象的是另一个类，而在工厂方法中，工厂父类负责创建对象的公共接口，工厂子类来创建具体的对象。适用场景： 客户不需要知道要使用的对象的创建过程 客户使用的对象存在变动的可能，或者根本就不知道使用哪一个具体对象 优缺点： 一旦需要增加新的功能，直接增加具体工厂和具体产品就可以了，不需要修改之前的代码。 增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，一定程度上增加了系统复杂性。 应用： java.util.Calendar java.text.NumberFormat 抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。 适用场景： 系统中有多个产品族，而系统一次只能消费其中一族产品 同属于同一个产品族的产品一起使用 优缺点： 新增产品族很方便，只需要增加一个具体工厂即可。 但如果要增加新产品等级结构，就需要修改抽象工厂和所有具体工厂类，这种性质被称为 开闭原则 的倾斜性。 单例模式：在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。 单例模式的实现有懒汉式(线程不安全)、饿汉式(线程安全，一开始就直接实例化)，静态内部类实现等。 静态内部类实现：使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，避免出现 JVM 具有指令重排的特性。 public class Singleton { /* 私有构造方法，防止被实例化 */ private Singleton() { } /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory { private static Singleton instance = new Singleton(); } /* 获取实例 */ public static Singleton getInstance() { return SingletonFactory.instance; } /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() { return getInstance(); } 建造者模式：建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 如Java中的StringBuilder类的实现就是应用这种模式。 原型模式：原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 关键代码：实现克隆操作，在 JAVA 实现 Cloneable，重写 clone()； 优点： 性能提高。 逃避构造函数的约束。 缺点： 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 必须实现 Cloneable 接口。 三、结构型模式(7种)适配器模式：适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。如读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 方法：适配器继承或依赖已有的对象，实现想要的目标接口。 优点： 可以让任何两个没有关联的类一起运行。 提高了类的复用。 增加了类的透明度。 缺点： 过多地使用适配器，会让系统非常零乱，不易整体进行把握。 因 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 应用：java.util.Arrays#asList() 桥接模式：将抽象和实现放在两个不同的类层次中，使它们可以独立地变化。——《Head First 设计模式》 将类的功能层次结构和实现层次结构相分离，使二者能够独立地变化，并在两者之间搭建桥梁，实现桥接。—— 《图解设计模式》 我们常用的JDBC桥DriverManager就是如此，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。 组合模式：组合模式（Composite Pattern），是用于把一组相似的对象当作一个单一的对象。将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 优点： 高层模块调用简单。 节点自由增加。 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。 应用：(组合模式的使用场景就是出现树形结构的地方) 文件目录显示，多及目录呈现等树形结构数据的操作 java.util.Map#putAll(Map) java.util.List#addAll(Collection) java.util.Set#addAll(Collection) 装饰者模式：装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。要求装饰对象和被装饰对象实现同一个接口。 优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。 缺点：多层装饰比较复杂。 使用场景： 扩展一个类的功能。 动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 外观模式：外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。 优点： 减少系统相互依赖。 提高灵活性。 提高了安全性。 缺点： 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。 使用场景： JAVA 的三层开发模式。 假设一台电脑，它包含了 CPU，Memory ，Disk）这几个部件，若想要启动电脑，则先后必须启动 CPU、Memory、Disk。关闭也是如此。但是实际上我们在电脑开/关机时根本不需要去操作这些组件，因为电脑已经帮我们都处理好了，并隐藏了这些东西。这些组件好比子系统角色(一个系统的子系统或模块)，而电脑就是一个外观角色(客户端通过操作外观角色从而达到控制子系统角色的目的)。 享元模式：享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象。 优点：大大减少对象的创建，降低系统的内存，使效率提高。 缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。 应用： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库连接池，不需要每一次都重新创建连接，节省了数据库重新创建的开销。 java.lang.Integer.valueOf() 代理模式：在代理模式（Proxy Pattern）中，一个类代表另一个类的功能，我们创建具有现有对象的对象，以便向外界提供功能接口，为其他对象提供一种代理以控制对这个对象的访问。比如我们在租房子的时候回去找中介，因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。 优点： 职责清晰。 高扩展性。 智能化。 缺点： 1、客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 应用： java.lang.reflect.Proxy Spring Aop 注意： 区别适配器模式：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 区别装饰器模式：装饰器模式为了增强功能，而代理模式是为了加以控制。 四、行为型模式(11种)责任链模式：责任链模式（Chain of Responsibility Pattern），为请求创建了一个接收者对象的链。有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求。 优点： 降低耦合度。它将请求的发送者和接收者解耦。 简化了对象。使得对象不需要知道链的结构。 增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 增加新的请求处理类很方便。 缺点： 不能保证请求一定被接收。 系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 可能不容易观察运行时的特征，有碍于除错。 应用： java.util.logging.Logger.log() Apache Commons Chain javax.servlet.Filter.doFilter() Java Web 中 Apache Tomcat 对 Encoding 的处理 命令模式：命令模式（Command Pattern）把一个请求或者操作封装到一个对象中，把发出命令的责任和执行命令的责任分割开，委派给不同的对象，从使用角度来看就是请求者把接口实现类作为参数传给使用者，使用者直接调用这个接口的方法，而不用关心具体执行的那个命令。优点： 降低了系统耦合度。 新的命令可以很容易添加到系统中去。 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。 应用：java.lang.Runnable 解释器模式：解释器模式（Interpreter Pattern）实现了一个表达式接口，该接口解释一个特定的上下文。给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。优点： 可扩展性比较好，灵活。 增加了新的解释表达式的方式。 易于实现简单文法。 缺点： 可利用场景比较少。 对于复杂的文法比较难维护。 解释器模式会引起类膨胀。 解释器模式采用递归调用方法。 使用场景： 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 一些重复出现的问题可以用一种简单的语言来进行表达。 一个简单语法需要解释的场景。 迭代器模式：迭代器模式（Iterator Pattern）提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 优点： 它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。 缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 应用：Java.util.Iterator 中介者模式：中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 优点： 降低了类的复杂度，将一对多转化成了一对一。 各个类之间的解耦。 符合迪米特原则。 缺点： 中介者会庞大，变得复杂难以维护。 应用： 系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。 java.lang.reflect.Method.invoke()。 备忘录模式：备忘录模式（Memento Pattern），保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。 优点： 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。 缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。 应用： 需要保存/恢复数据的相关状态场景。 数据库事务回滚。 观察者模式：当对象间存在一对多关系时，则使用观察者模式（Observer Pattern），又叫发布-订阅模式, 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。类似于邮件订阅，当你订阅了该文章，如果后续有更新，会及时通知你。 优点： 观察者和被观察者是抽象耦合的。 建立一套触发机制。 缺点： 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 状态模式：在状态模式（State Pattern）中，类的行为是基于它的状态改变的，当对象的状态改变时，同时改变其行为，就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态。 优点： 封装了转换规则。 枚举可能的状态，在枚举状态之前需要确定状态种类。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 缺点： 状态模式的使用必然会增加系统类和对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 状态模式对”开闭原则”的支持并不太好。 使用场景： 行为随状态改变而改变的场景。 条件、分支语句的代替者。 策略模式：在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。需要定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。 优点： 算法可以自由切换。 避免使用多重条件判断。 扩展性良好。 缺点： 策略类会增多。 所有策略类都需要对外暴露。 区分状态模式：状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。 状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。 应用：java.util.Comparator.compare()javax.servlet.http.HttpServletjavax.servlet.Filter.doFilter() 模板方法模式：在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 优点： 封装不变部分，扩展可变部分。 提取公共代码，便于维护。 行为由父类控制，子类实现。 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 应用： 有多个子类共有的方法，且逻辑相同。 java.util.Collections.sort()。 访问者模式：在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 优点： 符合单一职责原则。 优秀的扩展性。 灵活性。 缺点： 具体元素对访问者公布细节，违反了迪米特原则。 具体元素变更比较困难。 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。 应用：需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。 补充： 想更清楚了解UML图的话可以参考设计模式中的类图实例 JDK中的设计模式 Spring中涉及到的设计模式 Mybatis使用的设计模式 参考资料： 《设计模式》清华大学出版社刘伟主编 菜鸟教程","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/计算机基础/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/设计模式/"}]},{"title":"LeetCode中的数学问题","slug":"LeetCode中数学问题","date":"2019-05-08T10:25:08.000Z","updated":"2019-09-30T13:52:45.998Z","comments":true,"path":"2019/05/08/leetcode-zhong-shu-xue-wen-ti/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/08/leetcode-zhong-shu-xue-wen-ti/","excerpt":"","text":"对LeetCode中的有关数学问题进行了刷题总结： 素数：204. Count Primes 题目描述：统计所有小于非负整数 n 的质数的数量。示例: 输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路：本题要使用埃拉托斯特尼筛法，这样运行不会超时。 要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。给出要筛数值的范围n，找出以内的素数。先用2去筛，即把2留下，把2的倍数剔除掉；再用下一个质数，也就是3筛，把3留下，把3的倍数剔除掉；接下去用下一个质数5筛，把5留下，把5的倍数剔除掉；不断重复下去……。 class Solution { public int countPrimes(int n) { boolean [] notPrim = new boolean[n]; int count = 0; for (int i = 2; i &lt; n; i++){ if (notPrim[i] == false) { count++; for (int j = 2; j*i &lt; n; j++) { notPrim[j*i] = true; } } } return count; } } 十六进制405. Convert a Number to Hexadecimal 题目描述：给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。 注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 Example 1: Input: 26 Output: &quot;1a&quot; Example 2: Input: -1 Output: &quot;ffffffff&quot;解题思路： 使用位运算，每4位，对应1位16进制数字。 将输入右移4位，再做一次，直到输入变为0 这里两个概念了解下： 位与(&amp;)：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0。 无符号右移：位运算符（&gt;&gt;&gt;），它使用了“零扩展”：无论正负，都在高位插入0。class Solution { public String toHex(int num) { char [] array = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; if (num == 0) { return \"0\"; } StringBuilder sb = new StringBuilder(); while (num != 0) { sb.append(array[num &amp; 15]);//使用位与 num = num >>> 4; //无符号右移，左边填0 } return sb.reverse().toString(); } } 阶乘问题172. Factorial Trailing Zeroes题目描述：给定一个整数 n，返回 n! 结果尾数中零的数量。Example 1: Input: 3Output: 0Explanation: 3! = 6, no trailing zero. Example 2: Input: 5Output: 1Explanation: 5! = 120, one trailing zero. ##### 解题思路： 首先题目的意思是末尾有几个0 比如6! = 【1* 2* 3* 4* 5* 6】， 其中只有2*5末尾才有0，所以就可以抛去其他数据 专门看2和5以及其倍数，毕竟 4 * 25末尾也是0 2肯定比5多 所以只算5的个数就行了。 对于一个数 N，它所包含 5 的个数为：N/5 + N/25 + N/75 + ...。 ~~~ java class Solution { public int trailingZeroes(int n) { return n == 0 ? 0 : n / 5 + (trailingZeroes(n / 5)); } }字符串加法减法：即两个字符串相加问题，但是不能直接转成Integer解决，解决此类问题一般思路是从右到左开始遍历两个数，如果进位就加一，这个时候就要定义一个专门存储进位的变量count。 1、字符串加法：415. Add Strings 题目描述：给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100.num1 和num2 都只包含数字 0-9.num1 和num2 都不包含任何前导零。你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路：class Solution { public String addStrings(String num1, String num2) { StringBuilder sb = new StringBuilder(); int n1 = num1.length() - 1; int n2 = num2.length() - 1; int count = 0; //表示进位数 while (count == 1 || n1 >= 0 || n2 >= 0) { int x = n1 &lt; 0 ? 0 : num1.charAt(n1--) - '0'; int y = n2 &lt; 0 ? 0 : num2.charAt(n2--) - '0'; sb.append((x + y + count) % 10); count = (x + y + count) / 10; } return sb.reverse().toString(); } } 2、二进制加法： 67. Add Binary 题目描述：给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 Example 1: Input: a = &quot;11&quot;, b = &quot;1&quot; Output: &quot;100&quot; Example 2: Input: a = &quot;1010&quot;, b = &quot;1011&quot; Output: &quot;10101&quot;解题思路：将两个数从右往左进行相加，用变量count来判断是不是往前面进一位，即进位。 class Solution { public String addBinary(String a, String b) { int aNum = a.length() - 1; int bNum = b.length() - 1; int count = 0; StringBuilder sb = new StringBuilder(); // 注意这里count==1也是条件，即当aNum和bNum都为0时向前进一时 while (count == 1 || aNum >= 0 || bNum >= 0) { if (aNum >= 0 &amp;&amp; a.charAt(aNum) == '1') { count++; } if (bNum >= 0 &amp;&amp; b.charAt(bNum) == '1') { count++; } //每次都要往前移一位 aNum--; bNum--; sb.append(count % 2); count = count / 2; } return sb.reverse().toString(); } } 数组中出现次数多于 n / 2 的元素：169. Majority Element 题目描述：给定大小为n的数组，找到多数元素。 多数元素是出现超过⌊n /2⌋倍的元素。您可以假设该数组非空，并且多数元素始终存在于数组中。 Example 1: Input: [3,2,3] Output: 3 Example 2: Input: [2,2,1,1,1,2,2] Output: 2解题思路：1、可以先对数组排序，最中间那个数出现次数一定多于 n / 2。 class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return (nums[nums.length / 2]); } } 2、使用 摩尔投票算法。那么我们就先从数组的第一个元素开始，假定它代表的群体的人数是最多的，那么根据数组中出现次数超过一半的数只有一个的特质，如果我们设置一个计数器count，在遍历时遇到不同于这个群体的人时就将计数器-1，遇到同个群体的人时就+1，只要在计数器归0时就重新假定当前元素代表的群体为人数最多的群体再继续遍历，那么到了最后，计数器记录的那个群体必定是人最多的那个群体。这里就使得元素排序是不会造成任何影响的，只关心元素的个数所带来的对于计数器+1或-1的影响。 class Solution { public int majorityElement(int[] nums) { int count = 0, majority = 0; for (int num : nums) { if (count == 0) { majority = num; } if (num != majority) { count--; } else { count++; } } return majority; } } 相遇问题：462. Minimum Moves to Equal Array Elements II 题目描述：给定一个非空整数数组，找出使所有数组元素相等所需的最小移动数，其中移动使选定的元素递增1或递减1。您可以假设数组的长度最多为10,000。 Input: [1,2,3] Output: 2 Explanation: Only two moves are needed (remember each move increments or decrements one element): [1,2,3] =&gt; [2,2,3] =&gt; [2,2,2]解题思路：典型相遇问题，移动距离最小的方式是所有元素都移动到中位数。另外本题也属于求TopK问题，也可以用基于切分的快速选择算法，也可以用优先队列来解决，最重要是要知道什么情况下移动距离才是最小的。 class Solution { public int minMoves2(int[] nums) { Arrays.sort(nums); int move = 0; int l = 0, h = nums.length - 1; while (l &lt;= h) { move = move + nums[h] - nums[l]; l++; h--; } return move; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[]},{"title":"LeetCode中BFS&DFS","slug":"BFS","date":"2019-05-02T10:25:08.000Z","updated":"2019-09-10T09:52:30.929Z","comments":true,"path":"2019/05/02/bfs/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/05/02/bfs/","excerpt":"","text":"深度优先遍历DFS： 假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 DFS应用：使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解 单点连通性、单点可达性、单点路径等。 实现：使用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。也可以用递归。 LeetCode相关题解：695. Max Area of Island给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]]对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路:使用dfs计算每个岛屿的面积，在dfs期间，将岛中每个点的值设置为0，表示为已标记。 /* *使用DFS，先用二维数组存储四个方向，然后分别递归遍历每个点 *遍历过的点将其置为0，不再遍历 */ class Solution { private int m, n; private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};//四个方向 public int maxAreaOfIsland(int[][] grid) { m = grid.length;//行 n = grid[0].length;//列 int maxArea = 0; if (m == 0 || grid == null) { return 0; } for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { maxArea = Math.max(maxArea,dfs(grid,i,j)); } } return maxArea; } private int dfs(int [][] grid,int i,int j){ if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || grid[i][j] == 0) { return 0; } grid[i][j] = 0;//设为已标记 int area = 1; for (int [] d : direction) { area += dfs(grid,i + d[0],j + d[1]); } return area; } } 200. Number of Islands 给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3解题思路：本题跟上面leetcode695有点类似，都是岛屿问题，可以将矩阵表示看成一张有向图，把问题转换为对每个点进行DFS遍历，如果有遍历完一个，那么岛屿数量+1 class Solution { private int directions[][] = {{0,1},{0,-1},{1,0},{-1,0}}; private int m , n; public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } m = grid.length; n = grid[0].length; int num = 0;//岛屿数量 for (int i = 0;i &lt; m;i++) { for (int j = 0;j &lt; n;j++) { if (grid[i][j] != '0') { dfs(grid,i,j); num++; } } } return num; } private void dfs(char [][] grid,int i,int j){ if(i >= m || i &lt; 0 || j >= n || j &lt; 0 || grid[i][j] =='0'){ return; } grid[i][j] = '0';//遍历过的不再遍历 for(int d[] : directions){ dfs(grid,i + d[0],j + d[1]); } } } 547. Friend Circles班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1解题思路： DFS中的朋友圈问题，注意这是个N*N矩阵，可以使用一个hasVisited数组, 依次判断每个节点, 如果其未访问, 朋友圈数加1并对该节点进行dfs搜索标记所有访问到的节点。 class Solution { private int m; //N*N矩阵 public int findCircleNum(int[][] M) { if (M.length == 0 || M == null) { return -1; } m = M.length; boolean [] hasVisited = new boolean[m]; //是否访问 int circleNum = 0; for (int i = 0; i &lt; m; i++) { if (!hasVisited[i]) { dfs(M,i,hasVisited); circleNum++; } } return circleNum; } private void dfs(int [][] M,int i,boolean [] hasVisited) { hasVisited[i] = true; for (int k = 0; k &lt; m; k++) { if (M[i][k] == 1 &amp;&amp; !hasVisited[k]) dfs(M,k,hasVisited); } } } 207. Course Schedule现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 输入: 2, [[1,0]] 输出: true 解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 输入: 2, [[1,0],[0,1]] 输出: false 解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。解题思路：构建逆邻接表，实现深度优先遍历，其实就是检测这个有向图中有没有环，只要存在环，课程就不能完成。另外，当访问一个结点的时候，应该递归访问它的前驱结点，直至前驱结点没有前驱结点为止。 /** *采用深度优先遍历解决有无环 *如果采用BFS会更快 **/ class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { List&lt;Integer> [] graphic = new List[numCourses]; boolean [] marked = new boolean[numCourses];//判断那个数是否被标记 for (int i = 0;i &lt; numCourses;i++){ graphic[i] = new ArrayList();//对每个数字生成一个链表 } for (int [] pre : prerequisites){ graphic[pre[0]].add(pre[1]); } for (int i = 0;i &lt; numCourses;i++){ if(hasCycle(graphic,marked,i)){ return false; } } return true; } //判断是否含环 private boolean hasCycle(List&lt;Integer> [] graphic,boolean [] marked,int cur){ if (marked[cur]){ return true;//如果被标记，则直接返回true } marked[cur] = true; for (int next : graphic[cur]){ if (hasCycle(graphic,marked,next)){ return true; } } marked[cur] = false; return false; } } 130. Surrounded Regions给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。示例: X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为： X X X XX X X XX X X XX O X X解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路：首先对矩阵边界上所有的O做深度优先搜索，将相连的O更改为 * ，然后编辑数组，将数组中O更改为X，将数组中 * 更改为O。 class Solution { private int m,n; private int [] [] directions = {{0,1},{0,-1},{1,0},{-1,0}}; public void solve(char[][] board) { if (board == null || board.length == 0){ return; } m = board.length; n = board[0].length; //边界值遍历 for (int i = 0; i &lt; m; i++) { dfs(board, i, 0); dfs(board, i, n-1); } for (int j = 0; j &lt; n; j++) { dfs(board, 0, j); dfs(board, m - 1, j); } for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++){ if(board[i][j] == 'O') { board [i][j] = 'X'; //将被包围在中间的置为X }else if (board[i][j] == '*'){ board [i][j] = 'O'; //将边界的置为O } } } } private void dfs(char [][] board, int i, int j) { if (i &lt; 0 || i >= m || j &lt; 0 || j >= n || board[i][j] != 'O'){ return; } board[i][j] = '*'; //将被包围的O，并且O不在边界 置为其他符号 for (int [] d: directions) { dfs(board, i + d[0],j + d[1]); } } } 总结：通过刷题知道DFS类型的解题思路，大概有岛屿问题，朋友圈问题，此时解题模板也是类似的，用递归遍历，遍历过了点设为已标记。 广度优先遍历BFS： 广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。需要注意，遍历过的节点不能再次被遍历。 BFS应用：BFS可用于解决2类问题： 从A出发是否存在到达B的路径；从A出发到达B的最短路径(这个应该叫最少步骤合理，第一次遍历到目的节点，其所经过的路径为最短路径)；注意，使用 BFS 只能求解无权图的最短路径。 实现：使用队列来存储每一轮遍历得到的节点,对于遍历过的节点，应该将它标记，防止重复遍历。 典例：计算在网格中从原点到特定点的最短路径长度 [[1,1,0,1],[1,0,1,0],[1,1,1,1],[1,0,1,1]] 1 表示可以经过某个位置，求解从 (0, 0) 位置到 (tr, tc) 位置的最短路径长度。 由于每个点需要保存x坐标，y坐标以及长度，所以必须要用一个类将三个属性封装起来。 由于bfs每次只将距离加一，所以当位置抵达终点时，此时的距离就是最短路径了。 private static class Position { int r, c, length; public Position(int r, int c, int length) { this.r = r; this.c = c; this.length = length; } } public static int minPathLength(int[][] grids, int tr, int tc) { int[][] next = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; int m = grids.length, n = grids[0].length; Queue&lt;Position> queue = new LinkedList&lt;>(); queue.add(new Position(0, 0, 1)); while (!queue.isEmpty()) { Position pos = queue.poll(); for (int i = 0; i &lt; 4; i++) {//4是数组next的长度 Position nextPos = new Position(pos.r + next[i][0], pos.c + next[i][1], pos.length + 1); if (nextPos.r &lt; 0 || nextPos.r >= m || nextPos.c &lt; 0 || nextPos.c >= n) continue; if (grids[nextPos.r][nextPos.c] != 1) continue; grids[nextPos.r][nextPos.c] = 0; if (nextPos.r == tr &amp;&amp; nextPos.c == tc) return nextPos.length; queue.add(nextPos); } } return -1; } LeetCode相关题解：279. Perfect Square(Medium) 题目描述：给定一个正整数n，求和为n的最小全平方数（例如，1，4，9，16，…）。Input: n = 12Output: 3Explanation: 12 = 4 + 4 + 4. Input: n = 13Output: 2Explanation: 13 = 4 + 9. 解题思路: 思路来源参考@CyC2018Leetcode刷题题解 可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。 要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。 首先生成平方数序列放入数组，然后通过队列，每次减去一个平方数，把剩下的数加入队列，也就是通过bfs的方式，当此时的数刚好等于平方数，则满足题意，由于每次循环level加一，所以最后输出的level就是需要的平方数个数 class Solution { public int numSquares(int n) { List&lt;Integer> squares = getSquares(n);//获取所有平方数，存在链表中 Queue&lt;Integer> queue = new LinkedList&lt;>(); boolean[] marked = new boolean[n + 1];//这里是n+1，比较好计算 queue.add(n); marked[n] = true; int level = 0;//level为第几层 while(!queue.isEmpty()){ int size = queue.size(); level++; while(size-- > 0){ int top = queue.poll(); for(int s : squares){ if (top - s==0){ return level; } if (top - s &lt; 0){ break; } if (marked[top - s]){ continue; } marked[top - s] =true;//标记为true的不再遍历 queue.add(top - s); } } } return n; } //先定义一个求小于n的所有平方数的方法 private List getSquares(int n){ List&lt;Integer> list = new ArrayList&lt;>(); int square = 1; int i = 3; while (square &lt;= n){ list.add(square); square += i; i += 2; } return list; } } ```","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BFS&DFS","slug":"BFS-DFS","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BFS-DFS/"}]},{"title":"校园商铺O2O小结","slug":"校园商铺平台1.0学习","date":"2019-04-28T10:25:08.000Z","updated":"2019-09-30T14:07:42.056Z","comments":true,"path":"2019/04/28/xiao-yuan-shang-pu-ping-tai-1.0-xue-xi/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/28/xiao-yuan-shang-pu-ping-tai-1.0-xue-xi/","excerpt":"","text":"做完校园商铺平台O2O小项目1.0，项目来源慕课网，记录一下平时遇到的问题🤔： 项目简介：项目1.0中使用SSM技术快速迭代出版校园商铺1.0；同时包含MySQL主从同步实现读写分离，利用SUI Mobile快速实现响应式页面，Redis缓存，数据库加密配置，部署上线等实用技术点。 数据库设计：数据库表的总体结构如下：注意： 微信账号和本地账号是通过用户信息表中的user_id进行关联的，实现本地账号和微信账号的绑定。 店铺信息表跟以下四个表的关联： 商品信息表通过product_category_id跟商品类别表关联，通过product_id跟详情图片表进行关联Logback日志框架：本项目中使用Logback日志框架，Logback 是 Slf4j 的原生实现框架，同样也是出自 Log4j 一个人之手，但拥有比 log4j 更多的优点、特性和更做强的性能，现在基本都用来代替 log4j 成为主流。 Thumbnailator图片处理：GitHub链接地址Thumbnailator是一个用来生成图像缩略图的 Java类库，可生成图片缩略图，支持根据一个目录批量生成缩略图，支持图片缩放，区域裁剪，水印，旋转，保持比例等等。注意：需要封装工具类。 DTO及相关枚举类：Data Transfer Object，即数据传送对象 。 DTO是一个普通的Java类，它封装了要传送的批量的数据。当客户端需要读取服务器端的数据的时候，服务器端将数据封装在DTO中，这样客户端就可以在一个网络调用中获得它需要的所有数据。 Shop实体类包含了Shop的基本属性，但是在前端操作时，我们希望可以返回操作的结果等信息，这个时候Shop实体类就不能满足需求了，我们将操作结果和Shop等信息统一放到DTO中处理，即可满足当前的需求。 DTO类ShopExecution： package com.artisan.o2o.dto; import java.util.List; import com.artisan.o2o.entity.Shop; import com.artisan.o2o.enums.ShopStateEnum; /* *DTO中还要包含操作商铺的返回结果,单个的实体类无法满足，所以封装到dto中，便于操作 */ public class ShopExecution { private int state ; private String stateInfo; private int count; private Shop shop; /** * 店铺集合 (查询店铺列表的时候用) */ private List&lt;Shop> shopList; //构造函数,店铺操作失败的时候使用的构造函数 public ShopExecution(ShopStateEnum shopStateEnum) { this.state = shopStateEnum.getState(); this.stateInfo = shopStateEnum.getStateInfo(); } //构造函数,店铺操作成功的时候使用的构造函数 public ShopExecution(ShopStateEnum stateEnum, Shop shop) { this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); this.shop = shop; } //构造函数,店铺操作成功的时候使用的构造函数 public ShopExecution(ShopStateEnum stateEnum, List&lt;Shop> shopList) { this.state = stateEnum.getState(); this.stateInfo = stateEnum.getStateInfo(); this.shopList = shopList; } public int getState() { return state; } public void setState(int state) { this.state = state; } public String getStateInfo() { return stateInfo; } public void setStateInfo(String stateInfo) { this.stateInfo = stateInfo; } public int getCount() { return count; } public void setCount(int count) { this.count = count; } public Shop getShop() { return shop; } public void setShop(Shop shop) { this.shop = shop; } public List&lt;Shop> getShopList() { return shopList; } public void setShopList(List&lt;Shop> shopList) { this.shopList = shopList; } } 枚举类：使用枚举表述常量数据字典。例如为商品状态定义一个枚举类ShopStateEnum类。 package com.zzt.o2o.enums; public enum ShopStateEnum { CHECK(0, \"审核中\"), OFFLINE(-1, \"非法店铺\"), SUCCESS(1, \"操作成功\"), PASS(2, \"审核通过\"), INNER_ERROR(-1001, \"操作失败\"), NULL_SHOPID(-1002, \"ShopId为空\"), NULL_SHOP_INFO(-1003, \"传入了空的信息\"); private int state; private String stateInfo; private ShopStateEnum(int state, String stateInfo) { this.state = state; this.stateInfo = stateInfo; } public int getState() { return state; } public String getStateInfo() { return stateInfo; } // 定义换成pulic static 暴漏给外部,通过state获取ShopStateEnum public static ShopStateEnum stateOf(int state) { for (ShopStateEnum stateEnum : values()) { if(stateEnum.getState() == state){ return stateEnum; } } return null; } } 验证码kaptcha组件：GitHub地址：https://github.com/penggle/kaptcha Kaptcha是基于SimpleCaptcha的开源项目。通过调整Kaptcha配置可以生成各种样式的验证码。 Kaptcha提供的功能如下： 验证码的字体 验证码字体的大小 验证码字体的字体颜色 验证码内容的范围 验证码图片的大小，边框，边框粗细，边框颜色 验证码的干扰线 验证码的样式 jackson的使用使用jackson将前端传过来的json数据格式转换为对应的pojoGitHub：https://github.com/FasterXML/jackson-databind 商铺注册设置图片：我的数据库中存储的并不是全部路径，而是部分路径，因此在传给前端路径时并不完全，因此我们在tomcat的server.xml文件中配置，解决方案： 在idea不想es直接更改，打开tomca文件夹找到server.xml文件在最后设置一个，意思相当于当我们遇到第一个参数的路径时转第二个路径就是当遇到/A就转为/A/B/C/这种 商铺编辑Sql中可将重复的sql提取出来，使用时用include引用即可，最终达到sql重用的目的 注意：如果引用其它mapper.xml的sql片段，则在引用时需要加上namespace，如下：&lt;include refid=”namespace.sql片段”/&gt; 商铺列表列表页面需要支持分页 (MySql数据库，我们使用limit关键字)在dao层：分页是这样的：我们接受的是limit start，size （start从0开始），在mapper文件中只能指定相应的从某行到某行， 从前端却只能传来页数和页数大小，因此我们需要一个页数转为记录条数的记录。我们在Util类中写入一个方法，参数接受页数行页数大小，通过将页数减1乘上页数大小，就是我们要索引的这一页的所有记录。 商品类别在删除商品类别时需要先将该商品目录下的商品的类别Id置为空，然后再删除该商品目录。 商品编辑商品信息有商品缩略图和详情图片，我们约定好：如果用户传入了新的商品缩略图和详情图片，就将原有的商品缩略图和详情图片删除掉。 Redis使用：加入缓存的配置步骤 pom.xml 添加jedis依赖包 redis配置文件 spring-dao.xml加载redis.properties 封装JedisPool,用于创建JedisPool 封装操作redis的工具类 JedisUtil 新建spring-redis.xml 配置redis连接池和bean web.xml中加载spring-redis.xml Service层使用缓存 根据数据的特点，不经常变动的数据 即时性要求没有那么高的读数据 为了减轻DB压力，我们可以将数据放到缓存中。目前我们需要将区域信息、商铺分类信息和头条信息放入到redis中。因为这些数据不怎么变化。同时注意需要将这些数据分类存储在redis中。比如头条广告那里有区分是否可以放上去，即状态码商品分类那里是否有子目录。 对信息数据加密使用 DES 对数据库的用户名和密码进行加密。DES是一种对称加密算法。步骤： DES工具类 修改配置文件中即jdbc.properties 中的用户名和密码 继承PropertyPlaceholderConfigurer，重写convertProperty方法 配置自定义的EncryptPropertyPlaceholderConfigurer 使用 MD5 加密算法 对用户信息进行加密。 SpringMVC 拦截器 对非法路径进行拦截，确保一个店家只能在一个店铺上进行商铺编辑，商品管理等。 ShopPermissionInterceptor类： package com.zzt.o2o.interceptor.shopadmin; import java.util.List; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import com.zzt.o2o.entity.Shop; /** * 商家不能去操纵不属于它管理的店铺 * @author zhan * */ public class ShopPermissionInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Shop currentShop = (Shop) request.getSession().getAttribute( \"currentShop\"); @SuppressWarnings(\"unchecked\") //从session中获取当前用户可操作的店铺列表 List&lt;Shop> shopList = (List&lt;Shop>) request.getSession().getAttribute( \"shopList\"); if (currentShop != null &amp;&amp; shopList != null) { for (Shop shop : shopList) { //如果当前店铺在可操作的列表则返回true，进行接下来的用户操作 if (shop.getShopId() == currentShop.getShopId()) { return true; } } } //不满足返回false return false; } } 如果路径非法（没有经过登录）直接访问路径名，也将跳到登录界面。 ShopLoginInterceptor类： package com.zzt.o2o.interceptor.shopadmin; import java.io.PrintWriter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.web.servlet.handler.HandlerInterceptorAdapter; import com.zzt.o2o.entity.PersonInfo; /** * 店家管理系统登录验证拦截器 * @author zhan * */ public class ShopLoginInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object userObj = request.getSession().getAttribute(\"user\"); if (userObj != null) { PersonInfo user = (PersonInfo) userObj; if (user != null &amp;&amp; user.getUserId() != null &amp;&amp; user.getUserId() > 0 &amp;&amp; user.getEnableStatus() == 1) return true; } //若不满足登录验证，则直接跳转到账号登录页面 PrintWriter out = response.getWriter(); out.println(\"&lt;html>\"); out.println(\"&lt;script>\"); out.println(\"window.open ('\" + request.getContextPath()+ \"/local/login?usertype=2','_self')\"); out.println(\"&lt;/script>\"); out.println(\"&lt;/html>\"); return false; } }","categories":[{"name":"小项目","slug":"小项目","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/小项目/"}],"tags":[{"name":"O2O","slug":"O2O","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/O2O/"}]},{"title":"LeetCode中常见的链表题目","slug":"链表","date":"2019-04-28T07:45:28.000Z","updated":"2019-09-10T09:47:00.811Z","comments":true,"path":"2019/04/28/lian-biao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/28/lian-biao/","excerpt":"","text":"开始对LeetCode中链表相关问题进行刷题🤔 206. Reverse Linked List题目描述：反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题思路：1 → 2 → 3 → 4→ 5→ Ø，改成 Ø ← 1 ← 2 ← 3←4←5定义一个前结点pre和当前结点cur，在遍历列表时，将当前节点的 next 指针改为指向前面一个元素。 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode pre = null; //前一个节点 ListNode cur = head; while (cur != null) { ListNode nextNode = cur.next; cur.next = pre; //指针指向前一个结点 pre = cur; cur = nextNode; } return pre; } } 21. Merge Two Sorted Lists题目描述：合并两个已排序的链表，并将其作为一个新列表返回。新列表应该通过将前两个列表的节点拼接在一起来创建。 Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路：利用递归，比较两个链表第一个结点的大小，确定头结点的位置 ，头结点确定后，继续在剩下的结点中选出下一个结点去链接到第二步选出的结点后面，然后在继续重复上述步骤，直到有链表为空。 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) return l2; if (l2 == null) return l1; //先判断两个链表的第一个数谁比较大 if(l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next,l2); return l1; } else { l2.next = mergeTwoLists(l1,l2.next); return l2; } } } 83. Remove Duplicates from Sorted List题目描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 Example 1: Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3解题思路：可以使用一个临时指针node，需要注意头指针“head”不应该直接移动或更新，因为它指向列表的头部，你需要在最后返回这个头部。所有操作都应该使用“node”来防止丢失头部。 class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null){ return null; } ListNode node = head; //使用临时指针 while (node.next != null) { if (node.val == node.next.val) { node.next = node.next.next; }else{ node = node.next; } } return head; } } 也可以使用递归： class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; } } 24. Swap Nodes in Pairs题目描述：定一个链表，交换每两个相邻节点并返回其头部。 不能修改列表节点中的值，只能更改节点本身。 Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.解题思路：本题同样可以使用递归或者按照迭代，两种方式运行速度和内存都差不多。 迭代： // 1->2->3->4 class Solution { public ListNode swapPairs(ListNode head) { ListNode node = new ListNode(0); node.next = head; ListNode temp = node; while (temp.next != null &amp;&amp; temp.next.next != null) { ListNode l1 = temp.next; ListNode l2 = temp.next.next; ListNode next = l2.next; temp.next = l2; l2.next = l1; l1.next = next; temp = l1; } return node.next; //head此时已被改变 } } 递归： class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode second = head.next; ListNode third = second.next; second.next = head; head.next = swapPairs(third); return second; } } 19.Remove Nth Node From End of List题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.解题思路：题目那里描述可否用一次遍历就完成，刚开始我只想到用两次遍历，后来发现还可以使用双指针实现一次遍历就解题： 两次遍历：删除从列表开头数起的第 (L - n + 1) 个结点，其中 L 是列表的长度。第一次遍历中先算出链表长度，第二次遍历删除该数，注意添加一个临时结点作为辅助，该结点位于列表头部。该结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode temp= new ListNode(0); //临时结点 temp.next = head; ListNode node = head; int length = 0; //链表长度 while (node != null) { node = node.next; length++; } length -= n; node = temp; while (length > 0) { length--; node = node.next; } node.next = node.next.next; return temp.next; } } 一次遍历：使用两个指针，第一个指针fast先开始移动n步，然后第二个指针slow从头开始移动，此时第一个指针也一起移动，这样就可以使得在移动过程中两个指针保持n步的距离，直到fast到达最后一个结点。此时slow将指向从最后一个结点数起的第 n 个结点，我们重新链接slow所引用的结点的 next 指针指向该结点的下下个结点。 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode fast = head; while (n-- > 0) { fast = fast.next; } if (fast == null) return head.next; //防止极端情况 ListNode slow = head; while (fast.next != null) { fast = fast.next; slow = slow.next; } slow.next = slow.next.next; return head; } } 725. Split Linked List in Parts题目描述：给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。返回一个符合上述规则的链表的列表。举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ] 示例 1： 输入: root = [1, 2, 3], k = 5 输出: [[1],[2],[3],[],[]] 解释: 输入输出各部分都应该是链表，而不是数组。 例如, 输入的结点 root 的 val= 1, root.next.val = 2, \\root.next.next.val = 3, 且 root.next.next.next = null。 第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。 最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。 示例 2： 输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3 输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]] 解释: 输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。解题思路：首先求出链表长度，然后看链表长度是否平均分配，对其求余数即可，然后用数组来保存每一个切割那部分，最终将切断上一部分的最后一个节点和下一部分的第一个节点之间的链接。 class Solution { public ListNode[] splitListToParts(ListNode root, int k) { ListNode node = root; int length = 0; //链表长度 while (node != null) { length++; node = node.next; } node = root; int mod = length % k; //哪一个多余 int size = length / k; //分成几部分 ListNode result [] = new ListNode[k]; //用数组保存 for (int i = 0; node != null &amp;&amp; i &lt; k; i++) { result[i] = node; int cursize = size + (mod-- > 0 ? 1:0); for (int j = 0; j &lt; cursize - 1; j++) { node = node.next; } ListNode next = node.next; node.next = null; node = next; } return result; } } 总结：在链表中要理解每个节点和每个节点是相连的，如何来求链表长度，时刻要注意使用临时指针来代替头部分或者其他部分；用两个指针（一个快指针，一个慢指针）求链表中的中间结点；同时中也要灵活运用递归和迭代。 对链表刷题告一段落，开始新的tag刷题😀","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/链表/"}]},{"title":"LeetCode中栈和队列相关题目","slug":"栈和队列","date":"2019-04-15T08:28:52.000Z","updated":"2019-09-10T09:48:53.469Z","comments":true,"path":"2019/04/15/zhan-he-dui-lie/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/15/zhan-he-dui-lie/","excerpt":"","text":"栈和队列开始对数据结构中栈和队列相关题目进行刷题~ 155. 最小栈题目描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 解题思路：最小值栈问题，可以使用两个栈，一个存放数据，一个存放最小值，每次插入数据时两个栈都要插入，删除时每个栈也要删除。 这里还有一个栈的解决方案值得参考 class MinStack { private Stack&lt;Integer> dataStack; //存放数据 private Stack&lt;Integer> minStack; //存最小值 int min; /** initialize your data structure here. */ public MinStack() { dataStack = new Stack&lt;>(); minStack = new Stack&lt;>(); min = Integer.MAX_VALUE; } public void push(int x) { dataStack.push(x); min = Math.min(min,x); minStack.push(min); } public void pop() { dataStack.pop(); minStack.pop(); min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek(); } public int top() { return dataStack.peek(); } public int getMin() { return minStack.peek(); } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(x); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ 232. 用栈实现队列题目描述：使用栈实现队列的下列操作： push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 示例：MyQueue queue = new MyQueue(); queue.push(1);queue.push(2);queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 解题思路：栈的特点是后进先出，而队列是先进先出，因此，可以考虑用两个栈来实现，这样就能达到先进先出的效果。stack1表示入栈，stack2表示出栈。 class MyQueue { private Stack&lt;Integer> stack1; //入栈 private Stack&lt;Integer> stack2; //出栈 /** Initialize your data structure here. */ public MyQueue() { stack1 = new Stack&lt;>(); stack2 = new Stack&lt;>(); } /** Push element x to the back of queue. */ public void push(int x) { stack1.push(x); } /** Removes the element from in front of queue and returns that element. */ public int pop() { peek(); //执行代码类同peek() 故用peek代替 return stack2.pop(); } /** Get the front element. */ public int peek() { if (stack2.isEmpty()){ while (!stack1.isEmpty()) { int temp = stack1.pop(); stack2.push(temp); } } return stack2.peek(); } /** Returns whether the queue is empty. */ public boolean empty() { return stack2.isEmpty() &amp;&amp; stack1.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈题目描述：使用队列实现栈的下列操作： push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空 解题思路：用队列实现栈的话使用一个队列就可以，因为在一开始队列为空，需要进行push操作，所以将 x 插入队列尾部之后，需要让除了 x 之外的所有元素先出队列，再入队列。 class MyStack { private Queue&lt;Integer> queue; /** Initialize your data structure here. */ public MyStack() { queue = new LinkedList&lt;>(); } /** Push element x onto stack. */ public void push(int x) { queue.offer(x); int size = queue.size(); while(--size > 0) { queue.offer(queue.poll()); } } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue.poll(); } /** Get the top element. */ public int top() { return queue.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ 20. 有效的括号题目描述： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: &quot;()&quot; 输出: true 示例 2: 输入: &quot;()[]{}&quot; 输出: true 示例 3: 输入: &quot;(]&quot; 输出: false 示例 4: 输入: &quot;([)]&quot; 输出: false 示例 5: 输入: &quot;{[]}&quot; 输出: true解题思路： 先判断开头，然后用一个栈来保存结尾，根据其后进先出得特点，然后每次再弹出。 class Solution { public boolean isValid(String s) { Stack&lt;Character> stack = new Stack&lt;>(); for (char c : s.toCharArray()){ if (c == '('){ stack.push(')'); } else if (c == '{') { stack.push('}'); } else if (c == '[') { stack.push(']'); } else if (stack.isEmpty() || stack.pop() != c) { return false; } } return stack.isEmpty(); } } 对栈和队列的刷题告一段落，开始继续新的阶段刷题。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"栈和队列","slug":"栈和队列","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/栈和队列/"}]},{"title":"LeetCode中常见的堆排序","slug":"排序","date":"2019-04-07T01:25:08.000Z","updated":"2019-09-10T09:42:21.787Z","comments":true,"path":"2019/04/07/pai-xu/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/07/pai-xu/","excerpt":"","text":"堆排序今天在刷leetcode215题，碰到求解 TopK Elements问题，一共有三种方法，总结一下： 题目描述：找到未排序数组中的第k个最大元素。请注意，它是排序顺序中的第k个最大元素，而不是第k个不同元素。 Input: [3,2,1,5,6,4] and k = 2 Output: 5 Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 解题方法：1、对整个输入数组进行排序，然后通过它的索引（即O（1））操作访问该元素： ​ 时间复杂度 O(NlogN)，空间复杂度 O(1)。 public int findKthLargest(int[] nums, int k) { final int N = nums.length; Arrays.sort(nums); return nums[N - k]; } 2、堆排序也可以用于求解 Kth Element 问题，堆顶元素就是 Kth Element。使用面向最小值的优先级队列来存储第K个最大值。该算法迭代整个输入并维持优先级队列的大小。优先队列可以用堆来实现： 时间复杂度 O(NlogK)，空间复杂度 O(K)。 public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer> pq = new PriorityQueue&lt;>(); // 小顶堆 for (int val : nums) { pq.add(val); if (pq.size() > k) // 维护堆的大小为 K pq.poll(); } return pq.peek(); } 3、基于切分partion的快速选择算法；快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 k 个元素。 时间复杂度 最佳情况：O(N) 最坏情况：O（N ^ 2），空间复杂度 O(1) 我们如何才能改进上述解决方案并使其保证O（N）？答案非常简单，刚开始时要对数组进行洗牌shuffle，使其随机化输入，这样即使提供最坏情况输入，算法也不会受到影响。因此，所需要做的就是改变输入。 public int findKthLargest(int[] nums, int k) { shuffle(nums);//打乱数组 k = nums.length - k; int lo = 0; int hi = nums.length - 1; while (lo &lt; hi) { final int j = partition(nums, lo, hi); if(j &lt; k) { lo = j + 1; } else if (j > k) { hi = j - 1; } else { break; } } return nums[k]; } //切分 private int partition(int[] a, int lo, int hi) { int i = lo; int j = hi + 1; while(true) { while(i &lt; hi &amp;&amp; less(a[++i], a[lo])); while(j > lo &amp;&amp; less(a[lo], a[--j])); if(i >= j) { break; } exch(a, i, j); } exch(a, lo, j); return j; } //交换 private void exch(int[] a, int i, int j) { final int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } //比较是否小于 private boolean less(int v, int w) { return v &lt; w; } private void shuffle(int a[]) { final Random random = new Random(); for(int ind = 1; ind &lt; a.length; ind++) { final int r = random.nextInt(ind + 1); exch(a, ind, r); } } 桶排序Leetcode : 347. Top K Frequent Elements (Medium) 找出出现频率最多的 k 个数 题目描述：给定非空的整数数组，返回k个最常见的元素。 Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Input: nums = [1], k = 1 Output: [1]解决方法：设置若干个桶，每个桶存储出现频率相同的数，并且桶的下标代表桶中数出现的频率。 class Solution { public List&lt;Integer> topKFrequent(int[] nums, int k) { Map&lt;Integer,Integer> map = new HashMap&lt;>(); for(int a : nums){ map.put(a,map.getOrDefault(a,0)+1);//判断a是否存在，如果没出现 } List&lt;Integer> [] buckets = new ArrayList[nums.length + 1]; for(int i : map.keySet()){ int frequency = map.get(i); if(buckets[frequency]==null){ buckets[frequency] = new ArrayList&lt;>(); } buckets[frequency].add(i); } List&lt;Integer> topK = new ArrayList&lt;>(); //从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数 for(int i = buckets.length - 1; i >= 0 &amp;&amp; topK.size() &lt; k;i--){ if(buckets[i]!=null){ topK.addAll(buckets[i]); } } return topK; } } 荷兰国旗问题：75. Sort Colors (Medium) 题目描述：给定一个具有红色，白色或蓝色的n个对象的数组，对它们进行就地 排序，使相同颜色的对象相邻，颜色顺序为红色，白色和蓝色。 这里，我们将使用整数0,1和2分别表示红色，白色和蓝色。 注意： 您不应该使用库的排序功能来解决此问题。 Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]解决方法：使用三向切分快速排序，将数组分成三个区间：等于红色、等于白色、等于蓝色。 class Solution { public void sortColors(int[] nums) { int zero = 0; int two = nums.length - 1; int one = 0; while(one &lt;= two){ if (nums[one] == 0){ swap(nums,zero++,one++);//从前面开始交换的已经比较过了 }else if (nums[one] == 2){ swap(nums,two--,one);//这里注意one不要++，从后面交换到前面的还无法比较 }else { one++; } } } private static void swap(int [] nums,int a,int b){ int i = nums[a]; nums[a] = nums[b]; nums[b] = i; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"Sort","slug":"Sort","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/Sort/"}]},{"title":"LeetCode中常见的贪心题目","slug":"贪心算法","date":"2019-04-01T10:45:28.000Z","updated":"2019-09-10T09:45:03.856Z","comments":true,"path":"2019/04/01/tan-xin-suan-fa/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/04/01/tan-xin-suan-fa/","excerpt":"","text":"贪心算法：定义：贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 455. Assign Cookies题目描述：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意：你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2.解题思路：贪心就是给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。因为最小的孩子最容易得到满足，所以先满足最小的孩子。通过使用这种贪婪的方法，浪费的cookie的总和将是最小的。因此要对两个数组进行排序，然后进行比较即可。 //[1,2], [1,2,3] class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int gi = 0, si = 0; while (si &lt; s.length &amp;&amp; gi &lt; g.length) { if (g[gi] &lt;= s[si]) { gi++; } si++; } return gi; } } 435. Non-overlapping Intervals题目描述：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。解题思路：经典的贪婪问题：间隔调度，下面那一题LeetCode452也是同样思路 先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。 按区间的结尾进行升序排序，每次选择结尾最小，并且和前一个区间不重叠的区间。 在对数组进行排序的时候也可以使用 lambda 表示式来创建 Comparator ，不过算法运行时间会比较长点。 class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length == 0) { return 0; } Arrays.sort(intervals,new Comparator&lt;int [] >(){ public int compare(int [] a1,int [] a2) { return a1[1] - a2[1]; //升序排列 } }); int count = 1; //最多能组成的不重叠区间个数 int end = intervals[0][1]; for (int i = 0; i &lt; intervals.length; i++) { if (intervals[i][0] &lt; end) { continue; } end = intervals[i][1]; count++; } return intervals.length - count; } } 452. Minimum Number of Arrows to Burst Balloon题目描述：在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 输入: [[10,16], [2,8], [1,6], [7,12]] 输出: 2 解释: 对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。解题思路：本题跟上一题几乎一样的实现方法，说白了就是计算不重叠的区间个数，并且按结束坐标对数组进行排序，然后遍历判断不过这里注意[1, 2] 和 [2, 3] 在本题中算是重叠区间。在这里我对数组进行排序时用lambda表达式，相对实现Comparator接口较慢。代码如下： class Solution { public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points,(i1,i2) -> (i1[1] - i2[1])); //使用Lambda表达式排序，按 int count = 1; int end = points[0][1]; for (int i = 0; i &lt; points.length; i++) { if (points[i][0] &lt;= end) { //注意这里是&lt;= continue; //属于重复区间，跳过，不用增加count次数 } end = points[i][1]; count++; } return count; } } 605. Can Place Flowers题目描述：假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。 解题思路：贪婪地在从左到右遍历，在遇到的每个空地上放一朵花。获取上一个和下一个花坛，如果i位于首位或者末端，则前一个或者下一个被认为是0。 class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int length = flowerbed.length; int count = 0; for(int i = 0; i &lt; length &amp;&amp; count &lt; n; i++) { if (flowerbed[i] == 0) { int pre = (i == 0)? 0 : flowerbed[i-1]; //上一个花坛 int next = (i == length - 1)? 0 : flowerbed[i+1]; //下一个花坛 if(pre == 0 &amp;&amp; next == 0) { count++; flowerbed[i] = 1; } } } return count == n; } } 121. Best Time to Buy and Sell Stock题目描述：给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。解题思路：从头遍历数组，比较两个数之中谁比较大，这里注意卖出价格要大于买入价格，如果第一个值比第二个值大，由于贪心策略，要求最大收益，因此把最小价格赋值给第二个，如果第一个值比第二个小，则将当前价格 即 售出价格减去最小价格，则为最大利益，遍历完即可。 class Solution { public int maxProfit(int[] prices) { if (prices.length &lt;= 1) { return 0; } int temp = prices[0]; //最小价格 int max = 0; //最大收益 for (int i = 1; i &lt; prices.length; i++){ if (temp > prices[i]) { temp = prices[i]; } else { max = Math.max(max,prices[i] - temp); } } return max; } } 665. Non-decreasing Array题目描述：给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。 示例 1: 输入: [4,2,3] 输出: True 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2: 输入: [4,2,1] 输出: False 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 说明: n 的范围为 [1, 10,000]。解题思路：如果我们遇到一个失败的情况，即不是非递减数列，我们需要进行修正。可以通过以下两种方式之一进行更正： 使前一个数字小于或等于当前数字 使当前数字等于先前的数字当找到nums[i-1] &gt; nums[i]，采用方式一，通过改变nums[i-1]的值，这样不会影响了后续操作。还有，如果nums[i-2] &gt; nums[i]，采用方式二，改变nums[i]的值。class Solution { public boolean checkPossibility(int[] nums) { int length = nums.length; int count = 0; for (int i = 1; i &lt; length &amp;&amp; count &lt; 2; i++) { if (nums[i] >= nums[i - 1]) { continue; } count++; if (i - 2 >= 0 &amp;&amp; nums[i - 2] > nums[i]) { nums[i] = nums[i - 1]; //使当前数字等于先前的数字 } else { nums[i - 1] = nums[i]; //使前一个数字小于或等于当前数字 } } return count &lt;= 1; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/贪心/"}]},{"title":"LeetCode中常见的双指针题目","slug":"双指针","date":"2019-03-20T10:45:28.000Z","updated":"2019-09-10T09:45:37.599Z","comments":true,"path":"2019/03/20/shuang-zhi-zhen/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/20/shuang-zhi-zhen/","excerpt":"","text":"双指针：最近在刷leetcode，碰到了许多双指针类的题目，在这里总结下：所谓双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向或者相反方向的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。 (注：这里的指针，并非专指c中指针的概念，而是指索引，游标或指针，可迭代对象等) 167 .两个Sum II - 输入数组已排序题目：定给一个已按照升序个结果排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1和index2，其中index1必须小于index2 。 说明： 返回的下标值（index1和index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入：数字= [ 2,7,11,15 ]，目标= 9 输出： [1,2] 解释： 2与7之和等于目标数9.因此index1 = 1，index2 = 2。解决方法： 使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和sum == target，那么得到要求的结果; 如果sum&gt; target，移动较大的元素，使sum变小一些; 如果sum &lt;target，移动较小的元素，使sum变大一些。 public int[] twoSum(int[] numbers, int target) { int i = 0, j = numbers.length - 1; while (i &lt; j) { int sum = numbers[i] + numbers[j]; if (sum == target) { return new int[]{i + 1, j + 1}; } else if (sum &lt; target) { i++; } else { j--; } } return null; } 141. 环形链表问题：给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 **示例 3：** 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 解决：使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇，好比于操场，如果一个用走，一个用跑，两个肯定相遇。 public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode l1 = head, l2 = head.next; while (l1 != null &amp;&amp; l2 != null &amp;&amp; l2.next != null) { if (l1 == l2) { return true; } l1 = l1.next; l2 = l2.next.next; } return false; } 345 .反转字符串中的元音字母问题：编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: &quot;hello&quot; 输出: &quot;holle&quot;示例 2: 输入: &quot;leetcode&quot; 输出: &quot;leotcede&quot;解决：使用双指针指向待反转的两个元音字符，一个指针从头向尾遍历，一个指针从尾到头遍历。 private final static HashSet&lt;Character> vowels = new HashSet&lt;>(Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); public String reverseVowels(String s) { int i = 0, j = s.length() - 1; char[] result = new char[s.length()]; while (i &lt;= j) { char ci = s.charAt(i); char cj = s.charAt(j); if (!vowels.contains(ci)) { result[i++] = ci; } else if (!vowels.contains(cj)) { result[j--] = cj; } else { result[i++] = cj; result[j--] = ci; } } return new String(result); } 680. 验证回文字符串 Ⅱ问题：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: &quot;aba&quot; 输出: True示例 2: 输入: &quot;abca&quot; 输出: True 解释: 你可以删除c字符。注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解决：先写一个是否是回文的函数，然后再使用双指针，只要是回文数，头尾指针在遍历时肯定一样，如果不一样，可以去掉一个，增加i或减小j； public boolean validPalindrome(String s) { int i = -1, j = s.length(); while (++i &lt; --j) { if (s.charAt(i) != s.charAt(j)) { return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j); } } return true; } private boolean isPalindrome(String s, int i, int j) { while (i &lt; j) { if (s.charAt(i++) != s.charAt(j--)) { return false; } } return true; } 88. 合并两个有序数组问题：给定两个有序整数数组 nums1 和 nums2*，将 *nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n*）来保存 *nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解决：使用双指针，需要从尾开始遍历，否则在nums1上归并得到的值会覆盖还未进行归并比较的值。 public void merge(int[] nums1, int m, int[] nums2, int n) { int index1 = m - 1, index2 = n - 1; int indexMerge = m + n - 1; while (index1 >= 0 || index2 >= 0) { if (index1 &lt; 0) { nums1[indexMerge--] = nums2[index2--]; } else if (index2 &lt; 0) { nums1[indexMerge--] = nums1[index1--]; } else if (nums1[index1] > nums2[index2]) { nums1[indexMerge--] = nums1[index1--]; } else { nums1[indexMerge--] = nums2[index2--]; } } } 633. 平方数之和问题：给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5示例2: 输入: 3 输出: False解决：一个从头遍历，一个从目标数字的开方往回遍历，如果目标数字大于实际数字，则i++;如果目标数字小于实际数字，则j–;如果目标数字等于实际数字，则找到了; public boolean judgeSquareSum(int c) { int i = 0, j = (int) Math.sqrt(c); while (i &lt;= j) { int powSum = i * i + j * j; if (powSum == c) { return true; } else if (powSum > c) { j--; } else { i++; } } return false; }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/双指针/"}]},{"title":"LeetCode中的二分查找","slug":"二分查找","date":"2019-03-08T07:25:08.000Z","updated":"2019-09-10T09:40:34.940Z","comments":true,"path":"2019/03/08/er-fen-cha-zhao/","link":"","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/2019/03/08/er-fen-cha-zhao/","excerpt":"","text":"二分查找最近在看算法第四版，其中有说到二分搜索，也就是二分查找，也在LeetCode上刷题，总结下 定义二分查找又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。 优缺点优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。使用条件：查找序列是顺序结构，有序。 时间复杂度每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。 空间复杂度算法的空间复杂度并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数 非递归方式： 由于辅助空间是常数级别的所以： 空间复杂度是O(1); 递归方式： 递归的次数和深度都是log2 N,每次所需要的辅助空间都是常数级别的： 空间复杂度：O(log2N ) 实现1.非递归代码(使用的比较多) public static int biSearch(int []array,int a){ int lo=0; int hi=array.length-1; int mid; while(lo&lt;=hi){ mid=(lo+hi)/2; if(array[mid]==a){ return mid+1; }else if(array[mid]&lt;a){ lo=mid+1; }else{ hi=mid-1; } } return -1; } 2.递归实现 public static int sort(int []array,int a,int lo,int hi){ if(lo&lt;=hi){ int mid=(lo+hi)/2; if(a==array[mid]){ return mid+1; } else if(a>array[mid]){ return sort(array,a,mid+1,hi); }else{ return sort(array,a,lo,mid-1); } } return -1; } 变种二分查找可以有很多变种，这里介绍两个变种，实现时要注意边界值和区间的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下： 循环条件为 l &lt; h h 的赋值表达式为 h = m 最后返回 l 而不是 -1 另外，在 h 的赋值表达式为 h = mid 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。public int binarySearch(int[] nums, int key) { int l = 0, h = nums.length - 1; while (l &lt; h) { //注意区间范围 int m = l + (h - l) / 2; if (nums[m] >= key) { h = m;//注意这里h的赋值 } else { l = m + 1; } } return l;//最后返回l } 在一个有重复元素的数组中查询元素最后一次出现的位置： public static int biSearch(int []array,int a){ int n=array.length; int low=0; int hi=n-1; int mid=0; while(low&lt;hi){ mid=(low+hi+1)/2; if(array[mid]&lt;=a){ low=mid; }else{ hi=mid-1; } } if(array[low]!=a){ return -1; }else{ return hi; } } Leetcode题目：744、Find Smallest Letter Greater Than Target (Easy) 题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。Input:letters = [“c”, “f”, “j”]target = “a”Output: “c” Input:letters = [“c”, “f”, “j”]target = “c”Output: “f” Input:letters = [“c”, “f”, “j”]target = “d”Output: “f” Input:letters = [“c”, “f”, “j”]target = “g”Output: “j” Input:letters = [“c”, “f”, “j”]target = “j”Output: “c” Input:letters = [“c”, “f”, “j”]target = “k”Output: “c” 解题思路：典型的二分查找的正常实现，最后的时候通过三元运算符判断l跟n大小来决定输出l还是n，在二分查找中，中间值的计算用m = l + (h - l) / 2 比用 m = (l + h) / 2计算要好，可以防止l + h 出现加法溢出。 public char nextGreatestLetter(char[] letters, char target) { int n = letters.length; int l = 0, h = n - 1; while (l &lt;= h) { int m = l + (h - l) / 2; if (letters[m] &lt;= target) { l = m + 1; } else { h = m - 1; } } return l &lt; n ? letters[l] : letters[0]; } 34、Search for a Range (Medium) 题目描述：给定整数数组，数组按升序排序，找出给定目标值的起始位置和结束位置。 您的算法的运行时复杂性必须是O（log n）的顺序。 如果在数组中找不到目标，则返回[-1，-1]。 Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：本题基于二分查找的变种，考虑先写一个方法来判断target(可重复)在数组中出现的最左位置，再求求target+1出现的最左位置，然后进行比较即可。 class Solution { public int[] searchRange(int[] nums, int target) { int first = binarySearch(nums,target); int last = binarySearch(nums,target + 1) -1;//求target+1出现的最左位置 if(first ==nums.length || nums[first]!=target){ return new int []{-1,-1}; }else{ return new int[]{first,first>last?first:last};//当查找的目标数在最后一个时,first大于last } } //从数组中找出重复元素的最左位置 private static int binarySearch(int [] nums,int a){ int l = 0,h = nums.length;//注意这里h的取值，当数组中为[2,2]目标为2时，first和last都为0，所以这里h不能为nums.length-1; while(l &lt; h){ int min = l + (h - l) / 2; if(nums[min] >= a){ h = min; }else{ l = min + 1; } } return l; } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/categories/LeetCode/"}],"tags":[{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://github.com/ForeverSen/ForeverSen.github.io/tags/BinarySearch/"}]}]}